{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>CRIPT (the Community Resource for Innovation in Polymer Technology) is a web-based platform for capturing and sharing polymer data. In addition to a user interface, CRIPT enables programmatic access to the platform through the CRIPT Python SDK, which interfaces with a REST API.</p> <p>CRIPT offers multiple options to upload data, and scientists can pick the method that best suits them. Using the SDK to upload is a great choice if you have a large amount of data, stored it in an unconventional way, and know some python programming. You can easily use a library such as Pandas or Numpy to parse your data, create the needed CRIPT objects/nodes and upload them into CRIPT.</p> <p>Another great option can be the Excel Uploader for scientists that do not have past Python experience or would rather easily input their data into the CRIPT Excel Template.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>CRIPT Availability</p> <p>Currently, CRIPT is only available for users in the USA, and it is equipped with geo-blocking functionality that restricts access for users outside the USA.</p> <p>We are diligently working towards making CRIPT accessible worldwide.  We appreciate your patience as we strive to achieve this goal!</p>"},{"location":"#resources","title":"Resources","text":"CRIPT Resources <ul> <li>CRIPT Data Model<ul> <li>The CRIPT Data Model is the back bone of the whole CRIPT project. Understanding it will make it a lot easier to use any part of the system</li> </ul> </li> <li>CRIPT Scripts Research paper<ul> <li>Learn about the CRIPT platform</li> </ul> </li> <li>CRIPTScripts<ul> <li>CRIPT Scripts is a curated list of examples and tools for interacting with the CRIPT platform.</li> </ul> </li> <li>CRIPT Python SDK Internal Documentation<ul> <li>Learn more about the internal workings of the CRIPT Python SDK</li> </ul> </li> <li>CRIPT Python SDK Discussions Tab<ul> <li>Communicate with the CRIPT Python SDK team</li> </ul> </li> <li>CRIPT Python SDK Contributing Guidelines<ul> <li>Learn how to contribute to the CRIPT Python SDK open-source project</li> </ul> </li> <li>CRIPT Python SDK Contributors</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>Q: Where can I find more information about the CRIPT data model?</p> <p>A: Please feel free to review the CRIPT data model document and the CRIPT research paper</p> <p>Q: What does this error mean?</p> <p>A: Please visit the Exceptions documentation</p> <p>Q: Where do I report an issue that I encountered?</p> <p>A: Please feel free to report issues to our GitHub repository. We are always looking for ways to improve and create software that is a joy to use!</p> <p>Q: Where can I find more CRIPT examples?</p> <p>A: Please visit CRIPT Scripts where there are many CRIPT examples ranging from CRIPT graphs drawn out from research papers, Python scripts, TypeScript scripts, and more!</p> <p>Q: Where can I find more example code?</p> <p>A: We have written a lot of tests for our software, and if needed, those tests can be referred to as example code to work with the Python SDK software. The Python SDK tests are located within the GitHub repository/tests, and there they are broken down to different kinds of tests</p> <p>Q: How can I contribute to this project?</p> <p>A: We would love to have you contribute! Please read our contributing guidelines and our code of conduct to get started. Feel free to contribute to any bugs you find, any issues within the GitHub repository, or any features you want.</p> <p>Q: This repository is awesome, how can I build a plugin to add to it?</p> <p>A: We have built this code with plugins in mind! Please visit the CRIPT Python SDK GitHub repository Wiki tab for developer documentation.</p> <p>Q: Is there documentation detailing the internal workings of the code?</p> <p>A: Absolutely! For an in-depth look at the CRIPT Python SDK code, consult the GitHub repository wiki internal documentation.</p> <p>Q: I have this question that is not covered anywhere, where can I ask it?</p> <p>A: Please visit the CRIPT Python SDK repository and ask your question within the discussions tab Q/A section</p> <p>Q: Where is the best place where I can contact the CRIPT Python SDK team for questions or support?</p> <p>A: We would love to hear from you! Please visit our CRIPT Python SDK Repository GitHub Discussions to easily send us questions. Our repository's issue page is also another good way to let us know about any issues or suggestions you might have. A GitHub account is required.</p> <p>Q: How can I report security issues?</p> <p>A: Please visit the CRIPT Python SDK GitHub repository security tab for any security issues.</p> <p>Q: Where can I find the release notes for each SDK version?</p> <p>A: The release notes can be found on our CRIPT Python SDK repository releases section</p> <p>Q: Besides the user documentation, is there any developer documentation that I can read through on how the code is written to get a better grasp of it?</p> <p>A: You bet! There are documentation for developers within the CRIPT Python SDK Wiki. There you will find documentation on everything from how our code is structure, how we aim to write our documentation, CI/CD, and more.</p> <p>Q: What can I do, when my <code>api.search(...)</code> fails with a <code>cript.nodes.exception.CRIPTJsonDeserializationError</code> or similar?</p> <p>A: _There is a solution for you. Sometimes CRIPT can contain nodes formatted in a way that the Python SDK does not understand. We can disable the automatic conversion from the API response into SDK nodes. Here is an example of how to achieve this: <pre><code># Create API object in with statement, here it assumes host, token, and storage token are in your environment variables\nwith cript.API() as api:\n    # Find the paginator object, which is a python iterator over the search results.\n    materials_paginator = cript_api.search(node_type=cript.Material, search_mode=cript.SearchModes.NODE_TYPE)\n    # Usually you would do\n    # `materials_list = list(materials_paginator)`\n    # or\n    # for node in materials_paginator:\n    #    #do node stuff\n    # But now we want more control over the iteration to ignore failing node decoding.\n    # And store the result in a list of valid nodes\n    materials_list = []\n    # We use a while True loop to iterate over the results\n    while True:\n        # This first try catches, when we reach the end of the search results.\n    # The `next()` function raises a StopIteration exception in that case\n        try:\n        # First we try to convert the current response into a node directly\n            try:\n                material_node = next(materials_paginator)\n        # But if that fails, we catch the exception from CRIPT\n            except cript.CRIPTException as exc:\n                # In case of failure, we disable the auto_load_function temporarily\n                materials_paginator.auto_load_nodes = False\n        # And only obtain the unloaded node JSON instead\n                material_json = next(materials_paginator)\n        # Here you can inspect and manually handle the problem.\n        # In the example, we just print it and ignore it otherwise\n        print(exc, material_json)\n            else:\n        # After a valid node is loaded (try block didn't fail)\n        # we store the valid node in the list\n                materials_list += [material_node]\n            finally:\n            # No matter what happened, for the next iteration we want to try to obtain\n        # an auto loaded node again, so we reset the paginator state.\n                materials_paginator.auto_load_nodes = True\n        except StopIteration:\n        # If next() of the paginator indicates an end of the search results, break the loop\n            break\n</code></pre></p> <p>We try to also have type hinting, comments, and docstrings for all the code that we work on so it is clear and easy for anyone reading it to easily understand.</p> <p>if all else fails, contact us on our GitHub Repository.</p>"},{"location":"utility_functions/","title":"Utility Functions","text":""},{"location":"api/api/","title":"API","text":""},{"location":"api/api/#cript.api.api.API","title":"<code>API</code>","text":""},{"location":"api/api/#cript.api.api.API--definition","title":"Definition","text":"<p>API Client class to communicate with the CRIPT API</p> Source code in <code>src/cript/api/api.py</code> <pre><code>class API:\n    \"\"\"\n    ## Definition\n    API Client class to communicate with the CRIPT API\n    \"\"\"\n\n    # dictates whether the user wants to see terminal log statements or not\n    _logger: logging.Logger = None  # type: ignore\n\n    _host: str = \"\"\n    _api_token: str = \"\"\n    _storage_token: str = \"\"\n    _db_schema: Optional[DataSchema] = None\n    _api_prefix: str = \"api\"\n    _api_version: str = \"v1\"\n    _api_request_session: Union[None, requests.Session] = None\n\n    # trunk-ignore-begin(cspell)\n    # AWS S3 constants\n    _REGION_NAME: str = \"us-east-1\"\n    _IDENTITY_POOL_ID: str = \"us-east-1:9426df38-994a-4191-86ce-3cb0ce8ac84d\"\n    _COGNITO_LOGIN_PROVIDER: str = \"cognito-idp.us-east-1.amazonaws.com/us-east-1_SZGBXPl2j\"\n    _BUCKET_NAME: str = \"cript-user-data\"\n    _BUCKET_DIRECTORY_NAME: str = \"python_sdk_files\"\n    _internal_s3_client: Any = None  # type: ignore\n    # trunk-ignore-end(cspell)\n\n    extra_api_log_debug_info: bool = False\n\n    @beartype\n    def __init__(self, host: Union[str, None] = None, api_token: Union[str, None] = None, storage_token: Union[str, None] = None, config_file_path: Union[str, Path] = \"\", default_log_level=logging.INFO):\n        \"\"\"\n        Initialize CRIPT API client with host and token.\n        Additionally, you can  use a config.json file and specify the file path.\n\n        !!! note \"api client context manager\"\n            It is necessary to use a `with` context manager for the API\n\n        Examples\n        --------\n        ### Create API client with host and token\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; with cript.API(\n        ...     host=\"https://api.criptapp.org/\",\n        ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n        ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n        ... ) as api:\n        ...    # node creation, api.save(), etc.\n        ...    pass\n\n\n        ---\n\n        ### Creating API Client\n        !!! Warning \"Token Security\"\n            It is **highly** recommended that you store your API tokens in a safe location and read it into your code\n            Hard-coding API tokens directly into the code can pose security risks,\n            as the token might be exposed if the code is shared or stored in a version control system.\n            Anyone that has access to your tokens can impersonate you on the CRIPT platform\n\n        ### Create API Client with Environment Variables\n\n        Another great way to keep sensitive information secure is by using\n        [environment variables](https://www.freecodecamp.org/news/python-env-vars-how-to-get-an-environment-variable-in-python/).\n        Sensitive information can be securely stored in environment variables and loaded into the code using\n        [os.getenv()](https://docs.python.org/3/library/os.html#os.getenv).\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; # securely load sensitive data into the script\n        &gt;&gt;&gt; cript_host = os.getenv(\"cript_host\")\n        &gt;&gt;&gt; cript_api_token = os.getenv(\"cript_api_token\")\n        &gt;&gt;&gt; cript_storage_token = os.getenv(\"cript_storage_token\")\n        &gt;&gt;&gt; with cript.API(\n        ...     host=cript_host, api_token=cript_api_token, storage_token=cript_storage_token\n        ... ) as api:\n        ...     pass\n\n        ### Create API Client with None\n        Alternatively you can configure your system to have an environment variable of\n        `CRIPT_TOKEN` for the API token and `CRIPT_STORAGE_TOKEN` for the storage token, then\n        initialize `cript.API` `api_token` and `storage_token` with `None`.\n\n        The CRIPT Python SDK will try to read the API Token and Storage token from your system's environment variables.\n\n        ```python\n        with cript.API(host=cript_host, api_token=None, storage_token=None) as api:\n            # write your script\n            pass\n        ```\n\n        ### Create API client with config.json\n        `config.json`\n        ```json\n        {\n            \"host\": \"https://api.criptapp.org/\",\n            \"api_token\": \"I am API token\",\n            \"storage_token\": \"I am storage token\"\n        }\n        ```\n\n        Examples\n        --------\n        `my_script.py`\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; # create a file path object of where the config file is\n        &gt;&gt;&gt; config_file_path = Path(__file__) / Path('./config.json')\n        &gt;&gt;&gt; with cript.API(config_file_path=config_file_path) as api:   # doctest: +SKIP\n        ...     # node creation, api.save(), etc.\n        ...     pass\n\n        Parameters\n        ----------\n        host : str, None\n            CRIPT host for the Python SDK to connect to such as https://api.criptapp.org/`\n            This host address is the same address used to login to cript website.\n            If `None` is specified, the host is inferred from the environment variable `CRIPT_HOST`.\n        api_token : str, None\n            CRIPT API Token used to connect to CRIPT and upload all data with the exception to file upload that needs\n            a different token.\n            You can find your personal token on the cript website at User &gt; Security Settings.\n            The user icon is in the top right.\n            If `None` is specified, the token is inferred from the environment variable `CRIPT_TOKEN`.\n        storage_token: str\n            This token is used to upload local files to CRIPT cloud storage when needed\n        config_file_path: str\n            the file path to the config.json file where the token and host can be found\n\n\n        Notes\n        -----\n        * if `host=None` and `token=None`\n            then the Python SDK will grab the host from the users environment variable of `\"CRIPT_HOST\"`\n            and `\"CRIPT_TOKEN\"`\n\n        Warns\n        -----\n        UserWarning\n            If `host` is using \"http\" it gives the user a warning that HTTP is insecure and the user should use HTTPS\n\n        Raises\n        ------\n        CRIPTConnectionError\n            If it cannot connect to CRIPT with the provided host and token a CRIPTConnectionError is thrown.\n\n        Returns\n        -------\n        None\n            Instantiate a new CRIPT API object\n        \"\"\"\n\n        # if there is a config.json file or any of the parameters are None, then get the variables from file or env vars\n        if config_file_path or (host is None or api_token is None or storage_token is None):\n            authentication_dict: Dict[str, str] = resolve_host_and_token(host, api_token=api_token, storage_token=storage_token, config_file_path=config_file_path)\n\n            host = authentication_dict[\"host\"]\n            api_token = authentication_dict[\"api_token\"]\n            storage_token = authentication_dict[\"storage_token\"]\n\n        self._host: str = host.rstrip(\"/\")\n        self._api_token = api_token  # type: ignore\n        self._storage_token = storage_token  # type: ignore\n\n        # set a logger instance to use for the class logs\n        self._init_logger(default_log_level)\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        States the host of the CRIPT API client\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; with cript.API(\n        ...     host=\"https://api.criptapp.org/\",\n        ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n        ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n        ... ) as api:\n        ...     print(api)\n        CRIPT API Client - Host URL: 'https://api.criptapp.org'\n\n        Returns\n        -------\n        str\n        \"\"\"\n        return f\"CRIPT API Client - Host URL: '{self.host}'\"\n\n    def _init_logger(self, log_level=logging.INFO) -&gt; None:\n        \"\"\"\n        Prepare and configure the logger for the API class.\n\n        This function creates and configures a logger instance associated with the current module (class).\n\n        Parameters\n        ----------\n        log_level: logging.LEVEL default logging.INFO\n            set if you want `cript.API` to give logs to console or not\n\n        Returns\n        -------\n        logging.Logger\n            The configured logger instance.\n        \"\"\"\n        # Create a logger instance associated with the current module\n        logger = logging.getLogger(__name__)\n\n        logger.setLevel(log_level)\n\n        # Activate Warning handling\n        logging.captureWarnings(True)\n\n        # Create a console handler\n        console_handler = logging.StreamHandler()\n\n        # Create a formatter for log messages (customize the format as desired)\n        formatter = logging.Formatter(\"%(levelname)s: %(message)s\")\n\n        # Associate the formatter with the console handler\n        console_handler.setFormatter(formatter)\n\n        # Add the console handler to the logger\n        logger.addHandler(console_handler)\n\n        # set logger for the class\n        self._logger = logger\n\n    @property\n    def logger(self):\n        return self._logger\n\n    # Use a property to ensure delayed init of s3_client\n    @property\n    def _s3_client(self) -&gt; boto3.client:  # type: ignore\n        \"\"\"\n        Property to use when wanting to interact with AWS S3.\n\n        Gets a fully authenticated AWS S3 client if it was never created and stash it,\n        if the AWS S3 client has been created before, then returns the client that it has\n\n        Returns\n        -------\n        s3_client: boto3.client\n            fully prepared and authenticated s3 client ready to be used throughout the script\n        \"\"\"\n        if self._internal_s3_client is None:\n            self._internal_s3_client = get_s3_client(region_name=self._REGION_NAME, identity_pool_id=self._IDENTITY_POOL_ID, cognito_login_provider=self._COGNITO_LOGIN_PROVIDER, storage_token=self._storage_token)\n\n        return self._internal_s3_client\n\n    def __enter__(self):\n        self.connect()\n        return self\n\n    @beartype\n    def __exit__(self, type, value, traceback):\n        self.disconnect()\n\n    def connect(self):\n        \"\"\"\n        Connect this API globally as the current active access point.\n        It is not necessary to call this function manually if a context manager is used.\n        A context manager is preferred where possible.\n        Jupyter notebooks are a use case where this connection can be handled manually.\n        If this function is called manually, the `API.disconnect` function has to be called later.\n\n        For manual connection: nested API object are discouraged.\n\n        Raises\n        -------\n        CRIPTConnectionError\n            raised when the host does not give the expected response\n        \"\"\"\n\n        # Establish a requests session object\n        if self._api_request_session:\n            self.disconnect()\n        self._api_request_session = requests.Session()\n        # add Bearer to token for HTTP requests\n        self._api_request_session.headers = {\"Authorization\": f\"Bearer {self._api_token}\", \"Content-Type\": \"application/json\"}\n\n        # As a form to check our connection, we pull and establish the data schema\n        try:\n            self._db_schema = DataSchema(self)\n        except APIError as exc:\n            raise CRIPTConnectionError(self.host, self._api_token) from exc\n\n        # Store the last active global API (might be None)\n        global _global_cached_api\n        self._previous_global_cached_api = copy.copy(_global_cached_api)\n        _global_cached_api = self\n        return self\n\n    def disconnect(self):\n        \"\"\"\n        Disconnect this API from the active access point.\n        It is not necessary to call this function manually if a context manager is used.\n        A context manager is preferred where possible.\n        Jupyter notebooks are a use case where this connection can be handled manually.\n        This function has to be called manually if  the `API.connect` function has to be called before.\n\n        For manual connection: nested API object are discouraged.\n        \"\"\"\n        # Disconnect request session\n        if self._api_request_session:\n            self._api_request_session.close()\n\n        # Restore the previously active global API (might be None)\n        global _global_cached_api\n        _global_cached_api = self._previous_global_cached_api\n\n    @property\n    def schema(self):\n        \"\"\"\n        Access the CRIPT Database Schema that is associated with this API connection.\n        The CRIPT Database Schema is used  to validate a node's JSON so that it is compatible with the CRIPT API.\n        \"\"\"\n        return self._db_schema\n\n    @property\n    def host(self):\n        \"\"\"\n        Read only access to the currently connected host.\n\n        The term \"host\" designates the specific CRIPT instance to which you intend to upload your data.\n\n        For most users, the host will be `https://api.criptapp.org`\n\n        ```yaml\n        host: https://api.criptapp.org\n        ```\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; with cript.API(\n        ...     host=\"https://api.criptapp.org/\",\n        ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n        ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n        ... ) as api:\n        ...    print(api.host)\n        https://api.criptapp.org\n        \"\"\"\n        return self._host\n\n    @property\n    def api_prefix(self):\n        return self._api_prefix\n\n    @property\n    def api_version(self):\n        return self._api_version\n\n    def save(self, project: Project) -&gt; None:\n        \"\"\"\n        This method takes a project node, serializes the class into JSON\n        and then sends the JSON to be saved to the API.\n        It takes Project node because everything is connected to the Project node,\n        and it can be used to send either a POST or PATCH request to API\n\n        Parameters\n        ----------\n        project: Project\n            the Project Node that the user wants to save\n\n        Raises\n        ------\n        CRIPTAPISaveError\n            If the API responds with anything other than an HTTP of `200`, the API error is displayed to the user\n\n        Returns\n        -------\n        A set of extra saved node UUIDs.\n            Just sends a `POST` or `Patch` request to the API\n        \"\"\"\n        try:\n            self._internal_save(project)\n        except CRIPTAPISaveError as exc:\n            if exc.pre_saved_nodes:\n                for node_uuid in exc.pre_saved_nodes:\n                    # TODO remove all pre-saved nodes by their uuid.\n                    pass\n            raise exc from exc\n\n    def _internal_save(self, node, save_values: Optional[_InternalSaveValues] = None) -&gt; _InternalSaveValues:\n        \"\"\"\n        Internal helper function that handles the saving of different nodes (not just project).\n\n        If a \"Bad UUID\" error happens, we find that node with the UUID and save it first.\n        Then we recursively call the _internal_save again.\n        Because it is recursive, this repeats until no \"Bad UUID\" error happen anymore.\n        This works, because we keep track of \"Bad UUID\" handled nodes, and represent them in the JSON only as the UUID.\n        \"\"\"\n\n        if save_values is None:\n            save_values = _InternalSaveValues()\n\n        # saves all the local files to cloud storage right before saving the Project node\n        # Ensure that all file nodes have uploaded there payload before actual save.\n        for file_node in node.find_children({\"node\": [\"File\"]}):\n            file_node.ensure_uploaded(api=self)\n\n        node.validate(force_validation=True)\n\n        # Dummy response to have a virtual do-while loop, instead of while loop.\n        response = {\"code\": -1}\n        # TODO remove once get works properly\n        force_patch = False\n\n        while response[\"code\"] != 200:\n            # Keep a record of how the state was before the loop\n            old_save_values = copy.deepcopy(save_values)\n            # We assemble the JSON to be saved to back end.\n            # Note how we exclude pre-saved uuid nodes.\n            json_data = node.get_json(known_uuid=save_values.saved_uuid, suppress_attributes=save_values.suppress_attributes).json\n\n            # This checks if the current node exists on the back end.\n            # if it does exist we use `patch` if it doesn't `post`.\n            test_get_response: Dict = self._capsule_request(url_path=f\"/{node.node_type_snake_case}/{str(node.uuid)}/\", method=\"GET\").json()\n            patch_request = test_get_response[\"code\"] == 200\n\n            # TODO remove once get works properly\n            if not patch_request and force_patch:\n                patch_request = True\n                force_patch = False\n            # TODO activate patch validation\n            # node.validate(is_patch=patch_request)\n\n            # If all that is left is a UUID, we don't need to save it, we can just exit the loop.\n            if patch_request and len(json.loads(json_data)) == 1:\n                response = {\"code\": 200}\n                break\n\n            method = \"POST\"\n            url_path = f\"/{node.node_type_snake_case}/\"\n            if patch_request:\n                method = \"PATCH\"\n                url_path += f\"{str(node.uuid)}/\"\n\n            response: Dict = self._capsule_request(url_path=url_path, method=method, data=json_data).json()  # type: ignore\n\n            # if node.node_type != \"Project\":\n            #     test_success: Dict = requests.get(url=f\"{self._host}/{node.node_type_snake_case}/{str(node.uuid)}/\", headers=self._http_headers, timeout=_API_TIMEOUT).json()\n            #     print(\"XYZ\", json_data, save_values, response, test_success)\n\n            # print(json_data, patch_request, response, save_values)\n            # If we get an error we may be able to fix, we to handle this extra and save the bad node first.\n            # Errors with this code, may be fixable\n            if response[\"code\"] in (400, 409):\n                try:\n                    returned_save_values = _fix_node_save(self, node, response, save_values)\n                except CRIPTAPISaveError as exc:\n                    # If the previous error was a duplicated name issue\n                    if \"duplicate item [{'name':\" in str(response[\"error\"]):\n                        # And (second condition) the request failed bc of the now suppressed name\n                        if \"'name' is a required property\" in exc.api_response:\n                            # Raise a save error, with the nice name related error message\n                            raise CRIPTDuplicateNameError(response, json_data, exc) from exc\n                    # Else just raise the exception as normal.\n                    raise exc\n                save_values += returned_save_values\n\n            # Handle errors from patching with too many attributes\n            if patch_request and response[\"code\"] in (400,):\n                suppress_attributes = _identify_suppress_attributes(node, response)\n                new_save_values = _InternalSaveValues(save_values.saved_uuid, suppress_attributes)\n                save_values += new_save_values\n\n            # It is only worthwhile repeating the attempted save loop if our state has improved.\n            # Aka we did something to fix the occurring error\n            if not save_values &gt; old_save_values:\n                # TODO remove once get works properly\n                if not patch_request:\n                    # and response[\"code\"] == 409 and response[\"error\"].strip().startswith(\"Duplicate uuid:\"):  # type: ignore\n                    # duplicate_uuid = _get_uuid_from_error_message(response[\"error\"])  # type: ignore\n                    # if str(node.uuid) == duplicate_uuid:\n                    force_patch = True\n                    continue\n                break\n\n        if response[\"code\"] != 200:\n            raise CRIPTAPISaveError(api_host_domain=self._host, http_code=response[\"code\"], api_response=response[\"error\"], patch_request=patch_request, pre_saved_nodes=save_values.saved_uuid, json_data=json_data)  # type: ignore\n\n        save_values.saved_uuid.add(str(node.uuid))\n        return save_values\n\n    def upload_file(self, file_path: Union[Path, str]) -&gt; str:\n        # trunk-ignore-begin(cspell)\n        \"\"\"\n        uploads a file to AWS S3 bucket and returns a URL of the uploaded file in AWS S3\n        The URL is has no expiration time limit and is available forever\n\n        1. take a file path of type path or str to the file on local storage\n            * see Example for more details\n        1. convert the file path to pathlib object, so it is versatile and\n            always uniform regardless if the user passes in a str or path object\n        1. get the file\n        1. rename the file to avoid clash or overwriting of previously uploaded files\n            * change file name to `original_name_uuid4.extension`\n                *  `document_42926a201a624fdba0fd6271defc9e88.txt`\n        1. upload file to AWS S3\n        1. get the link of the uploaded file and return it\n\n\n        Parameters\n        ----------\n        file_path: Union[str, Path]\n            file path as str or Path object. Path Object is recommended\n\n        Examples\n        --------\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; with cript.API(\n        ...     host=\"https://api.criptapp.org/\",\n        ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n        ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n        ... ) as api:\n        ...     # programmatically create the absolute path of your file, so the program always works correctly\n        ...     my_file_path = (Path(__file__) / Path('../upload_files/my_file.txt')).resolve()\n        ...     my_file_cloud_storage_source = api.upload_file(file_path=my_file_path)  # doctest: +SKIP\n\n        Notes\n        -----\n        We recommend using a [Path](https://docs.python.org/3/library/pathlib.html) object for specifying a file path.\n        Using the Python [pathlib library](https://docs.python.org/3/library/pathlib.html) provides platform-agnostic approach\n        for filesystem operations, ensuring seamless functionality across different operating systems.\n        Additionally, [Path](https://docs.python.org/3/library/pathlib.html) objects offer various built-in methods\n        for more sophisticated and secure file handling and has a easy to use interface that can make working with it a breeze\n        and can help reduce errors.\n\n        Other options include using a raw string for relative/absolute file path,\n        or using the [os.path module](https://docs.python.org/3/library/os.path.html).\n\n\n        Raises\n        ------\n        FileNotFoundError\n            In case the CRIPT Python SDK cannot find the file on your computer because the file does not exist\n            or the path to it is incorrect it raises\n            [FileNotFoundError](https://docs.python.org/3/library/exceptions.html#FileNotFoundError)\n\n        Returns\n        -------\n        object_name: str\n            object_name of the AWS S3 uploaded file to be put into the File node source attribute\n        \"\"\"\n        # trunk-ignore-end(cspell)\n\n        # TODO consider using a new variable when converting `file_path` from parameter\n        #  to a Path object with a new type\n        # convert file path from whatever the user passed in to a pathlib object\n        file_path = Path(file_path).resolve()\n\n        # get file_name and file_extension from absolute file path\n        # file_extension includes the dot, e.g. \".txt\"\n        file_name, file_extension = os.path.splitext(os.path.basename(file_path))\n\n        # generate a UUID4 string without dashes, making a cleaner file name\n        uuid_str: str = str(uuid.uuid4().hex)\n\n        new_file_name: str = f\"{file_name}_{uuid_str}{file_extension}\"\n\n        # e.g. \"directory/file_name_uuid.extension\"\n        object_name: str = f\"{self._BUCKET_DIRECTORY_NAME}/{new_file_name}\"\n\n        # upload file to AWS S3\n        self._s3_client.upload_file(Filename=file_path, Bucket=self._BUCKET_NAME, Key=object_name)  # type: ignore\n\n        self.logger.info(f\"Uploaded File: '{file_path}' to CRIPT storage\")\n\n        # return the object_name within AWS S3 for easy retrieval\n        return object_name\n\n    @beartype\n    def download_file(self, file_source: str, destination_path: str = \".\") -&gt; None:\n        \"\"\"\n        Download a file from CRIPT Cloud Storage (AWS S3) and save it to the specified path.\n\n        ??? Info \"Cloud Storage vs Web URL File Download\"\n\n            If the `object_name` does not starts with `http` then the program assumes the file is in AWS S3 storage,\n            and attempts to retrieve it via\n            [boto3 client](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html).\n\n            If the `object_name` starts with `http` then the program knows that\n            it is a file stored on the web. The program makes a simple\n            [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request to get the file,\n            then writes the contents of it to the specified destination.\n\n            &gt; Note: The current version of the program is designed to download files from the web in a straightforward\n            manner. However, please be aware that the program may encounter limitations when dealing with URLs that\n            require JavaScript or a session to be enabled. In such cases, the download method may fail.\n\n            &gt; We acknowledge these limitations and plan to enhance the method in future versions to ensure compatibility\n            with a wider range of web file URLs. Our goal is to develop a robust solution capable of handling any and\n            all web file URLs.\n\n        Parameters\n        ----------\n        file_source: str\n            `object_name`: file downloaded via object_name from cloud storage and saved to local storage\n            object_name e.g. `\"Data/{file_name}\"`\n            ---\n            `URL file source`: If the file source starts with `http` then it is downloaded via `GET` request and\n            saved to local storage\n           URL file source e.g. `https://criptscripts.org/cript_graph_json/JSON/cao_protein.json`\n        destination_path: str\n            please provide a path with file name of where you would like the file to be saved\n            on local storage.\n            &gt; If no path is specified, then by default it will download the file\n            to the current working directory.\n\n            &gt; The destination path must include a file name and file extension\n                e.g.: `~/Desktop/my_example_file_name.extension`\n\n        Examples\n        --------\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; with cript.API(\n        ...     host=\"https://api.criptapp.org/\",\n        ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n        ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n        ... ) as api:\n        ...     desktop_path = (Path(__file__).parent / \"cript_downloads\" / \"my_downloaded_file.txt\").resolve()\n        ...     my_file = cript.File(\n        ...         name=\"my file node name\",\n        ...         source=\"https://criptapp.org\",\n        ...         type=\"calibration\",\n        ...         extension=\".csv\",\n        ...     )\n        ...     api.download_file(file_source=my_file.source, destination_path=str(desktop_path)) # doctest: +SKIP\n\n        Raises\n        ------\n        FileNotFoundError\n            In case the file could not be found because the file does not exist or the path given is incorrect\n\n        Returns\n        -------\n        None\n            Simply downloads the file\n        \"\"\"\n\n        # if the file source is a URL\n        if file_source.startswith(\"http\"):\n            download_file_from_url(url=file_source, destination_path=Path(destination_path).resolve())\n            return\n\n        # the file is stored in cloud storage and must be retrieved via object_name\n        self._s3_client.download_file(Bucket=self._BUCKET_NAME, Key=file_source, Filename=destination_path)  # type: ignore\n\n    @beartype\n    def search(\n        self,\n        node_type: Any,\n        search_mode: SearchModes,\n        value_to_search: str = \"\",\n    ) -&gt; Paginator:\n        \"\"\"\n        This method is used to perform search on the CRIPT platform.\n\n        Essentially creates needed resources and passes it to paginator to get results from API\n        and display them.\n\n        Examples\n        --------\n        ???+ Example \"Search by Node Type\"\n            ```python\n            materials_iterator = cript_api.search(\n                node_type=cript.Material,\n                search_mode=cript.SearchModes.NODE_TYPE,\n            )\n            ```\n\n        ??? Example \"Search by Contains name\"\n            ```python\n            contains_name_iterator = cript_api.search(\n                node_type=cript.Process,\n                search_mode=cript.SearchModes.CONTAINS_NAME,\n                value_to_search=\"poly\"\n            )\n            ```\n\n        ??? Example \"Search by Exact Name\"\n            ```python\n            exact_name_iterator = cript_api.search(\n                node_type=cript.Project,\n                search_mode=cript.SearchModes.EXACT_NAME,\n                value_to_search=\"Sodium polystyrene sulfonate\"\n            )\n            ```\n\n        ??? Example \"Search by UUID\"\n            ```python\n            uuid_iterator = cript_api.search(\n                node_type=cript.Collection,\n                search_mode=cript.SearchModes.UUID,\n                value_to_search=\"75fd3ee5-48c2-4fc7-8d0b-842f4fc812b7\"\n            )\n            ```\n\n        ??? Example \"Search by BigSmiles\"\n            ```python\n            iterator = cript_api.search(\n                node_type=cript.Material,\n                search_mode=cript.SearchModes.BIGSMILES,\n                value_to_search=\"{[][$]CC(C)(C(=O)OCCCC)[$][]}\"\n            )\n            ```\n\n        Parameters\n        ----------\n        node_type : UUIDBaseNode\n            Type of node that you are searching for.\n        search_mode : SearchModes\n            Type of search you want to do. You can search by name, `UUID`, `EXACT_NAME`, etc.\n            Refer to [valid search modes](../search_modes)\n        value_to_search : str\n            What you are searching for can be either a value, and if you are only searching for\n            a `NODE_TYPE`, then this value can be empty or `None`\n\n        Returns\n        -------\n        Paginator\n            An iterator that will present and fetch the results to the user seamlessly\n\n        Notes\n        -----\n        To learn more about working with pagination, please refer to our\n        [paginator object documentation](../paginator).\n        \"\"\"\n\n        # get node typ from class\n        node_type = node_type.node_type_snake_case\n\n        api_endpoint: str = \"\"\n        limit_node_fetches: Optional[int] = None\n        if search_mode == SearchModes.NODE_TYPE:\n            api_endpoint = f\"/search/{node_type}\"\n            value_to_search = \"\"\n\n        elif search_mode == SearchModes.CONTAINS_NAME:\n            api_endpoint = f\"/search/{node_type}\"\n\n        elif search_mode == SearchModes.EXACT_NAME:\n            api_endpoint = f\"/search/exact/{node_type}\"\n            limit_node_fetches = 1\n\n        elif search_mode == SearchModes.UUID:\n            api_endpoint = f\"/{node_type}/{value_to_search}\"\n            # putting the value_to_search in the URL instead of a query\n            value_to_search = \"\"\n            limit_node_fetches = 1\n\n        elif search_mode == SearchModes.BIGSMILES:\n            api_endpoint = \"/search/bigsmiles/\"\n\n        # error handling if none of the API endpoints got hit\n        else:\n            raise RuntimeError(\"Internal Error: Failed to recognize any search modes. Please report this bug on https://github.com/C-Accel-CRIPT/Python-SDK/issues.\")\n\n        return Paginator(api=self, url_path=api_endpoint, query=value_to_search, limit_node_fetches=limit_node_fetches)\n\n    def delete(self, node) -&gt; None:\n        \"\"\"\n        Simply deletes the desired node from the CRIPT API and writes a log in the terminal that the node has been\n        successfully deleted.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material_node = cript.Material(\n        ...     name=\"my component material 1\",\n        ...     names = [\"component 1 alternative name\"],\n        ... )\n        &gt;&gt;&gt; api.delete(node=my_material_node) # doctest: +SKIP\n\n        Notes\n        -----\n        After the node has been successfully deleted, a log is written to the terminal\n\n        ```bash\n        INFO: Deleted 'Material' with UUID of '80bfc642-157e-4692-a547-97c470725397' from CRIPT API.\n        ```\n\n        ??? info \"Implementation Details\"\n            Under the hood, this method actually calls\n            [delete_node_by_uuid](./#cript.api.api.API.delete_node_by_uuid)\n            with the node_type and node UUID\n\n        Warnings\n        --------\n        After successfully deleting a node from the API, keep in mind that your local Project node in your script\n        may still contain outdated data as it has not been synced with the API.\n\n        To ensure you have the latest data, follow these steps:\n\n        1. Fetch the newest Project node from the API using the [`cript.API.search()`](./#cript.api.api.API.search) provided by the SDK.\n        1. Deserialize the retrieved data into a new Project node using the [`load_nodes_from_json`](../../utility_functions/#cript.nodes.util.load_nodes_from_json) utility function.\n        1. Replace your old Project node with the new one in your script for accurate and up-to-date information.\n\n        Parameters\n        ----------\n        node: UUIDBaseNode\n            The node that you want to delete\n\n        Raises\n        ------\n        APIError\n            If the API responds with anything other than HTTP status 200, then the CRIPT Python SDK raises `APIError`\n            `APIError` is raised in case the API cannot delete the specified node.\n            Such cases can happen if you do not have permission to delete the node\n            or if the node is actively being used elsewhere in CRIPT platform and the API cannot delete it.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.delete_node_by_uuid(node_type=node.node_type_snake_case, node_uuid=str(node.uuid))\n\n    @beartype\n    def delete_node_by_uuid(self, node_type: str, node_uuid: str) -&gt; None:\n        \"\"\"\n        Simply deletes the desired node from the CRIPT API and writes a log in the terminal that the node has been\n        successfully deleted.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; with cript.API(\n        ...     host=\"https://api.criptapp.org/\",\n        ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n        ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n        ... ) as api:\n        ...      api.delete_node_by_uuid(\n        ...         node_type=\"computation_process\",\n        ...         node_uuid=\"2fd3d500-304d-4a06-8628-a79b59344b2f\"\n        ...     ) # doctest: +SKIP\n\n        ??? \"How to get `node_type in snake case`\"\n               You can get the `node type in snake case` of a node via:\n               ```python\n                import cript\n                print(cript.ComputationProcess.node_type_snake_case)\n               computation_process\n               ```\n\n               You can also call `api.delete_node_by_uuid()` with\n               ```python\n               api.delete(\n                   node_type=cript.ComputationProcess.node_type_snake_case,\n                   node_uuid=\"2fd3d500-304d-4a06-8628-a79b59344b2f\",\n               )\n               ```\n\n        Notes\n        -----\n        After the node has been successfully deleted, a log is written\n\n        ```bash\n        INFO: Deleted 'Material' with UUID of '80bfc642-157e-4692-a547-97c470725397' from CRIPT API.\n        ```\n\n        Warnings\n        --------\n        After successfully deleting a node from the API, keep in mind that your local Project node in your script\n        may still contain outdated data as it has not been synced with the API.\n\n        To ensure you have the latest data, follow these steps:\n\n        1. Fetch the newest Project node from the API using the\n        [`cript.API.search()`](./#cript.api.api.API.search) provided by the SDK.\n        1. Deserialize the retrieved data into a new Project node using the\n        [`load_nodes_from_json`](../../utility_functions/#cript.nodes.util.load_nodes_from_json) utility function.\n        1. Replace your old Project node with the new one in your script for accurate and up-to-date information.\n\n        Parameters\n        ----------\n        node_type: str\n           the type of node that you want to delete in snake case\n        node_uuid: str\n           the UUID of the primary node, supporting node, or sub-object\n           that you want to delete from the API\n\n        Raises\n        ------\n        APIError\n            If the API responds with anything other than HTTP status 200, then the CRIPT Python SDK raises `APIError`\n            `APIError` is raised in case the API cannot delete the specified node.\n            Such cases can happen if you do not have permission to delete the node\n            or if the node is actively being used elsewhere in CRIPT platform and the API cannot delete it.\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        response: Dict = self._capsule_request(url_path=f\"/{node_type.lower()}/{node_uuid}/\", method=\"DELETE\").json()\n\n        if response[\"code\"] != 200:\n            raise APIError(api_error=str(response), http_method=\"DELETE\", api_url=f\"/{node_type.lower()}/{node_uuid}/\")\n\n        self.logger.info(f\"Deleted '{node_type.title()}' with UUID of '{node_uuid}' from CRIPT API.\")\n\n    def _capsule_request(self, url_path: str, method: str, api_request: bool = True, timeout: int = _API_TIMEOUT, **kwargs) -&gt; requests.Response:\n        \"\"\"Helper function that capsules every request call we make against the backend.\n\n        Please *always* use this methods instead of `requests` directly.\n        We can log all request calls this way, which can help debugging immensely.\n\n        Parameters\n        ----------\n        url_path:str\n          URL path that we want to request from. So every thing that follows api.host. You can omit the api prefix and api version if you use api_request=True they are automatically added.\n\n        method: str\n          One of `GET`, `OPTIONS`, `HEAD`, `POST`, `PUT, `PATCH`, or `DELETE` as this will directly passed to `requests.request(...)`. See https://docs.python-requests.org/en/latest/api/ for details.\n\n        headers: Dict\n          HTTPS headers to use for the request.\n          If None (default) use the once associated with this API object for authentication.\n\n        timeout:int\n          Time out to be used for the request call.\n\n        kwargs\n          additional keyword arguments that are passed to `request.request`\n        \"\"\"\n\n        url: str = self.host\n        if api_request:\n            url += f\"/{self.api_prefix}/{self.api_version}\"\n        url += url_path\n\n        pre_log_message: str = f\"Requesting {method} from {url}\"\n        if self.extra_api_log_debug_info:\n            pre_log_message += f\" from {traceback.format_stack(limit=4)} kwargs {kwargs}\"\n        pre_log_message += \"...\"\n        self.logger.debug(pre_log_message)\n\n        if self._api_request_session is None:\n            raise CRIPTAPIRequiredError\n        response: requests.Response = self._api_request_session.request(url=url, method=method, timeout=timeout, **kwargs)\n        post_log_message: str = f\"Request return with {response.status_code}\"\n        if self.extra_api_log_debug_info:\n            post_log_message += f\" {response.text}\"\n        self.logger.debug(post_log_message)\n\n        return response\n</code></pre>"},{"location":"api/api/#cript.api.api.API.host","title":"<code>host</code>  <code>property</code>","text":"<p>Read only access to the currently connected host.</p> <p>The term \"host\" designates the specific CRIPT instance to which you intend to upload your data.</p> <p>For most users, the host will be <code>https://api.criptapp.org</code></p> <pre><code>host: https://api.criptapp.org\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; with cript.API(\n...     host=\"https://api.criptapp.org/\",\n...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n... ) as api:\n...    print(api.host)\nhttps://api.criptapp.org\n</code></pre>"},{"location":"api/api/#cript.api.api.API.schema","title":"<code>schema</code>  <code>property</code>","text":"<p>Access the CRIPT Database Schema that is associated with this API connection. The CRIPT Database Schema is used  to validate a node's JSON so that it is compatible with the CRIPT API.</p>"},{"location":"api/api/#cript.api.api.API.__init__","title":"<code>__init__(host=None, api_token=None, storage_token=None, config_file_path='', default_log_level=logging.INFO)</code>","text":"<p>Initialize CRIPT API client with host and token. Additionally, you can  use a config.json file and specify the file path.</p> <p>api client context manager</p> <p>It is necessary to use a <code>with</code> context manager for the API</p> <p>Examples:</p>"},{"location":"api/api/#cript.api.api.API.__init__--create-api-client-with-host-and-token","title":"Create API client with host and token","text":"<pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; with cript.API(\n...     host=\"https://api.criptapp.org/\",\n...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n... ) as api:\n...    # node creation, api.save(), etc.\n...    pass\n</code></pre>"},{"location":"api/api/#cript.api.api.API.__init__--creating-api-client","title":"Creating API Client","text":"<p>Token Security</p> <p>It is highly recommended that you store your API tokens in a safe location and read it into your code Hard-coding API tokens directly into the code can pose security risks, as the token might be exposed if the code is shared or stored in a version control system. Anyone that has access to your tokens can impersonate you on the CRIPT platform</p>"},{"location":"api/api/#cript.api.api.API.__init__--create-api-client-with-environment-variables","title":"Create API Client with Environment Variables","text":"<p>Another great way to keep sensitive information secure is by using environment variables. Sensitive information can be securely stored in environment variables and loaded into the code using os.getenv().</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; # securely load sensitive data into the script\n&gt;&gt;&gt; cript_host = os.getenv(\"cript_host\")\n&gt;&gt;&gt; cript_api_token = os.getenv(\"cript_api_token\")\n&gt;&gt;&gt; cript_storage_token = os.getenv(\"cript_storage_token\")\n&gt;&gt;&gt; with cript.API(\n...     host=cript_host, api_token=cript_api_token, storage_token=cript_storage_token\n... ) as api:\n...     pass\n</code></pre>"},{"location":"api/api/#cript.api.api.API.__init__--create-api-client-with-none","title":"Create API Client with None","text":"<p>Alternatively you can configure your system to have an environment variable of <code>CRIPT_TOKEN</code> for the API token and <code>CRIPT_STORAGE_TOKEN</code> for the storage token, then initialize <code>cript.API</code> <code>api_token</code> and <code>storage_token</code> with <code>None</code>.</p> <p>The CRIPT Python SDK will try to read the API Token and Storage token from your system's environment variables.</p> <pre><code>with cript.API(host=cript_host, api_token=None, storage_token=None) as api:\n    # write your script\n    pass\n</code></pre>"},{"location":"api/api/#cript.api.api.API.__init__--create-api-client-with-configjson","title":"Create API client with config.json","text":"<p><code>config.json</code> <pre><code>{\n    \"host\": \"https://api.criptapp.org/\",\n    \"api_token\": \"I am API token\",\n    \"storage_token\": \"I am storage token\"\n}\n</code></pre></p> <p>Examples:</p> <p><code>my_script.py</code></p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import cript\n&gt;&gt;&gt; # create a file path object of where the config file is\n&gt;&gt;&gt; config_file_path = Path(__file__) / Path('./config.json')\n&gt;&gt;&gt; with cript.API(config_file_path=config_file_path) as api:\n...     # node creation, api.save(), etc.\n...     pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>(str, None)</code> <p>CRIPT host for the Python SDK to connect to such as https://api.criptapp.org/<code>This host address is the same address used to login to cript website. If</code>None<code>is specified, the host is inferred from the environment variable</code>CRIPT_HOST`.</p> <code>None</code> <code>api_token</code> <code>(str, None)</code> <p>CRIPT API Token used to connect to CRIPT and upload all data with the exception to file upload that needs a different token. You can find your personal token on the cript website at User &gt; Security Settings. The user icon is in the top right. If <code>None</code> is specified, the token is inferred from the environment variable <code>CRIPT_TOKEN</code>.</p> <code>None</code> <code>storage_token</code> <code>Union[str, None]</code> <p>This token is used to upload local files to CRIPT cloud storage when needed</p> <code>None</code> <code>config_file_path</code> <code>Union[str, Path]</code> <p>the file path to the config.json file where the token and host can be found</p> <code>''</code> Notes <ul> <li>if <code>host=None</code> and <code>token=None</code>     then the Python SDK will grab the host from the users environment variable of <code>\"CRIPT_HOST\"</code>     and <code>\"CRIPT_TOKEN\"</code></li> </ul> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If <code>host</code> is using \"http\" it gives the user a warning that HTTP is insecure and the user should use HTTPS</p> <p>Raises:</p> Type Description <code>CRIPTConnectionError</code> <p>If it cannot connect to CRIPT with the provided host and token a CRIPTConnectionError is thrown.</p> <p>Returns:</p> Type Description <code>None</code> <p>Instantiate a new CRIPT API object</p> Source code in <code>src/cript/api/api.py</code> <pre><code>@beartype\ndef __init__(self, host: Union[str, None] = None, api_token: Union[str, None] = None, storage_token: Union[str, None] = None, config_file_path: Union[str, Path] = \"\", default_log_level=logging.INFO):\n    \"\"\"\n    Initialize CRIPT API client with host and token.\n    Additionally, you can  use a config.json file and specify the file path.\n\n    !!! note \"api client context manager\"\n        It is necessary to use a `with` context manager for the API\n\n    Examples\n    --------\n    ### Create API client with host and token\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; with cript.API(\n    ...     host=\"https://api.criptapp.org/\",\n    ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n    ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n    ... ) as api:\n    ...    # node creation, api.save(), etc.\n    ...    pass\n\n\n    ---\n\n    ### Creating API Client\n    !!! Warning \"Token Security\"\n        It is **highly** recommended that you store your API tokens in a safe location and read it into your code\n        Hard-coding API tokens directly into the code can pose security risks,\n        as the token might be exposed if the code is shared or stored in a version control system.\n        Anyone that has access to your tokens can impersonate you on the CRIPT platform\n\n    ### Create API Client with Environment Variables\n\n    Another great way to keep sensitive information secure is by using\n    [environment variables](https://www.freecodecamp.org/news/python-env-vars-how-to-get-an-environment-variable-in-python/).\n    Sensitive information can be securely stored in environment variables and loaded into the code using\n    [os.getenv()](https://docs.python.org/3/library/os.html#os.getenv).\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; # securely load sensitive data into the script\n    &gt;&gt;&gt; cript_host = os.getenv(\"cript_host\")\n    &gt;&gt;&gt; cript_api_token = os.getenv(\"cript_api_token\")\n    &gt;&gt;&gt; cript_storage_token = os.getenv(\"cript_storage_token\")\n    &gt;&gt;&gt; with cript.API(\n    ...     host=cript_host, api_token=cript_api_token, storage_token=cript_storage_token\n    ... ) as api:\n    ...     pass\n\n    ### Create API Client with None\n    Alternatively you can configure your system to have an environment variable of\n    `CRIPT_TOKEN` for the API token and `CRIPT_STORAGE_TOKEN` for the storage token, then\n    initialize `cript.API` `api_token` and `storage_token` with `None`.\n\n    The CRIPT Python SDK will try to read the API Token and Storage token from your system's environment variables.\n\n    ```python\n    with cript.API(host=cript_host, api_token=None, storage_token=None) as api:\n        # write your script\n        pass\n    ```\n\n    ### Create API client with config.json\n    `config.json`\n    ```json\n    {\n        \"host\": \"https://api.criptapp.org/\",\n        \"api_token\": \"I am API token\",\n        \"storage_token\": \"I am storage token\"\n    }\n    ```\n\n    Examples\n    --------\n    `my_script.py`\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; # create a file path object of where the config file is\n    &gt;&gt;&gt; config_file_path = Path(__file__) / Path('./config.json')\n    &gt;&gt;&gt; with cript.API(config_file_path=config_file_path) as api:   # doctest: +SKIP\n    ...     # node creation, api.save(), etc.\n    ...     pass\n\n    Parameters\n    ----------\n    host : str, None\n        CRIPT host for the Python SDK to connect to such as https://api.criptapp.org/`\n        This host address is the same address used to login to cript website.\n        If `None` is specified, the host is inferred from the environment variable `CRIPT_HOST`.\n    api_token : str, None\n        CRIPT API Token used to connect to CRIPT and upload all data with the exception to file upload that needs\n        a different token.\n        You can find your personal token on the cript website at User &gt; Security Settings.\n        The user icon is in the top right.\n        If `None` is specified, the token is inferred from the environment variable `CRIPT_TOKEN`.\n    storage_token: str\n        This token is used to upload local files to CRIPT cloud storage when needed\n    config_file_path: str\n        the file path to the config.json file where the token and host can be found\n\n\n    Notes\n    -----\n    * if `host=None` and `token=None`\n        then the Python SDK will grab the host from the users environment variable of `\"CRIPT_HOST\"`\n        and `\"CRIPT_TOKEN\"`\n\n    Warns\n    -----\n    UserWarning\n        If `host` is using \"http\" it gives the user a warning that HTTP is insecure and the user should use HTTPS\n\n    Raises\n    ------\n    CRIPTConnectionError\n        If it cannot connect to CRIPT with the provided host and token a CRIPTConnectionError is thrown.\n\n    Returns\n    -------\n    None\n        Instantiate a new CRIPT API object\n    \"\"\"\n\n    # if there is a config.json file or any of the parameters are None, then get the variables from file or env vars\n    if config_file_path or (host is None or api_token is None or storage_token is None):\n        authentication_dict: Dict[str, str] = resolve_host_and_token(host, api_token=api_token, storage_token=storage_token, config_file_path=config_file_path)\n\n        host = authentication_dict[\"host\"]\n        api_token = authentication_dict[\"api_token\"]\n        storage_token = authentication_dict[\"storage_token\"]\n\n    self._host: str = host.rstrip(\"/\")\n    self._api_token = api_token  # type: ignore\n    self._storage_token = storage_token  # type: ignore\n\n    # set a logger instance to use for the class logs\n    self._init_logger(default_log_level)\n</code></pre>"},{"location":"api/api/#cript.api.api.API.__str__","title":"<code>__str__()</code>","text":"<p>States the host of the CRIPT API client</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; with cript.API(\n...     host=\"https://api.criptapp.org/\",\n...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n... ) as api:\n...     print(api)\nCRIPT API Client - Host URL: 'https://api.criptapp.org'\n</code></pre> <p>Returns:</p> Type Description <code>str</code> Source code in <code>src/cript/api/api.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    States the host of the CRIPT API client\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; with cript.API(\n    ...     host=\"https://api.criptapp.org/\",\n    ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n    ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n    ... ) as api:\n    ...     print(api)\n    CRIPT API Client - Host URL: 'https://api.criptapp.org'\n\n    Returns\n    -------\n    str\n    \"\"\"\n    return f\"CRIPT API Client - Host URL: '{self.host}'\"\n</code></pre>"},{"location":"api/api/#cript.api.api.API.connect","title":"<code>connect()</code>","text":"<p>Connect this API globally as the current active access point. It is not necessary to call this function manually if a context manager is used. A context manager is preferred where possible. Jupyter notebooks are a use case where this connection can be handled manually. If this function is called manually, the <code>API.disconnect</code> function has to be called later.</p> <p>For manual connection: nested API object are discouraged.</p> <p>Raises:</p> Type Description <code>CRIPTConnectionError</code> <p>raised when the host does not give the expected response</p> Source code in <code>src/cript/api/api.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect this API globally as the current active access point.\n    It is not necessary to call this function manually if a context manager is used.\n    A context manager is preferred where possible.\n    Jupyter notebooks are a use case where this connection can be handled manually.\n    If this function is called manually, the `API.disconnect` function has to be called later.\n\n    For manual connection: nested API object are discouraged.\n\n    Raises\n    -------\n    CRIPTConnectionError\n        raised when the host does not give the expected response\n    \"\"\"\n\n    # Establish a requests session object\n    if self._api_request_session:\n        self.disconnect()\n    self._api_request_session = requests.Session()\n    # add Bearer to token for HTTP requests\n    self._api_request_session.headers = {\"Authorization\": f\"Bearer {self._api_token}\", \"Content-Type\": \"application/json\"}\n\n    # As a form to check our connection, we pull and establish the data schema\n    try:\n        self._db_schema = DataSchema(self)\n    except APIError as exc:\n        raise CRIPTConnectionError(self.host, self._api_token) from exc\n\n    # Store the last active global API (might be None)\n    global _global_cached_api\n    self._previous_global_cached_api = copy.copy(_global_cached_api)\n    _global_cached_api = self\n    return self\n</code></pre>"},{"location":"api/api/#cript.api.api.API.delete","title":"<code>delete(node)</code>","text":"<p>Simply deletes the desired node from the CRIPT API and writes a log in the terminal that the node has been successfully deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material_node = cript.Material(\n...     name=\"my component material 1\",\n...     names = [\"component 1 alternative name\"],\n... )\n&gt;&gt;&gt; api.delete(node=my_material_node)\n</code></pre> Notes <p>After the node has been successfully deleted, a log is written to the terminal</p> <pre><code>INFO: Deleted 'Material' with UUID of '80bfc642-157e-4692-a547-97c470725397' from CRIPT API.\n</code></pre> Implementation Details <p>Under the hood, this method actually calls delete_node_by_uuid with the node_type and node UUID</p> Warnings <p>After successfully deleting a node from the API, keep in mind that your local Project node in your script may still contain outdated data as it has not been synced with the API.</p> <p>To ensure you have the latest data, follow these steps:</p> <ol> <li>Fetch the newest Project node from the API using the <code>cript.API.search()</code> provided by the SDK.</li> <li>Deserialize the retrieved data into a new Project node using the <code>load_nodes_from_json</code> utility function.</li> <li>Replace your old Project node with the new one in your script for accurate and up-to-date information.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>node</code> <p>The node that you want to delete</p> required <p>Raises:</p> Type Description <code>APIError</code> <p>If the API responds with anything other than HTTP status 200, then the CRIPT Python SDK raises <code>APIError</code> <code>APIError</code> is raised in case the API cannot delete the specified node. Such cases can happen if you do not have permission to delete the node or if the node is actively being used elsewhere in CRIPT platform and the API cannot delete it.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/api/api.py</code> <pre><code>def delete(self, node) -&gt; None:\n    \"\"\"\n    Simply deletes the desired node from the CRIPT API and writes a log in the terminal that the node has been\n    successfully deleted.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_material_node = cript.Material(\n    ...     name=\"my component material 1\",\n    ...     names = [\"component 1 alternative name\"],\n    ... )\n    &gt;&gt;&gt; api.delete(node=my_material_node) # doctest: +SKIP\n\n    Notes\n    -----\n    After the node has been successfully deleted, a log is written to the terminal\n\n    ```bash\n    INFO: Deleted 'Material' with UUID of '80bfc642-157e-4692-a547-97c470725397' from CRIPT API.\n    ```\n\n    ??? info \"Implementation Details\"\n        Under the hood, this method actually calls\n        [delete_node_by_uuid](./#cript.api.api.API.delete_node_by_uuid)\n        with the node_type and node UUID\n\n    Warnings\n    --------\n    After successfully deleting a node from the API, keep in mind that your local Project node in your script\n    may still contain outdated data as it has not been synced with the API.\n\n    To ensure you have the latest data, follow these steps:\n\n    1. Fetch the newest Project node from the API using the [`cript.API.search()`](./#cript.api.api.API.search) provided by the SDK.\n    1. Deserialize the retrieved data into a new Project node using the [`load_nodes_from_json`](../../utility_functions/#cript.nodes.util.load_nodes_from_json) utility function.\n    1. Replace your old Project node with the new one in your script for accurate and up-to-date information.\n\n    Parameters\n    ----------\n    node: UUIDBaseNode\n        The node that you want to delete\n\n    Raises\n    ------\n    APIError\n        If the API responds with anything other than HTTP status 200, then the CRIPT Python SDK raises `APIError`\n        `APIError` is raised in case the API cannot delete the specified node.\n        Such cases can happen if you do not have permission to delete the node\n        or if the node is actively being used elsewhere in CRIPT platform and the API cannot delete it.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.delete_node_by_uuid(node_type=node.node_type_snake_case, node_uuid=str(node.uuid))\n</code></pre>"},{"location":"api/api/#cript.api.api.API.delete_node_by_uuid","title":"<code>delete_node_by_uuid(node_type, node_uuid)</code>","text":"<p>Simply deletes the desired node from the CRIPT API and writes a log in the terminal that the node has been successfully deleted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; with cript.API(\n...     host=\"https://api.criptapp.org/\",\n...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n... ) as api:\n...      api.delete_node_by_uuid(\n...         node_type=\"computation_process\",\n...         node_uuid=\"2fd3d500-304d-4a06-8628-a79b59344b2f\"\n...     )\n</code></pre> How to get <code>node_type in snake case</code> <p>You can get the <code>node type in snake case</code> of a node via:    <pre><code> import cript\n print(cript.ComputationProcess.node_type_snake_case)\ncomputation_process\n</code></pre></p> <p>You can also call <code>api.delete_node_by_uuid()</code> with    <pre><code>api.delete(\n    node_type=cript.ComputationProcess.node_type_snake_case,\n    node_uuid=\"2fd3d500-304d-4a06-8628-a79b59344b2f\",\n)\n</code></pre></p> Notes <p>After the node has been successfully deleted, a log is written</p> <pre><code>INFO: Deleted 'Material' with UUID of '80bfc642-157e-4692-a547-97c470725397' from CRIPT API.\n</code></pre> Warnings <p>After successfully deleting a node from the API, keep in mind that your local Project node in your script may still contain outdated data as it has not been synced with the API.</p> <p>To ensure you have the latest data, follow these steps:</p> <ol> <li>Fetch the newest Project node from the API using the <code>cript.API.search()</code> provided by the SDK.</li> <li>Deserialize the retrieved data into a new Project node using the <code>load_nodes_from_json</code> utility function.</li> <li>Replace your old Project node with the new one in your script for accurate and up-to-date information.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>node_type</code> <code>str</code> <p>the type of node that you want to delete in snake case</p> required <code>node_uuid</code> <code>str</code> <p>the UUID of the primary node, supporting node, or sub-object that you want to delete from the API</p> required <p>Raises:</p> Type Description <code>APIError</code> <p>If the API responds with anything other than HTTP status 200, then the CRIPT Python SDK raises <code>APIError</code> <code>APIError</code> is raised in case the API cannot delete the specified node. Such cases can happen if you do not have permission to delete the node or if the node is actively being used elsewhere in CRIPT platform and the API cannot delete it.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/api/api.py</code> <pre><code>@beartype\ndef delete_node_by_uuid(self, node_type: str, node_uuid: str) -&gt; None:\n    \"\"\"\n    Simply deletes the desired node from the CRIPT API and writes a log in the terminal that the node has been\n    successfully deleted.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; with cript.API(\n    ...     host=\"https://api.criptapp.org/\",\n    ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n    ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n    ... ) as api:\n    ...      api.delete_node_by_uuid(\n    ...         node_type=\"computation_process\",\n    ...         node_uuid=\"2fd3d500-304d-4a06-8628-a79b59344b2f\"\n    ...     ) # doctest: +SKIP\n\n    ??? \"How to get `node_type in snake case`\"\n           You can get the `node type in snake case` of a node via:\n           ```python\n            import cript\n            print(cript.ComputationProcess.node_type_snake_case)\n           computation_process\n           ```\n\n           You can also call `api.delete_node_by_uuid()` with\n           ```python\n           api.delete(\n               node_type=cript.ComputationProcess.node_type_snake_case,\n               node_uuid=\"2fd3d500-304d-4a06-8628-a79b59344b2f\",\n           )\n           ```\n\n    Notes\n    -----\n    After the node has been successfully deleted, a log is written\n\n    ```bash\n    INFO: Deleted 'Material' with UUID of '80bfc642-157e-4692-a547-97c470725397' from CRIPT API.\n    ```\n\n    Warnings\n    --------\n    After successfully deleting a node from the API, keep in mind that your local Project node in your script\n    may still contain outdated data as it has not been synced with the API.\n\n    To ensure you have the latest data, follow these steps:\n\n    1. Fetch the newest Project node from the API using the\n    [`cript.API.search()`](./#cript.api.api.API.search) provided by the SDK.\n    1. Deserialize the retrieved data into a new Project node using the\n    [`load_nodes_from_json`](../../utility_functions/#cript.nodes.util.load_nodes_from_json) utility function.\n    1. Replace your old Project node with the new one in your script for accurate and up-to-date information.\n\n    Parameters\n    ----------\n    node_type: str\n       the type of node that you want to delete in snake case\n    node_uuid: str\n       the UUID of the primary node, supporting node, or sub-object\n       that you want to delete from the API\n\n    Raises\n    ------\n    APIError\n        If the API responds with anything other than HTTP status 200, then the CRIPT Python SDK raises `APIError`\n        `APIError` is raised in case the API cannot delete the specified node.\n        Such cases can happen if you do not have permission to delete the node\n        or if the node is actively being used elsewhere in CRIPT platform and the API cannot delete it.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    response: Dict = self._capsule_request(url_path=f\"/{node_type.lower()}/{node_uuid}/\", method=\"DELETE\").json()\n\n    if response[\"code\"] != 200:\n        raise APIError(api_error=str(response), http_method=\"DELETE\", api_url=f\"/{node_type.lower()}/{node_uuid}/\")\n\n    self.logger.info(f\"Deleted '{node_type.title()}' with UUID of '{node_uuid}' from CRIPT API.\")\n</code></pre>"},{"location":"api/api/#cript.api.api.API.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect this API from the active access point. It is not necessary to call this function manually if a context manager is used. A context manager is preferred where possible. Jupyter notebooks are a use case where this connection can be handled manually. This function has to be called manually if  the <code>API.connect</code> function has to be called before.</p> <p>For manual connection: nested API object are discouraged.</p> Source code in <code>src/cript/api/api.py</code> <pre><code>def disconnect(self):\n    \"\"\"\n    Disconnect this API from the active access point.\n    It is not necessary to call this function manually if a context manager is used.\n    A context manager is preferred where possible.\n    Jupyter notebooks are a use case where this connection can be handled manually.\n    This function has to be called manually if  the `API.connect` function has to be called before.\n\n    For manual connection: nested API object are discouraged.\n    \"\"\"\n    # Disconnect request session\n    if self._api_request_session:\n        self._api_request_session.close()\n\n    # Restore the previously active global API (might be None)\n    global _global_cached_api\n    _global_cached_api = self._previous_global_cached_api\n</code></pre>"},{"location":"api/api/#cript.api.api.API.download_file","title":"<code>download_file(file_source, destination_path='.')</code>","text":"<p>Download a file from CRIPT Cloud Storage (AWS S3) and save it to the specified path.</p> Cloud Storage vs Web URL File Download <p>If the <code>object_name</code> does not starts with <code>http</code> then the program assumes the file is in AWS S3 storage, and attempts to retrieve it via boto3 client.</p> <p>If the <code>object_name</code> starts with <code>http</code> then the program knows that it is a file stored on the web. The program makes a simple GET request to get the file, then writes the contents of it to the specified destination.</p> <p>Note: The current version of the program is designed to download files from the web in a straightforward manner. However, please be aware that the program may encounter limitations when dealing with URLs that require JavaScript or a session to be enabled. In such cases, the download method may fail.</p> <p>We acknowledge these limitations and plan to enhance the method in future versions to ensure compatibility with a wider range of web file URLs. Our goal is to develop a robust solution capable of handling any and all web file URLs.</p> <p>Parameters:</p> Name Type Description Default <code>file_source</code> <code>str</code> <p><code>object_name</code>: file downloaded via object_name from cloud storage and saved to local storage object_name e.g. <code>\"Data/{file_name}\"</code></p> <p><code>URL file source</code>: If the file source starts with <code>http</code> then it is downloaded via <code>GET</code> request and saved to local storage URL file source e.g. <code>https://criptscripts.org/cript_graph_json/JSON/cao_protein.json</code></p> required <code>destination_path</code> <code>str</code> <p>please provide a path with file name of where you would like the file to be saved on local storage.</p> <p>If no path is specified, then by default it will download the file to the current working directory.</p> <p>The destination path must include a file name and file extension     e.g.: <code>~/Desktop/my_example_file_name.extension</code></p> <code>'.'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import cript\n&gt;&gt;&gt; with cript.API(\n...     host=\"https://api.criptapp.org/\",\n...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n... ) as api:\n...     desktop_path = (Path(__file__).parent / \"cript_downloads\" / \"my_downloaded_file.txt\").resolve()\n...     my_file = cript.File(\n...         name=\"my file node name\",\n...         source=\"https://criptapp.org\",\n...         type=\"calibration\",\n...         extension=\".csv\",\n...     )\n...     api.download_file(file_source=my_file.source, destination_path=str(desktop_path))\n</code></pre> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>In case the file could not be found because the file does not exist or the path given is incorrect</p> <p>Returns:</p> Type Description <code>None</code> <p>Simply downloads the file</p> Source code in <code>src/cript/api/api.py</code> <pre><code>@beartype\ndef download_file(self, file_source: str, destination_path: str = \".\") -&gt; None:\n    \"\"\"\n    Download a file from CRIPT Cloud Storage (AWS S3) and save it to the specified path.\n\n    ??? Info \"Cloud Storage vs Web URL File Download\"\n\n        If the `object_name` does not starts with `http` then the program assumes the file is in AWS S3 storage,\n        and attempts to retrieve it via\n        [boto3 client](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html).\n\n        If the `object_name` starts with `http` then the program knows that\n        it is a file stored on the web. The program makes a simple\n        [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request to get the file,\n        then writes the contents of it to the specified destination.\n\n        &gt; Note: The current version of the program is designed to download files from the web in a straightforward\n        manner. However, please be aware that the program may encounter limitations when dealing with URLs that\n        require JavaScript or a session to be enabled. In such cases, the download method may fail.\n\n        &gt; We acknowledge these limitations and plan to enhance the method in future versions to ensure compatibility\n        with a wider range of web file URLs. Our goal is to develop a robust solution capable of handling any and\n        all web file URLs.\n\n    Parameters\n    ----------\n    file_source: str\n        `object_name`: file downloaded via object_name from cloud storage and saved to local storage\n        object_name e.g. `\"Data/{file_name}\"`\n        ---\n        `URL file source`: If the file source starts with `http` then it is downloaded via `GET` request and\n        saved to local storage\n       URL file source e.g. `https://criptscripts.org/cript_graph_json/JSON/cao_protein.json`\n    destination_path: str\n        please provide a path with file name of where you would like the file to be saved\n        on local storage.\n        &gt; If no path is specified, then by default it will download the file\n        to the current working directory.\n\n        &gt; The destination path must include a file name and file extension\n            e.g.: `~/Desktop/my_example_file_name.extension`\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; with cript.API(\n    ...     host=\"https://api.criptapp.org/\",\n    ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n    ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n    ... ) as api:\n    ...     desktop_path = (Path(__file__).parent / \"cript_downloads\" / \"my_downloaded_file.txt\").resolve()\n    ...     my_file = cript.File(\n    ...         name=\"my file node name\",\n    ...         source=\"https://criptapp.org\",\n    ...         type=\"calibration\",\n    ...         extension=\".csv\",\n    ...     )\n    ...     api.download_file(file_source=my_file.source, destination_path=str(desktop_path)) # doctest: +SKIP\n\n    Raises\n    ------\n    FileNotFoundError\n        In case the file could not be found because the file does not exist or the path given is incorrect\n\n    Returns\n    -------\n    None\n        Simply downloads the file\n    \"\"\"\n\n    # if the file source is a URL\n    if file_source.startswith(\"http\"):\n        download_file_from_url(url=file_source, destination_path=Path(destination_path).resolve())\n        return\n\n    # the file is stored in cloud storage and must be retrieved via object_name\n    self._s3_client.download_file(Bucket=self._BUCKET_NAME, Key=file_source, Filename=destination_path)  # type: ignore\n</code></pre>"},{"location":"api/api/#cript.api.api.API.save","title":"<code>save(project)</code>","text":"<p>This method takes a project node, serializes the class into JSON and then sends the JSON to be saved to the API. It takes Project node because everything is connected to the Project node, and it can be used to send either a POST or PATCH request to API</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>the Project Node that the user wants to save</p> required <p>Raises:</p> Type Description <code>CRIPTAPISaveError</code> <p>If the API responds with anything other than an HTTP of <code>200</code>, the API error is displayed to the user</p> <p>Returns:</p> Type Description <code>A set of extra saved node UUIDs.</code> <p>Just sends a <code>POST</code> or <code>Patch</code> request to the API</p> Source code in <code>src/cript/api/api.py</code> <pre><code>def save(self, project: Project) -&gt; None:\n    \"\"\"\n    This method takes a project node, serializes the class into JSON\n    and then sends the JSON to be saved to the API.\n    It takes Project node because everything is connected to the Project node,\n    and it can be used to send either a POST or PATCH request to API\n\n    Parameters\n    ----------\n    project: Project\n        the Project Node that the user wants to save\n\n    Raises\n    ------\n    CRIPTAPISaveError\n        If the API responds with anything other than an HTTP of `200`, the API error is displayed to the user\n\n    Returns\n    -------\n    A set of extra saved node UUIDs.\n        Just sends a `POST` or `Patch` request to the API\n    \"\"\"\n    try:\n        self._internal_save(project)\n    except CRIPTAPISaveError as exc:\n        if exc.pre_saved_nodes:\n            for node_uuid in exc.pre_saved_nodes:\n                # TODO remove all pre-saved nodes by their uuid.\n                pass\n        raise exc from exc\n</code></pre>"},{"location":"api/api/#cript.api.api.API.search","title":"<code>search(node_type, search_mode, value_to_search='')</code>","text":"<p>This method is used to perform search on the CRIPT platform.</p> <p>Essentially creates needed resources and passes it to paginator to get results from API and display them.</p> <p>Examples:</p> Search by Node Type <pre><code>materials_iterator = cript_api.search(\n    node_type=cript.Material,\n    search_mode=cript.SearchModes.NODE_TYPE,\n)\n</code></pre> Search by Contains name <pre><code>contains_name_iterator = cript_api.search(\n    node_type=cript.Process,\n    search_mode=cript.SearchModes.CONTAINS_NAME,\n    value_to_search=\"poly\"\n)\n</code></pre> Search by Exact Name <pre><code>exact_name_iterator = cript_api.search(\n    node_type=cript.Project,\n    search_mode=cript.SearchModes.EXACT_NAME,\n    value_to_search=\"Sodium polystyrene sulfonate\"\n)\n</code></pre> Search by UUID <pre><code>uuid_iterator = cript_api.search(\n    node_type=cript.Collection,\n    search_mode=cript.SearchModes.UUID,\n    value_to_search=\"75fd3ee5-48c2-4fc7-8d0b-842f4fc812b7\"\n)\n</code></pre> Search by BigSmiles <pre><code>iterator = cript_api.search(\n    node_type=cript.Material,\n    search_mode=cript.SearchModes.BIGSMILES,\n    value_to_search=\"{[][$]CC(C)(C(=O)OCCCC)[$][]}\"\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node_type</code> <code>UUIDBaseNode</code> <p>Type of node that you are searching for.</p> required <code>search_mode</code> <code>SearchModes</code> <p>Type of search you want to do. You can search by name, <code>UUID</code>, <code>EXACT_NAME</code>, etc. Refer to valid search modes</p> required <code>value_to_search</code> <code>str</code> <p>What you are searching for can be either a value, and if you are only searching for a <code>NODE_TYPE</code>, then this value can be empty or <code>None</code></p> <code>''</code> <p>Returns:</p> Type Description <code>Paginator</code> <p>An iterator that will present and fetch the results to the user seamlessly</p> Notes <p>To learn more about working with pagination, please refer to our paginator object documentation.</p> Source code in <code>src/cript/api/api.py</code> <pre><code>@beartype\ndef search(\n    self,\n    node_type: Any,\n    search_mode: SearchModes,\n    value_to_search: str = \"\",\n) -&gt; Paginator:\n    \"\"\"\n    This method is used to perform search on the CRIPT platform.\n\n    Essentially creates needed resources and passes it to paginator to get results from API\n    and display them.\n\n    Examples\n    --------\n    ???+ Example \"Search by Node Type\"\n        ```python\n        materials_iterator = cript_api.search(\n            node_type=cript.Material,\n            search_mode=cript.SearchModes.NODE_TYPE,\n        )\n        ```\n\n    ??? Example \"Search by Contains name\"\n        ```python\n        contains_name_iterator = cript_api.search(\n            node_type=cript.Process,\n            search_mode=cript.SearchModes.CONTAINS_NAME,\n            value_to_search=\"poly\"\n        )\n        ```\n\n    ??? Example \"Search by Exact Name\"\n        ```python\n        exact_name_iterator = cript_api.search(\n            node_type=cript.Project,\n            search_mode=cript.SearchModes.EXACT_NAME,\n            value_to_search=\"Sodium polystyrene sulfonate\"\n        )\n        ```\n\n    ??? Example \"Search by UUID\"\n        ```python\n        uuid_iterator = cript_api.search(\n            node_type=cript.Collection,\n            search_mode=cript.SearchModes.UUID,\n            value_to_search=\"75fd3ee5-48c2-4fc7-8d0b-842f4fc812b7\"\n        )\n        ```\n\n    ??? Example \"Search by BigSmiles\"\n        ```python\n        iterator = cript_api.search(\n            node_type=cript.Material,\n            search_mode=cript.SearchModes.BIGSMILES,\n            value_to_search=\"{[][$]CC(C)(C(=O)OCCCC)[$][]}\"\n        )\n        ```\n\n    Parameters\n    ----------\n    node_type : UUIDBaseNode\n        Type of node that you are searching for.\n    search_mode : SearchModes\n        Type of search you want to do. You can search by name, `UUID`, `EXACT_NAME`, etc.\n        Refer to [valid search modes](../search_modes)\n    value_to_search : str\n        What you are searching for can be either a value, and if you are only searching for\n        a `NODE_TYPE`, then this value can be empty or `None`\n\n    Returns\n    -------\n    Paginator\n        An iterator that will present and fetch the results to the user seamlessly\n\n    Notes\n    -----\n    To learn more about working with pagination, please refer to our\n    [paginator object documentation](../paginator).\n    \"\"\"\n\n    # get node typ from class\n    node_type = node_type.node_type_snake_case\n\n    api_endpoint: str = \"\"\n    limit_node_fetches: Optional[int] = None\n    if search_mode == SearchModes.NODE_TYPE:\n        api_endpoint = f\"/search/{node_type}\"\n        value_to_search = \"\"\n\n    elif search_mode == SearchModes.CONTAINS_NAME:\n        api_endpoint = f\"/search/{node_type}\"\n\n    elif search_mode == SearchModes.EXACT_NAME:\n        api_endpoint = f\"/search/exact/{node_type}\"\n        limit_node_fetches = 1\n\n    elif search_mode == SearchModes.UUID:\n        api_endpoint = f\"/{node_type}/{value_to_search}\"\n        # putting the value_to_search in the URL instead of a query\n        value_to_search = \"\"\n        limit_node_fetches = 1\n\n    elif search_mode == SearchModes.BIGSMILES:\n        api_endpoint = \"/search/bigsmiles/\"\n\n    # error handling if none of the API endpoints got hit\n    else:\n        raise RuntimeError(\"Internal Error: Failed to recognize any search modes. Please report this bug on https://github.com/C-Accel-CRIPT/Python-SDK/issues.\")\n\n    return Paginator(api=self, url_path=api_endpoint, query=value_to_search, limit_node_fetches=limit_node_fetches)\n</code></pre>"},{"location":"api/api/#cript.api.api.API.upload_file","title":"<code>upload_file(file_path)</code>","text":"<p>uploads a file to AWS S3 bucket and returns a URL of the uploaded file in AWS S3 The URL is has no expiration time limit and is available forever</p> <ol> <li>take a file path of type path or str to the file on local storage<ul> <li>see Example for more details</li> </ul> </li> <li>convert the file path to pathlib object, so it is versatile and     always uniform regardless if the user passes in a str or path object</li> <li>get the file</li> <li>rename the file to avoid clash or overwriting of previously uploaded files<ul> <li>change file name to <code>original_name_uuid4.extension</code><ul> <li><code>document_42926a201a624fdba0fd6271defc9e88.txt</code></li> </ul> </li> </ul> </li> <li>upload file to AWS S3</li> <li>get the link of the uploaded file and return it</li> </ol> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[Path, str]</code> <p>file path as str or Path object. Path Object is recommended</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import cript\n&gt;&gt;&gt; with cript.API(\n...     host=\"https://api.criptapp.org/\",\n...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n... ) as api:\n...     # programmatically create the absolute path of your file, so the program always works correctly\n...     my_file_path = (Path(__file__) / Path('../upload_files/my_file.txt')).resolve()\n...     my_file_cloud_storage_source = api.upload_file(file_path=my_file_path)\n</code></pre> Notes <p>We recommend using a Path object for specifying a file path. Using the Python pathlib library provides platform-agnostic approach for filesystem operations, ensuring seamless functionality across different operating systems. Additionally, Path objects offer various built-in methods for more sophisticated and secure file handling and has a easy to use interface that can make working with it a breeze and can help reduce errors.</p> <p>Other options include using a raw string for relative/absolute file path, or using the os.path module.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>In case the CRIPT Python SDK cannot find the file on your computer because the file does not exist or the path to it is incorrect it raises FileNotFoundError</p> <p>Returns:</p> Name Type Description <code>object_name</code> <code>str</code> <p>object_name of the AWS S3 uploaded file to be put into the File node source attribute</p> Source code in <code>src/cript/api/api.py</code> <pre><code>def upload_file(self, file_path: Union[Path, str]) -&gt; str:\n    # trunk-ignore-begin(cspell)\n    \"\"\"\n    uploads a file to AWS S3 bucket and returns a URL of the uploaded file in AWS S3\n    The URL is has no expiration time limit and is available forever\n\n    1. take a file path of type path or str to the file on local storage\n        * see Example for more details\n    1. convert the file path to pathlib object, so it is versatile and\n        always uniform regardless if the user passes in a str or path object\n    1. get the file\n    1. rename the file to avoid clash or overwriting of previously uploaded files\n        * change file name to `original_name_uuid4.extension`\n            *  `document_42926a201a624fdba0fd6271defc9e88.txt`\n    1. upload file to AWS S3\n    1. get the link of the uploaded file and return it\n\n\n    Parameters\n    ----------\n    file_path: Union[str, Path]\n        file path as str or Path object. Path Object is recommended\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; with cript.API(\n    ...     host=\"https://api.criptapp.org/\",\n    ...     api_token=os.getenv(\"CRIPT_TOKEN\"),\n    ...     storage_token=os.getenv(\"CRIPT_STORAGE_TOKEN\")\n    ... ) as api:\n    ...     # programmatically create the absolute path of your file, so the program always works correctly\n    ...     my_file_path = (Path(__file__) / Path('../upload_files/my_file.txt')).resolve()\n    ...     my_file_cloud_storage_source = api.upload_file(file_path=my_file_path)  # doctest: +SKIP\n\n    Notes\n    -----\n    We recommend using a [Path](https://docs.python.org/3/library/pathlib.html) object for specifying a file path.\n    Using the Python [pathlib library](https://docs.python.org/3/library/pathlib.html) provides platform-agnostic approach\n    for filesystem operations, ensuring seamless functionality across different operating systems.\n    Additionally, [Path](https://docs.python.org/3/library/pathlib.html) objects offer various built-in methods\n    for more sophisticated and secure file handling and has a easy to use interface that can make working with it a breeze\n    and can help reduce errors.\n\n    Other options include using a raw string for relative/absolute file path,\n    or using the [os.path module](https://docs.python.org/3/library/os.path.html).\n\n\n    Raises\n    ------\n    FileNotFoundError\n        In case the CRIPT Python SDK cannot find the file on your computer because the file does not exist\n        or the path to it is incorrect it raises\n        [FileNotFoundError](https://docs.python.org/3/library/exceptions.html#FileNotFoundError)\n\n    Returns\n    -------\n    object_name: str\n        object_name of the AWS S3 uploaded file to be put into the File node source attribute\n    \"\"\"\n    # trunk-ignore-end(cspell)\n\n    # TODO consider using a new variable when converting `file_path` from parameter\n    #  to a Path object with a new type\n    # convert file path from whatever the user passed in to a pathlib object\n    file_path = Path(file_path).resolve()\n\n    # get file_name and file_extension from absolute file path\n    # file_extension includes the dot, e.g. \".txt\"\n    file_name, file_extension = os.path.splitext(os.path.basename(file_path))\n\n    # generate a UUID4 string without dashes, making a cleaner file name\n    uuid_str: str = str(uuid.uuid4().hex)\n\n    new_file_name: str = f\"{file_name}_{uuid_str}{file_extension}\"\n\n    # e.g. \"directory/file_name_uuid.extension\"\n    object_name: str = f\"{self._BUCKET_DIRECTORY_NAME}/{new_file_name}\"\n\n    # upload file to AWS S3\n    self._s3_client.upload_file(Filename=file_path, Bucket=self._BUCKET_NAME, Key=object_name)  # type: ignore\n\n    self.logger.info(f\"Uploaded File: '{file_path}' to CRIPT storage\")\n\n    # return the object_name within AWS S3 for easy retrieval\n    return object_name\n</code></pre>"},{"location":"api/controlled_vocabulary_categories/","title":"Controlled Vocabulary Categories","text":"<p>             Bases: <code>Enum</code></p> <p>All available CRIPT controlled vocabulary categories</p> <p>Controlled vocabulary categories are used to classify data.</p> <p>Attributes:</p> Name Type Description <code>ALGORITHM_KEY</code> <code>str</code> <p>Algorithm key.</p> <code>ALGORITHM_TYPE</code> <code>str</code> <p>Algorithm type.</p> <code>BUILDING_BLOCK</code> <code>str</code> <p>Building block.</p> <code>CITATION_TYPE</code> <code>str</code> <p>Citation type.</p> <code>COMPUTATION_TYPE</code> <code>str</code> <p>Computation type.</p> <code>COMPUTATIONAL_FORCEFIELD_KEY</code> <code>str</code> <p>Computational forcefield key.</p> <code>COMPUTATIONAL_PROCESS_PROPERTY_KEY</code> <code>str</code> <p>Computational process property key.</p> <code>COMPUTATIONAL_PROCESS_TYPE</code> <code>str</code> <p>Computational process type.</p> <code>CONDITION_KEY</code> <code>str</code> <p>Condition key.</p> <code>DATA_LICENSE</code> <code>str</code> <p>Data license.</p> <code>DATA_TYPE</code> <code>str</code> <p>Data type.</p> <code>EQUIPMENT_KEY</code> <code>str</code> <p>Equipment key.</p> <code>FILE_TYPE</code> <code>str</code> <p>File type.</p> <code>INGREDIENT_KEYWORD</code> <code>str</code> <p>Ingredient keyword.</p> <code>MATERIAL_IDENTIFIER_KEY</code> <code>str</code> <p>Material identifier key.</p> <code>MATERIAL_KEYWORD</code> <code>str</code> <p>Material keyword.</p> <code>MATERIAL_PROPERTY_KEY</code> <code>str</code> <p>Material property key.</p> <code>PARAMETER_KEY</code> <code>str</code> <p>Parameter key.</p> <code>PROCESS_KEYWORD</code> <code>str</code> <p>Process keyword.</p> <code>PROCESS_PROPERTY_KEY</code> <code>str</code> <p>Process property key.</p> <code>PROCESS_TYPE</code> <code>str</code> <p>Process type.</p> <code>PROPERTY_METHOD</code> <code>str</code> <p>Property method.</p> <code>QUANTITY_KEY</code> <code>str</code> <p>Quantity key.</p> <code>REFERENCE_TYPE</code> <code>str</code> <p>Reference type.</p> <code>SET_TYPE</code> <code>str</code> <p>Set type.</p> <code>UNCERTAINTY_TYPE</code> <code>str</code> <p>Uncertainty type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; algorithm_vocabulary = api.schema.get_vocab_by_category(\n...     cript.VocabCategories.ALGORITHM_KEY\n... )\n</code></pre> Source code in <code>src/cript/api/vocabulary_categories.py</code> <pre><code>class VocabCategories(Enum):\n    \"\"\"\n    All available [CRIPT controlled vocabulary categories](https://app.criptapp.org/vocab/)\n\n    Controlled vocabulary categories are used to classify data.\n\n    Attributes\n    ----------\n    ALGORITHM_KEY: str\n        Algorithm key.\n    ALGORITHM_TYPE: str\n        Algorithm type.\n    BUILDING_BLOCK: str\n        Building block.\n    CITATION_TYPE: str\n        Citation type.\n    COMPUTATION_TYPE: str\n       Computation type.\n    COMPUTATIONAL_FORCEFIELD_KEY: str\n        Computational forcefield key.\n    COMPUTATIONAL_PROCESS_PROPERTY_KEY: str\n        Computational process property key.\n    COMPUTATIONAL_PROCESS_TYPE: str\n        Computational process type.\n    CONDITION_KEY: str\n        Condition key.\n    DATA_LICENSE: str\n        Data license.\n    DATA_TYPE: str\n        Data type.\n    EQUIPMENT_KEY: str\n        Equipment key.\n    FILE_TYPE: str\n        File type.\n    INGREDIENT_KEYWORD: str\n        Ingredient keyword.\n    MATERIAL_IDENTIFIER_KEY: str\n        Material identifier key.\n    MATERIAL_KEYWORD: str\n        Material keyword.\n    MATERIAL_PROPERTY_KEY: str\n        Material property key.\n    PARAMETER_KEY: str\n        Parameter key.\n    PROCESS_KEYWORD: str\n        Process keyword.\n    PROCESS_PROPERTY_KEY: str\n        Process property key.\n    PROCESS_TYPE: str\n        Process type.\n    PROPERTY_METHOD: str\n        Property method.\n    QUANTITY_KEY: str\n        Quantity key.\n    REFERENCE_TYPE: str\n        Reference type.\n    SET_TYPE: str\n        Set type.\n    UNCERTAINTY_TYPE: str\n        Uncertainty type.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; algorithm_vocabulary = api.schema.get_vocab_by_category(\n    ...     cript.VocabCategories.ALGORITHM_KEY\n    ... )\n    \"\"\"\n\n    ALGORITHM_KEY: str = \"algorithm_key\"\n    ALGORITHM_TYPE: str = \"algorithm_type\"\n    BUILDING_BLOCK: str = \"building_block\"\n    CITATION_TYPE: str = \"citation_type\"\n    COMPUTATION_TYPE: str = \"computation_type\"\n    COMPUTATIONAL_FORCEFIELD_KEY: str = \"computational_forcefield_key\"\n    COMPUTATIONAL_PROCESS_PROPERTY_KEY: str = \"computational_process_property_key\"\n    COMPUTATIONAL_PROCESS_TYPE: str = \"computational_process_type\"\n    CONDITION_KEY: str = \"condition_key\"\n    DATA_LICENSE: str = \"data_license\"\n    DATA_TYPE: str = \"data_type\"\n    EQUIPMENT_KEY: str = \"equipment_key\"\n    FILE_TYPE: str = \"file_type\"\n    INGREDIENT_KEYWORD: str = \"ingredient_keyword\"\n    MATERIAL_IDENTIFIER_KEY: str = \"material_identifier_key\"\n    MATERIAL_KEYWORD: str = \"material_keyword\"\n    MATERIAL_PROPERTY_KEY: str = \"material_property_key\"\n    PARAMETER_KEY: str = \"parameter_key\"\n    PROCESS_KEYWORD: str = \"process_keyword\"\n    PROCESS_PROPERTY_KEY: str = \"process_property_key\"\n    PROCESS_TYPE: str = \"process_type\"\n    PROPERTY_METHOD: str = \"property_method\"\n    QUANTITY_KEY: str = \"quantity_key\"\n    REFERENCE_TYPE: str = \"reference_type\"\n    SET_TYPE: str = \"set_type\"\n    UNCERTAINTY_TYPE: str = \"uncertainty_type\"\n</code></pre>"},{"location":"api/paginator/","title":"Paginator","text":""},{"location":"api/paginator/#cript.api.paginator.Paginator","title":"<code>Paginator</code>","text":"<p>Paginator is used to flip through different pages of data that the API returns when searching.</p> <p>Instead of the user manipulating the URL and parameters, this object handles all of that for them.</p> <p>Using the Paginator object, the user can simply and easily flip through the results of the search. The details, that results are listed as pages are hidden from the user. The pages are automatically requested from the API as needed.</p> <p>This object implements a python iterator, so <code>for node in Paginator</code> works as expected. It will loop through all results of the search, returning the nodes one by one.</p> <p>Do not create paginator objects</p> <p>Please note that you are not required or advised to create a paginator object, and instead the Python SDK API object will create a paginator for you, return it, and let you simply use it</p> Source code in <code>src/cript/api/paginator.py</code> <pre><code>class Paginator:\n    \"\"\"\n    Paginator is used to flip through different pages of data that the API returns when searching.\n    &gt; Instead of the user manipulating the URL and parameters, this object handles all of that for them.\n\n    Using the Paginator object, the user can simply and easily flip through the results of the search.\n    The details, that results are listed as pages are hidden from the user.\n    The pages are automatically requested from the API as needed.\n\n    This object implements a python iterator, so `for node in Paginator` works as expected.\n    It will loop through all results of the search, returning the nodes one by one.\n\n    !!! Warning \"Do not create paginator objects\"\n        Please note that you are not required or advised to create a paginator object, and instead the\n        Python SDK API object will create a paginator for you, return it, and let you simply use it\n\n    \"\"\"\n\n    _url_path: str\n    _query: str\n    _current_position: int\n    _fetched_nodes: list\n    _uuid_search_score_map: Dict\n    _number_fetched_pages: int = 0\n    _limit_node_fetches: Optional[int] = None\n    _start_after_uuid: Optional[str] = None\n    _start_after_score: Optional[float] = None\n    auto_load_nodes: bool = True\n\n    @beartype\n    def __init__(self, api, url_path: str, query: str, limit_node_fetches: Optional[int] = None):\n        \"\"\"\n        create a paginator\n\n        1. set all the variables coming into constructor\n        1. then prepare any variable as needed e.g. strip extra spaces or url encode query\n\n        Parameters\n        ----------\n        api: cript.API\n           Object through which the API call is routed.\n        url_path: str\n            query URL used.\n        query: str\n            the value the user is searching for\n        limit_node_fetches: Optional[int] = None\n            limits the number of nodes fetches through this call.\n\n        Returns\n        -------\n        None\n            instantiate a paginator\n        \"\"\"\n        self._api = api\n        self._fetched_nodes = []\n        self._current_position = 0\n        self._limit_node_fetches = limit_node_fetches\n        self._uuid_search_score_map = {}\n\n        # check if it is a string and not None to avoid AttributeError\n        try:\n            self._url_path = url_path.rstrip(\"/\").strip()\n        except Exception as exc:\n            raise RuntimeError(f\"Invalid type for api_endpoint {self._url_path} for a paginator.\") from exc\n\n        self._query = query\n\n    @beartype\n    def _fetch_next_page(self) -&gt; None:\n        \"\"\"\n        1. builds the URL from the query and page number\n        1. makes the request to the API\n        1. API responds with a JSON that has data or JSON that has data and result\n            1. parses the response\n            2. creates cript.Nodes from the response\n            3. Add the nodes to the fetched_data so the iterator can return them\n\n        Raises\n        ------\n        InvalidSearchRequest\n            In case the API responds with an error\n        StopIteration\n            In case there are no further results to fetch\n\n\n        Returns\n        -------\n             None\n        \"\"\"\n\n        # Composition of the query URL\n        temp_url_path: str = self._url_path + \"/\"\n\n        query_list = []\n\n        if len(self._query) &gt; 0:\n            query_list += [f\"q={self._query}\"]\n\n        if self._limit_node_fetches is None or self._limit_node_fetches &gt; 1:  # This limits these parameters\n            if self._start_after_uuid is not None:\n                query_list += [f\"after={self._start_after_uuid}\"]\n                if self._start_after_score is not None:  # Always None for none BigSMILES searches\n                    query_list += [f\"score={self._start_after_score}\"]\n\n                # Reset to allow normal search to continue\n                self._start_after_uuid = None\n                self._start_after_score = None\n\n            elif len(self._fetched_nodes) &gt; 0:  # Use known last element\n                node_uuid, node_score = _get_uuid_score_from_json(self._fetched_nodes[-1])\n                query_list += [f\"after={node_uuid}\"]\n                if node_score is not None:\n                    query_list += [f\"score={node_score}\"]\n\n        for i, query in enumerate(query_list):\n            if i == 0:\n                temp_url_path += \"?\"\n            else:\n                temp_url_path += \"&amp;\"\n            temp_url_path += quote(query, safe=\"/=&amp;?\")\n\n        response: requests.Response = self._api._capsule_request(url_path=temp_url_path, method=\"GET\")\n\n        # it is expected that the response will be JSON\n        # try to convert response to JSON\n        try:\n            api_response: Dict = response.json()\n\n        # if converting API response to JSON gives an error\n        # then there must have been an API error, so raise the requests error\n        # this is to avoid bad indirect errors and make the errors more direct for users\n        except json.JSONDecodeError as json_exc:\n            try:\n                response.raise_for_status()\n            except Exception as exc:\n                raise exc from json_exc\n\n        # handling both cases in case there is result inside of data or just data\n        try:\n            current_page_results = api_response[\"data\"][\"result\"]\n        except KeyError:\n            current_page_results = api_response[\"data\"]\n        except TypeError:\n            current_page_results = api_response[\"data\"]\n\n        if api_response[\"code\"] == 404 and api_response[\"error\"] == \"The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.\":\n            current_page_results = []\n            self._api.logger.debug(f\"The paginator hit a 404 HTTP for requesting this {temp_url_path} with GET. We interpret it as no nodes present, but this is brittle at the moment.\")\n        # if API response is not 200 raise error for the user to debug\n        elif api_response[\"code\"] != 200:\n            raise APIError(api_error=str(response.json()), http_method=\"GET\", api_url=temp_url_path)\n\n        # Here we only load the JSON into the temporary results.\n        # This delays error checking, and allows users to disable auto node conversion\n        json_list = current_page_results\n        self._fetched_nodes += json_list\n\n    def __next__(self):\n        if self._limit_node_fetches and self._current_position &gt;= self._limit_node_fetches:\n            raise StopIteration\n\n        if self._current_position &gt;= len(self._fetched_nodes):\n            self._fetch_next_page()\n\n        try:\n            next_node_json = self._fetched_nodes[self._current_position - 1]\n        except IndexError as exc:  # This is not a random access iteration.\n            # So if fetching a next page wasn't enough to get the index inbound,\n            # The iteration stops\n            raise StopIteration from exc\n\n        if self.auto_load_nodes:\n            return_data = load_nodes_from_json(next_node_json)\n        else:\n            return_data = next_node_json\n\n        # Advance position last, so if an exception occurs, for example when\n        # node decoding fails, we do not advance, and users can try again without decoding\n        self._current_position += 1\n\n        return return_data\n\n    def __iter__(self):\n        self._current_position = 0\n        return self\n\n    @beartype\n    def limit_node_fetches(self, max_num_nodes: Optional[int]) -&gt; None:\n        \"\"\"Limit pagination to a maximum number of pages.\n\n        This can be used for very large searches with the paginator, so the search can be split into\n        smaller portions.\n\n        Parameters\n        ----------\n        max_num_nodes: Optional[int],\n          positive integer with maximum number of page fetches.\n          or None, indicating unlimited number of page fetches are permitted.\n        \"\"\"\n        self._limit_node_fetches = max_num_nodes\n\n    @beartype\n    def start_after_uuid(self, start_after_uuid: str, start_after_score: Optional[float] = None):\n        \"\"\"\n        This can be used to continue a search from a last known node.\n\n        Parameters\n        ----------\n        start_after_uuid: str\n            UUID string of the last node from a previous search\n        start_after_score: float\n            required for BigSMILES searches, the last score from a BigSMILES search.\n            Must be None if not a BigSMILES search.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._start_after_uuid = start_after_uuid\n        self._start_after_score = start_after_score\n\n    @beartype\n    def get_bigsmiles_search_score(self, uuid: str):\n        \"\"\"\n        Get the ranking score for nodes from the BigSMILES search.\n        Will return None if not a BigSMILES search or raise an Exception.\n        \"\"\"\n        if uuid not in self._uuid_search_score_map.keys():\n            start = len(self._uuid_search_score_map.keys())\n            for node_json in self._fetched_nodes[start:]:\n                node_uuid, node_score = _get_uuid_score_from_json(node_json)\n                self._uuid_search_score_map[node_uuid] = node_score\n        try:\n            return self._uuid_search_score_map[uuid]\n        except KeyError as exc:\n            raise RuntimeError(f\"The requested UUID {uuid} is not know from the search. Search scores are limited only to current search.\") from exc\n</code></pre>"},{"location":"api/paginator/#cript.api.paginator.Paginator.__init__","title":"<code>__init__(api, url_path, query, limit_node_fetches=None)</code>","text":"<p>create a paginator</p> <ol> <li>set all the variables coming into constructor</li> <li>then prepare any variable as needed e.g. strip extra spaces or url encode query</li> </ol> <p>Parameters:</p> Name Type Description Default <code>api</code> <p>Object through which the API call is routed.</p> required <code>url_path</code> <code>str</code> <p>query URL used.</p> required <code>query</code> <code>str</code> <p>the value the user is searching for</p> required <code>limit_node_fetches</code> <code>Optional[int]</code> <p>limits the number of nodes fetches through this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>instantiate a paginator</p> Source code in <code>src/cript/api/paginator.py</code> <pre><code>@beartype\ndef __init__(self, api, url_path: str, query: str, limit_node_fetches: Optional[int] = None):\n    \"\"\"\n    create a paginator\n\n    1. set all the variables coming into constructor\n    1. then prepare any variable as needed e.g. strip extra spaces or url encode query\n\n    Parameters\n    ----------\n    api: cript.API\n       Object through which the API call is routed.\n    url_path: str\n        query URL used.\n    query: str\n        the value the user is searching for\n    limit_node_fetches: Optional[int] = None\n        limits the number of nodes fetches through this call.\n\n    Returns\n    -------\n    None\n        instantiate a paginator\n    \"\"\"\n    self._api = api\n    self._fetched_nodes = []\n    self._current_position = 0\n    self._limit_node_fetches = limit_node_fetches\n    self._uuid_search_score_map = {}\n\n    # check if it is a string and not None to avoid AttributeError\n    try:\n        self._url_path = url_path.rstrip(\"/\").strip()\n    except Exception as exc:\n        raise RuntimeError(f\"Invalid type for api_endpoint {self._url_path} for a paginator.\") from exc\n\n    self._query = query\n</code></pre>"},{"location":"api/paginator/#cript.api.paginator.Paginator.get_bigsmiles_search_score","title":"<code>get_bigsmiles_search_score(uuid)</code>","text":"<p>Get the ranking score for nodes from the BigSMILES search. Will return None if not a BigSMILES search or raise an Exception.</p> Source code in <code>src/cript/api/paginator.py</code> <pre><code>@beartype\ndef get_bigsmiles_search_score(self, uuid: str):\n    \"\"\"\n    Get the ranking score for nodes from the BigSMILES search.\n    Will return None if not a BigSMILES search or raise an Exception.\n    \"\"\"\n    if uuid not in self._uuid_search_score_map.keys():\n        start = len(self._uuid_search_score_map.keys())\n        for node_json in self._fetched_nodes[start:]:\n            node_uuid, node_score = _get_uuid_score_from_json(node_json)\n            self._uuid_search_score_map[node_uuid] = node_score\n    try:\n        return self._uuid_search_score_map[uuid]\n    except KeyError as exc:\n        raise RuntimeError(f\"The requested UUID {uuid} is not know from the search. Search scores are limited only to current search.\") from exc\n</code></pre>"},{"location":"api/paginator/#cript.api.paginator.Paginator.limit_node_fetches","title":"<code>limit_node_fetches(max_num_nodes)</code>","text":"<p>Limit pagination to a maximum number of pages.</p> <p>This can be used for very large searches with the paginator, so the search can be split into smaller portions.</p> <p>Parameters:</p> Name Type Description Default <code>max_num_nodes</code> <code>Optional[int]</code> <p>positive integer with maximum number of page fetches. or None, indicating unlimited number of page fetches are permitted.</p> required Source code in <code>src/cript/api/paginator.py</code> <pre><code>@beartype\ndef limit_node_fetches(self, max_num_nodes: Optional[int]) -&gt; None:\n    \"\"\"Limit pagination to a maximum number of pages.\n\n    This can be used for very large searches with the paginator, so the search can be split into\n    smaller portions.\n\n    Parameters\n    ----------\n    max_num_nodes: Optional[int],\n      positive integer with maximum number of page fetches.\n      or None, indicating unlimited number of page fetches are permitted.\n    \"\"\"\n    self._limit_node_fetches = max_num_nodes\n</code></pre>"},{"location":"api/paginator/#cript.api.paginator.Paginator.start_after_uuid","title":"<code>start_after_uuid(start_after_uuid, start_after_score=None)</code>","text":"<p>This can be used to continue a search from a last known node.</p> <p>Parameters:</p> Name Type Description Default <code>start_after_uuid</code> <code>str</code> <p>UUID string of the last node from a previous search</p> required <code>start_after_score</code> <code>Optional[float]</code> <p>required for BigSMILES searches, the last score from a BigSMILES search. Must be None if not a BigSMILES search.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/api/paginator.py</code> <pre><code>@beartype\ndef start_after_uuid(self, start_after_uuid: str, start_after_score: Optional[float] = None):\n    \"\"\"\n    This can be used to continue a search from a last known node.\n\n    Parameters\n    ----------\n    start_after_uuid: str\n        UUID string of the last node from a previous search\n    start_after_score: float\n        required for BigSMILES searches, the last score from a BigSMILES search.\n        Must be None if not a BigSMILES search.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._start_after_uuid = start_after_uuid\n    self._start_after_score = start_after_score\n</code></pre>"},{"location":"api/search_modes/","title":"Search Modes","text":"<p>             Bases: <code>Enum</code></p> <p>Available search modes to use with the CRIPT API search</p> <p>Attributes:</p> Name Type Description <code>NODE_TYPE</code> <code>str</code> <p>Search by node type.</p> <code>EXACT_NAME</code> <code>str</code> <p>Search by exact node name.</p> <code>CONTAINS_NAME</code> <code>str</code> <p>Search by node name containing a given string.</p> <code>UUID</code> <code>str</code> <p>Search by node UUID.</p> <code>BIGSMILES</code> <code>str</code> <p>search materials by bigsmiles.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; # search by node type\n&gt;&gt;&gt; materials_paginator = api.search(\n...     node_type=cript.Material,\n...     search_mode=cript.SearchModes.NODE_TYPE,\n...     value_to_search=None,\n... )\n</code></pre> <p>For more details and code examples, please check the cript.API.search( ) method</p> Source code in <code>src/cript/api/valid_search_modes.py</code> <pre><code>class SearchModes(Enum):\n    \"\"\"\n    Available search modes to use with the CRIPT API search\n\n    Attributes\n    ----------\n    NODE_TYPE : str\n        Search by node type.\n    EXACT_NAME : str\n        Search by exact node name.\n    CONTAINS_NAME : str\n        Search by node name containing a given string.\n    UUID : str\n        Search by node UUID.\n    BIGSMILES: str\n        search materials by bigsmiles.\n\n    Examples\n    -------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; # search by node type\n    &gt;&gt;&gt; materials_paginator = api.search(\n    ...     node_type=cript.Material,\n    ...     search_mode=cript.SearchModes.NODE_TYPE,\n    ...     value_to_search=None,\n    ... )   # doctest: +SKIP\n\n    For more details and code examples,\n    please check the [cript.API.search( ) method](../api/#cript.api.api.API.search)\n    \"\"\"\n\n    NODE_TYPE: str = \"\"\n    EXACT_NAME: str = \"exact_name\"\n    CONTAINS_NAME: str = \"contains_name\"\n    UUID: str = \"uuid\"\n    # UUID_CHILDREN = \"uuid_children\"\n    BIGSMILES: str = \"bigsmiles\"\n</code></pre>"},{"location":"examples/simulation/","title":"Simulation","text":"<p>Abstract</p> <p>This tutorial guides you through an example material synthesis workflow using the CRIPT Python SDK.</p>"},{"location":"examples/simulation/#installation","title":"Installation","text":"<p>Before you start, be sure the cript python package is installed.</p> <pre><code>pip install cript\n</code></pre>"},{"location":"examples/simulation/#connect-to-cript","title":"Connect to CRIPT","text":"<p>To connect to CRIPT, you must enter a <code>host</code> and an <code>API Token</code>. For most users, <code>host</code> will be <code>https://api.criptapp.org/</code>.</p> <p>Keep API Token Secure</p> <p>To ensure security, avoid storing sensitive information like tokens directly in your code. Instead, use environment variables. Storing tokens in code shared on platforms like GitHub can lead to security incidents. Anyone that possesses your token can impersonate you on the CRIPT platform. Consider alternative methods for loading tokens with the CRIPT API Client. In case your token is exposed be sure to immediately generate a new token to revoke the access of the old one and keep the new token safe.</p> <pre><code>import cript\n\nwith cript.API(host=\"https://api.criptapp.org/\", api_token=\"123456\", storage_token=\"987654\") as api:\n    pass\n</code></pre> <p>Note</p> <p>You may notice, that we are not executing any code inside the context manager block. If you were to write a python script, compared to a jupyter notebook, you would add all the following code inside that block. Here in a jupyter notebook, we need to connect manually. We just have to remember to disconnect at the end.</p> <pre><code>api = cript.API(\n    host=\"https://api.criptapp.org/\", api_token=None, storage_token=\"123456\"\n)\napi = api.connect()\n</code></pre>"},{"location":"examples/simulation/#create-a-project","title":"Create a Project","text":"<p>All data uploaded to CRIPT must be associated with a <code>Project</code> node. <code>Project</code> can be thought of as an overarching research goal. For example, finding a replacement for an existing material from a sustainable feedstock.</p> <pre><code># create a new project in the CRIPT database\nproject = cript.Project(name=\"My simulation project.\")\n</code></pre>"},{"location":"examples/simulation/#create-a-collection-node","title":"Create a Collection node","text":"<p>For this project, you can create multiple collections, which represent a set of experiments. For example, you can create a collection for a specific manuscript, or you can create a collection for initial screening of candidates and one for later refinements etc.</p> <p>So, let's create a collection node and add it to the project.</p> <pre><code>collection = cript.Collection(name=\"Initial simulation screening\")\n# We add this collection to the project as a list.\nproject.collection += [collection]\n</code></pre> <p>Viewing CRIPT JSON</p> <p>Note, that if you are interested into the inner workings of CRIPT, you can obtain a JSON representation of your data at any time to see what is being sent to the API through HTTP JSON requests.</p> <pre><code>print(project.json)\n</code></pre> <p>Format JSON in terminal</p> <p>Format the JSON within the terminal for easier reading <pre><code>print(project.get_json(indent=2).json)\n</code></pre></p>"},{"location":"examples/simulation/#create-an-experiment-node","title":"Create an Experiment node","text":"<p>The Collection node holds a series of Experiment nodes nodes.</p> <p>And we can add this experiment to the collection of the project.</p> <pre><code>experiment = cript.Experiment(name=\"Simulation for the first candidate\")\ncollection.experiment += [experiment]\n</code></pre>"},{"location":"examples/simulation/#create-relevant-software-nodes","title":"Create relevant Software nodes","text":"<p><code>Software</code> nodes refer to software that you use during your simulation experiment. In general <code>Software</code> nodes can be shared between project, and it is encouraged to do so if the software you are using is already present in the CRIPT project use it.</p> <p>If They are not, you can create them as follows:</p> <pre><code>python = cript.Software(name=\"python\", version=\"3.9\")\n\nrdkit = cript.Software(name=\"rdkit\", version=\"2020.9\")\n\nstage = cript.Software(\n    name=\"stage\", source=\"https://doi.org/10.1021/jp505332p\", version=\"N/A\"\n)\n\npackmol = cript.Software(\n    name=\"Packmol\", source=\"http://m3g.iqm.unicamp.br/packmol\", version=\"N/A\"\n)\n\nopenmm = cript.Software(name=\"openmm\", version=\"7.5\")\n</code></pre> <p>Generally, provide as much information about the software as possible this helps to make your results reproducible. Even a software is not publicly available, like an in-house code, we encourage you to specify them in CRIPT. If a version is not available, consider using git-hashes.</p>"},{"location":"examples/simulation/#create-software-configuration","title":"Create Software Configuration","text":"<p>Now that we have our <code>Software</code> nodes, we can create  <code>SoftwareConfiguration</code> nodes. <code>SoftwareConfigurations</code> nodes are designed to let you specify details, about which algorithms from the software package you are using and log parameters for these algorithms.</p> <p>The <code>SoftwareConfigurations</code> are then used for constructing our <code>Computation</code> node, which describe the actual computation you are performing.</p> <p>We can also attach <code>Algorithm</code> nodes to a <code>SoftwareConfiguration</code>  node. The <code>Algorithm</code> nodes may contain nested <code>Parameter</code> nodes, as shown in the example below.</p> <pre><code># create some software configuration nodes\npython_config = cript.SoftwareConfiguration(software=python)\nrdkit_config = cript.SoftwareConfiguration(software=rdkit)\nstage_config = cript.SoftwareConfiguration(software=stage)\n\n# create a software configuration node with a child Algorithm node\nopenmm_config = cript.SoftwareConfiguration(\n    software=openmm,\n    algorithm=[\n        cript.Algorithm(\n            key=\"energy_minimization\",\n            type=\"initialization\",\n        ),\n    ],\n)\npackmol_config = cript.SoftwareConfiguration(software=packmol)\n</code></pre> <p>Algorithm keys</p> <p>The allowed <code>Algorithm</code> keys are listed under  algorithm keys in the CRIPT controlled vocabulary.</p> <p>Parameter keys</p> <p>The allowed <code>Parameter</code> keys are listed under parameter keys in the CRIPT controlled vocabulary.</p>"},{"location":"examples/simulation/#create-computations","title":"Create Computations","text":"<p>Now that we've created some <code>SoftwareConfiguration</code> nodes, we can used them to build full <code>Computation</code> nodes. In some cases, we may also want to add <code>Condition</code> nodes to our computation, to specify the conditions at which the computation was carried out. An example of this is shown below.</p> <pre><code># Create a ComputationNode\n# This block of code represents the computation involved in generating forces.\n# It also details the initial placement of molecules within a simulation box.\ninit = cript.Computation(\n    name=\"Initial snapshot and force-field generation\",\n    type=\"initialization\",\n    software_configuration=[\n        python_config,\n        rdkit_config,\n        stage_config,\n        packmol_config,\n        openmm_config,\n    ],\n)\n\n# Initiate the simulation equilibration using a separate node.\n# The equilibration process is governed by specific conditions and a \n# set equilibration time.\n# Given this is an NPT (Number of particles, Pressure, Temperature) \n# simulation, conditions such as the number of chains, temperature, \n# and pressure are specified.\nequilibration = cript.Computation(\n    name=\"Equilibrate data prior to measurement\",\n    type=\"MD\",\n    software_configuration=[python_config, openmm_config],\n    condition=[\n        cript.Condition(key=\"time_duration\", type=\"value\", value=100.0, unit=\"ns\"),\n        cript.Condition(key=\"temperature\", type=\"value\", value=450.0, unit=\"K\"),\n        cript.Condition(key=\"pressure\", type=\"value\", value=1.0, unit=\"bar\"),\n        cript.Condition(key=\"number\", type=\"value\", value=31),\n    ],\n    prerequisite_computation=init,\n)\n\n# This section involves the actual data measurement.\n# Note that we use the previously computed data as a prerequisite. \n# Additionally, we incorporate the input data at a later stage.\nbulk = cript.Computation(\n    name=\"Bulk simulation for measurement\",\n    type=\"MD\",\n    software_configuration=[python_config, openmm_config],\n    condition=[\n        cript.Condition(key=\"time_duration\", type=\"value\", value=50.0, unit=\"ns\"),\n        cript.Condition(key=\"temperature\", type=\"value\", value=450.0, unit=\"K\"),\n        cript.Condition(key=\"pressure\", type=\"value\", value=1.0, unit=\"bar\"),\n        cript.Condition(key=\"number\", type=\"value\", value=31),\n    ],\n    prerequisite_computation=equilibration,\n)\n\n# The following step involves analyzing the data \n# from the measurement run to ascertain a specific property.\nana = cript.Computation(\n    name=\"Density analysis\",\n    type=\"analysis\",\n    software_configuration=[python_config],\n    prerequisite_computation=bulk,\n)\n\n# Add all these computations to the experiment.\nexperiment.computation += [init, equilibration, bulk, ana]\n</code></pre> <p>Computation types</p> <p>The allowed <code>Computation</code> types are listed under computation types in the CRIPT controlled vocabulary.</p> <p>Condition keys</p> <p>The allowed <code>Condition</code> keys are listed under condition keys in the CRIPT controlled vocabulary.</p>"},{"location":"examples/simulation/#create-and-upload-files-nodes","title":"Create and Upload Files nodes","text":"<p>New we'd like to upload files associated with our simulation. First, we'll instantiate our File nodes under a specific project.</p> <pre><code>packing_file = cript.File(\n    name=\"Initial simulation box snapshot with roughly packed molecules\",\n    type=\"computation_snapshot\",\n    source=\"path/to/local/file\",\n    extension=\".csv\",\n)\n\nforcefield_file = cript.File(\n    name=\"Forcefield definition file\",\n    type=\"data\",\n    source=\"path/to/local/file\",\n    extension=\".pdf\",\n)\n\nsnap_file = cript.File(\n    name=\"Bulk measurement initial system snap shot\",\n    type=\"computation_snapshot\",\n    source=\"path/to/local/file\",\n    extension=\".png\",\n)\n\nfinal_file = cript.File(\n    name=\"Final snapshot of the system at the end the simulations\",\n    type=\"computation_snapshot\",\n    source=\"path/to/local/file\",\n    extension=\".jpeg\",\n)\n</code></pre> <p>Note</p> <p>The source field should point to any file on your local filesystem or a web URL to where the file can be found. </p> <p>For example,  CRIPT protein JSON file on CRIPTScripts </p> <p>Note, that we haven't uploaded the files to CRIPT yet, this is automatically performed, when the project is uploaded via <code>api.save(project)</code>.</p>"},{"location":"examples/simulation/#create-data","title":"Create Data","text":"<p>Next, we'll create a <code>Data</code> node which helps organize our <code>File</code> nodes and links back to our <code>Computation</code> objects.</p> <pre><code>packing_data = cript.Data(\n    name=\"Loosely packed chains\",\n    type=\"computation_config\",\n    file=[packing_file],\n    computation=[init],\n    notes=\"PDB file without topology describing an initial system.\",\n)\n\nforcefield_data = cript.Data(\n    name=\"OpenMM forcefield\",\n    type=\"computation_forcefield\",\n    file=[forcefield_file],\n    computation=[init],\n    notes=\"Full forcefield definition and topology.\",\n)\n\nequilibration_snap = cript.Data(\n    name=\"Equilibrated simulation snapshot\",\n    type=\"computation_config\",\n    file=[snap_file],\n    computation=[equilibration],\n)\n\nfinal_data = cript.Data(\n    name=\"Logged volume during simulation\",\n    type=\"computation_trajectory\",\n    file=[final_file],\n    computation=[bulk],\n)\n</code></pre> <p>Data types</p> <p>The allowed <code>Data</code> types are listed under the data types in the CRIPT controlled vocabulary.</p> <p>Next, we'll link these <code>Data</code> nodes to the appropriate <code>Computation</code> nodes.</p> <pre><code># Observe how this step also forms a continuous graph, \n# enabling data to flow from one computation to the next.\n# The sequence initiates with the computation process \n# and culminates with the determination of the material property.\ninit.output_data = [packing_data, forcefield_data]\nequilibration.input_data = [packing_data, forcefield_data]\nequilibration.output_data = [equilibration_snap]\nana.input_data = [final_data]\nbulk.output_data = [final_data]\n</code></pre>"},{"location":"examples/simulation/#create-a-virtual-material","title":"Create a virtual Material","text":"<p>First, we'll create a virtual material with identifiers to make it easier to search for.</p> <pre><code># create a material node object with identifiers\npolystyrene = cript.Material(name=\"virtual polystyrene\", bigsmiles=\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[&lt;]}C(C)CC\", names = [\"poly(styrene)\", \"poly(vinylbenzene)\"], chem_repeat= [\"C8H8\"])\n</code></pre>"},{"location":"examples/simulation/#add-property-sub-objects","title":"Add <code>Property</code> sub-objects","text":"<p>Let's also add some <code>Property</code> nodes to the <code>Material</code>, which represent its physical or virtual (in the case of a simulated material) properties.</p> <pre><code>phase = cript.Property(key=\"phase\", value=\"solid\", type=\"none\", unit=None)\ncolor = cript.Property(key=\"color\", value=\"white\", type=\"none\", unit=None)\n\npolystyrene.property += [phase]\npolystyrene.property += [color]\n</code></pre> <p>Material property keys</p> <p>The allowed material <code>Property</code> keys are listed in the material property keys in the CRIPT controlled vocabulary.</p>"},{"location":"examples/simulation/#create-computationalforcefield","title":"Create <code>ComputationalForcefield</code>","text":"<p>Finally, we'll create a <code>ComputationalForcefield</code> node and link it to the Material.</p> <pre><code>forcefield = cript.ComputationalForcefield(\n    key=\"opls_aa\",\n    building_block=\"atom\",\n    source=\"Custom determination via STAGE\",\n    data=[forcefield_data],\n)\n\npolystyrene.computational_forcefield = forcefield\n</code></pre> <p>Computational forcefield keys</p> <p>The allowed <code>ComputationalForcefield</code> keys are listed under the computational forcefield keys in the CRIPT controlled vocabulary.</p> <p>Now we can save the project to CRIPT (and upload the files) or inspect the JSON output</p>"},{"location":"examples/simulation/#validate-cript-project-node","title":"Validate CRIPT Project Node","text":"<pre><code># Before we can save it, we should add all the orphaned nodes to the experiments.\n# It is important to do this for every experiment separately, \n# but here we only have one.\ncript.add_orphaned_nodes_to_project(project, active_experiment=experiment)\nproject.validate()\n\n# api.save(project)\nprint(project.get_json(indent=2).json)\n\n# Let's not forget to close the API connection after everything is done.\napi.disconnect()\n</code></pre>"},{"location":"examples/simulation/#conclusion","title":"Conclusion","text":"<p>You made it! We hope this tutorial has been helpful.</p> <p>Please let us know how you think it could be improved. Feel free to reach out to us on our CRIPT Python SDK GitHub. We'd love your inputs and contributions!</p>"},{"location":"examples/synthesis/","title":"Synthesis","text":"<p>Abstract</p> <p>This tutorial guides you through an example material synthesis workflow using the CRIPT Python SDK.</p>"},{"location":"examples/synthesis/#installation","title":"Installation","text":"<p>Before you start, be sure the cript python package is installed.</p> <pre><code>pip install cript\n</code></pre>"},{"location":"examples/synthesis/#connect-to-cript","title":"Connect to CRIPT","text":"<p>To connect to CRIPT, you must enter a <code>host</code> and an <code>API Token</code>. For most users, <code>host</code> will be <code>https://api.criptapp.org/</code>.</p> <p>Keep API Token Secure</p> <p>To ensure security, avoid storing sensitive information like tokens directly in your code. Instead, use environment variables. Storing tokens in code shared on platforms like GitHub can lead to security incidents. Anyone that possesses your token can impersonate you on the CRIPT platform. Consider alternative methods for loading tokens with the CRIPT API Client. In case your token is exposed be sure to immediately generate a new token to revoke the access of the old one and keep the new token safe.</p> <pre><code>import cript\n\nwith cript.API(host=\"https://api.criptapp.org/\", api_token=\"123456\", storage_token=\"987654\") as api:\n    pass\n</code></pre> <p>Note</p> <p>You may notice, that we are not executing any code inside the context manager block. If you were to write a python script, compared to a jupyter notebook, you would add all the following code inside that block. Here in a jupyter notebook, we need to connect manually. We just have to remember to disconnect at the end.</p> <pre><code>api = cript.API(host=\"https://api.criptapp.org/\", api_token=None, storage_token=\"123456\")\napi = api.connect()\n</code></pre>"},{"location":"examples/synthesis/#create-a-project","title":"Create a Project","text":"<p>All data uploaded to CRIPT must be associated with a project node. Project can be thought of as an overarching research goal. For example, finding a replacement for an existing material from a sustainable feedstock.</p> <pre><code># create a new project in the CRIPT database\nproject = cript.Project(name=\"My first project.\")\n</code></pre>"},{"location":"examples/synthesis/#create-a-collection-node","title":"Create a Collection node","text":"<p>For this project, you can create multiple collections, which represent a set of experiments. For example, you can create a collection for a specific manuscript, or you can create a collection for initial screening of candidates and one for later refinements etc.</p> <p>So, let's create a collection node and add it to the project.</p> <pre><code>collection = cript.Collection(name=\"Initial screening\")\n# We add this collection to the project as a list.\nproject.collection += [collection]\n</code></pre> <p>Viewing CRIPT JSON</p> <p>Note, that if you are interested into the inner workings of CRIPT, you can obtain a JSON representation of your data graph at any time to see what is being sent to the API.</p> <pre><code>print(project.json)\nprint(\"\\n Or more pretty \\n\")\nprint(project.get_json(indent=2).json)\n</code></pre>"},{"location":"examples/synthesis/#create-an-experiment-node","title":"Create an Experiment node","text":"<p>The collection node holds a series of Experiment nodes nodes.</p> <p>And we can add this experiment to the collection of the project.</p> <pre><code>experiment = cript.Experiment(name=\"Anionic Polymerization of Styrene with SecBuLi\")\ncollection.experiment += [experiment]\n</code></pre>"},{"location":"examples/synthesis/#create-an-inventory","title":"Create an Inventory","text":"<p>An Inventory contains materials, that are well known and usually not of polymeric nature. They are for example the chemical you buy commercially and use as input into your synthesis.</p> <p>For this we create this inventory by adding the Material we need one by one.</p> <pre><code>solution = cript.Material(\n    name=\"SecBuLi solution 1.4M cHex\",\n    chemical_id = \"598-30-1\",\n)\n</code></pre> <p>These materials are simple, notice how we use the SMILES notation here as an identifier for the material. Similarly, we can create more initial materials.</p> <pre><code>toluene = cript.Material(name=\"toluene\", smiles=\"Cc1ccccc1\", pubchem_cid = 1140)\nstyrene = cript.Material(name=\"styrene\", smiles = \"c1ccccc1C=C\", inchi = \"InChI=1S/C8H8/c1-2-8-6-4-3-5-7-8/h2-7H,1H2\")\nbutanol = cript.Material(name=\"1-butanol\", smiles = \"OCCCC\", inchi_key = \"InChIKey=LRHPLDYGYMQRHN-UHFFFAOYSA-N\")\nmethanol = cript.Material(name=\"methanol\", smiles = \"CO\", names = [\"Butan-1-ol\", \"Butyric alcohol\", \"Methylolpropane\", \"n-Butan-1-ol\", \"methanol\"])\n</code></pre> <p>Now that we defined those materials, we can combine them into an inventory for easy access and sharing between experiments/projects.</p> <pre><code>inventory = cript.Inventory(\n    name=\"Common chemicals for poly-styrene synthesis\",\n    material=[solution, toluene, styrene, butanol, methanol],\n)\ncollection.inventory += [inventory]\n</code></pre>"},{"location":"examples/synthesis/#create-a-process-node","title":"Create a Process node","text":"<p>A Process is a step in an experiment. You decide how many Process are required for your experiment, so you can list details for your experiment as fine-grained as desired. Here we use just one step to describe the entire synthesis.</p> <pre><code>process = cript.Process(\n    name=\"Anionic of Synthesis Poly-Styrene\",\n    type=\"multistep\",\n    description=\"In an argon filled glove box, a round bottom flask was filled with 216 ml of dried toluene. The \"\n    \"solution of secBuLi (3 ml, 3.9 mmol) was added next, followed by styrene (22.3 g, 176 mmol) to \"\n    \"initiate the polymerization. The reaction mixture immediately turned orange. After 30 min, \"\n    \"the reaction was quenched with the addition of 3 ml of methanol. The polymer was isolated by \"\n    \"precipitation in methanol 3 times and dried under vacuum.\",\n)\nexperiment.process += [process]\n</code></pre>"},{"location":"examples/synthesis/#add-ingredients-to-a-process","title":"Add Ingredients to a Process","text":"<p>From a chemistry standpoint, most experimental processes, regardless of whether they are carried out in the lab or simulated using computer code, consist of input ingredients that are transformed in some way. Let's add ingredients to the Process that we just created. For this we use the materials from the inventory. Next, define Quantities nodes indicating the amount of each Ingredient that we will use in the Process.</p> <pre><code>initiator_qty = cript.Quantity(key=\"volume\", value=1.7e-8, unit=\"m**3\")\nsolvent_qty = cript.Quantity(key=\"volume\", value=1e-4, unit=\"m**3\")\nmonomer_qty = cript.Quantity(key=\"mass\", value=0.455e-3, unit=\"kg\")\nquench_qty = cript.Quantity(key=\"volume\", value=5e-3, unit=\"m**3\")\nworkup_qty = cript.Quantity(key=\"volume\", value=0.1, unit=\"m**3\")\n</code></pre> <p>Now we can create an Ingredient node for each ingredient using the Material and quantities attributes.</p> <pre><code>initiator = cript.Ingredient(\n    keyword=[\"initiator\"], material=solution, quantity=[initiator_qty]\n)\n\nsolvent = cript.Ingredient(\n    keyword=[\"solvent\"], material=toluene, quantity=[solvent_qty]\n)\n\nmonomer = cript.Ingredient(\n    keyword=[\"monomer\"], material=styrene, quantity=[monomer_qty]\n)\n\nquench = cript.Ingredient(\n    keyword=[\"quench\"], material=butanol, quantity=[quench_qty]\n)\n\nworkup = cript.Ingredient(\n    keyword=[\"workup\"], material=methanol, quantity=[workup_qty]\n)\n</code></pre> <p>Finally, we can add the <code>Ingredient</code> nodes to the <code>Process</code> node.</p> <pre><code>process.ingredient += [initiator, solvent, monomer, quench, workup]\n</code></pre>"},{"location":"examples/synthesis/#add-conditions-to-the-process","title":"Add Conditions to the Process","text":"<p>Its possible that our <code>Process</code> was carried out under specific physical conditions. We can codify this by adding Condition nodes to the process.</p> <pre><code>temp = cript.Condition(key=\"temperature\", type=\"value\", value=25, unit=\"celsius\")\ntime = cript.Condition(key=\"time_duration\", type=\"value\", value=60, unit=\"min\")\nprocess.condition = [temp, time]\n</code></pre>"},{"location":"examples/synthesis/#add-a-property-to-a-process","title":"Add a Property to a Process","text":"<p>We may also want to associate our process with certain properties. We can do this by adding Property nodes to the process.</p> <pre><code>yield_mass = cript.Property(key=\"yield_mass\", type=\"number\", value=47e-5, unit=\"kilogram\", method=\"scale\")\nprocess.property += [yield_mass]\n</code></pre>"},{"location":"examples/synthesis/#create-a-material-node-process-product","title":"Create a Material node (process product)","text":"<p>Along with input Ingredients, our Process may also produce product materials.</p> <p>First, let's create the Material that will serve as our product. We give the material a <code>name</code> attribute and add it to our [Project]((../../nodes/primary_nodes/project).</p> <pre><code>polystyrene = cript.Material(name=\"polystyrene\", bigsmiles=\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[&lt;]}C(C)CC\")\nproject.material += [polystyrene]\n</code></pre> <p>Let's add some <code>Identifiers</code> to the material to make it easier to identify and search.</p> <pre><code># create a chemical repeat unit identifier\npolystyrene.chem_repeat = [\"C8H8\"]\n</code></pre> <p>Next, we'll add some Property nodes to the Material , which represent its physical or virtual (in the case of a simulated material) properties.</p> <pre><code># create a phase property\nphase = cript.Property(key=\"phase\", value=\"solid\", type=\"none\", unit=None)\n# create a color property\ncolor = cript.Property(key=\"color\", value=\"white\", type=\"none\", unit=None)\n\n# add the properties to the material\npolystyrene.property += [phase, color]\n</code></pre> <p>Congratulations! You've just created a process that represents the polymerization reaction of Polystyrene, starting with a set of input ingredients in various quantities, and ending with a new polymer with specific identifiers and physical properties.</p> <p>Now we can save the project to CRIPT via the api object.</p> <pre><code>project.validate()\nprint(project.get_json(indent=2, condense_to_uuid={}).json)\n# api.save(project)\n</code></pre> <pre><code># Don't forget to disconnect once everything is done\napi.disconnect()\n</code></pre>"},{"location":"exceptions/api_exceptions/","title":"API Exceptions","text":""},{"location":"exceptions/api_exceptions/#api-client-exceptions","title":"API Client Exceptions","text":""},{"location":"exceptions/api_exceptions/#cript.api.exceptions.APIError","title":"<code>APIError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.APIError--definition","title":"Definition","text":"<p>This is a generic error made to display API errors to the user to troubleshoot.</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.APIError--troubleshooting","title":"Troubleshooting","text":"<p>Please keep in mind that the CRIPT Python SDK turns the Project node into a giant JSON and sends that to the API to be processed. If there are any errors while processing the giant JSON generated by the CRIPT Python SDK, then the API will return an error about the http request and the JSON sent to it.</p> <p>The best way to trouble shoot this is to figure out what the API error means and figure out where in the Python SDK this error occurred and what could be the reason under the hood.</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.APIError--steps-to-try","title":"Steps to try:","text":"<ol> <li>What does the API error mean?<ol> <li>Is the error something you can easily fix by maybe renaming a node?</li> <li>Does the <code>http_method</code> look reasonable?</li> <li>Does the <code>URL</code> that the data was sent to look reasonable?</li> </ol> </li> <li>Is there a problem within the JSON?</li> <li>Is the problem within how the SDK is converting nodes from and to JSON (serialization and deserialization)?</li> </ol> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class APIError(CRIPTException):\n    \"\"\"\n    ## Definition\n    This is a generic error made to display API errors to the user to troubleshoot.\n\n    ## Troubleshooting\n    Please keep in mind that the CRIPT Python SDK turns the [Project](../../nodes/primary_nodes/project)\n    node into a giant JSON and sends that to the API to be processed. If there are any errors while processing\n    the giant JSON generated by the CRIPT Python SDK, then the API will return an error about the http request\n    and the JSON sent to it.\n\n    The best way to trouble shoot this is to figure out what the API error means and figure out where\n    in the Python SDK this error occurred and what could be the reason under the hood.\n\n    ### Steps to try:\n    1. What does the API error mean?\n        1. Is the error something you can easily fix by maybe renaming a node?\n        1. Does the `http_method` look reasonable?\n        1. Does the `URL` that the data was sent to look reasonable?\n    1. Is there a problem within the JSON?\n    1. Is the problem within how the SDK is converting nodes from and to JSON (serialization and deserialization)?\n    \"\"\"\n\n    api_error: str = \"\"\n\n    # having the URL that the API gave an error for helps in debugging\n    api_url: str = \"\"\n    http_method: str = \"\"\n\n    @beartype\n    def __init__(self, api_error: str, http_method: str, api_url: str) -&gt; None:\n        self.api_error = api_error\n\n        self.api_url = api_url\n\n        # TODO consider having an enum for all the HTTP methods so they are easily entered and disallows anything\n        #   that would be not make sense\n        self.http_method = http_method\n\n    def __str__(self) -&gt; str:\n        return f\"CRIPT Python SDK sent HTTP `{self.http_method.upper()}` request to URL: `{self.api_url}` and API responded with {self.api_error}\"\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTAPIRequiredError","title":"<code>CRIPTAPIRequiredError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTAPIRequiredError--definition","title":"Definition","text":"<p>Exception to be raised when the API object is requested, but no cript.API object exists yet. Also make sure to use it in a context manager <code>with cript.API as api:</code> or  manually call <code>connect</code> and <code>disconnect</code>.</p> <p>The CRIPT Python SDK relies on a cript.API object for creation, validation, and modification of nodes. The cript.API object may be explicitly called by the user to perform operations to the API, or implicitly called by the Python SDK under the hood to perform some sort of validation.</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTAPIRequiredError--troubleshooting","title":"Troubleshooting","text":"<p>To fix this error please instantiate an api object</p> <pre><code>import cript\n\nmy_host = \"https://api.criptapp.org/\"\nmy_token = \"123456\" # To use your token securely, please consider using environment variables\n\nmy_api = cript.API(host=my_host, token=my_token)\nmy_api.connect()\n# Your code\nmy_api.disconnect()\n</code></pre> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class CRIPTAPIRequiredError(CRIPTException):\n    \"\"\"\n    ## Definition\n    Exception to be raised when the API object is requested, but no cript.API object exists yet.\n    Also make sure to use it in a context manager `with cript.API as api:` or  manually call\n    `connect` and `disconnect`.\n\n    The CRIPT Python SDK relies on a cript.API object for creation, validation, and modification of nodes.\n    The cript.API object may be explicitly called by the user to perform operations to the API, or\n    implicitly called by the Python SDK under the hood to perform some sort of validation.\n\n    ## Troubleshooting\n    To fix this error please instantiate an api object\n\n    ```python\n    import cript\n\n    my_host = \"https://api.criptapp.org/\"\n    my_token = \"123456\" # To use your token securely, please consider using environment variables\n\n    my_api = cript.API(host=my_host, token=my_token)\n    my_api.connect()\n    # Your code\n    my_api.disconnect()\n    ```\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def __str__(self) -&gt; str:\n        error_message = (\n            \"cript.API object is required for an operation, but it does not exist.\"\n            \"Please instantiate a cript.API object and connect it to API for example with a context manager `with cript.API() as api:` to continue.\"\n            \"See the documentation for more details.\"\n        )\n\n        return error_message\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTAPISaveError","title":"<code>CRIPTAPISaveError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTAPISaveError--definition","title":"Definition","text":"<p>CRIPTAPISaveError is raised when the API responds with a http status code that is anything other than 200. The status code and API response is shown to the user to help them debug the issue.</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTAPISaveError--troubleshooting","title":"Troubleshooting","text":"<p>This error is more of a case by case basis, but the best way to approach it to understand that the CRIPT Python SDK sent an HTTP POST request with a giant JSON in the request body to the CRIPT API. The API then read that request, and it responded with some sort of error either to the that JSON or how the request was sent.</p> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class CRIPTAPISaveError(CRIPTException):\n    \"\"\"\n    ## Definition\n    CRIPTAPISaveError is raised when the API responds with a http status code that is anything other than 200.\n    The status code and API response is shown to the user to help them debug the issue.\n\n    ## Troubleshooting\n    This error is more of a case by case basis, but the best way to approach it to understand that the\n    CRIPT Python SDK sent an HTTP POST request with a giant JSON in the request body\n    to the CRIPT API. The API then read that request, and it responded with some sort of error either\n    to the that JSON or how the request was sent.\n    \"\"\"\n\n    api_host_domain: str\n    http_code: str\n    api_response: str\n\n    def __init__(self, api_host_domain: str, http_code: str, api_response: str, patch_request: bool, pre_saved_nodes: Set[str], json_data: str):\n        self.api_host_domain = api_host_domain\n        self.http_code = http_code\n        self.api_response = api_response\n        self.patch_request = patch_request\n        self.pre_saved_nodes = pre_saved_nodes\n        self.json_data = json_data\n\n    def __str__(self) -&gt; str:\n        type = \"POST\"\n        if self.patch_request:\n            type = \"PATCH\"\n        error_message = f\"API responded to {type} with 'http:{self.http_code} {self.api_response}'\"\n        if self.json_data:\n            error_message += f\" data: {self.json_data}\"\n\n        return error_message\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTConnectionError","title":"<code>CRIPTConnectionError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTConnectionError--definition","title":"Definition","text":"<p>Raised when the cript.API object cannot connect to CRIPT with the given host and token</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTConnectionError--troubleshooting","title":"Troubleshooting","text":"<p>The best way to fix this error is to check that your host and token are written and used correctly within the cript.API object. This error could also be shown if the API is unresponsive and the cript.API object just cannot successfully connect to it.</p> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class CRIPTConnectionError(CRIPTException):\n    \"\"\"\n    ## Definition\n    Raised when the cript.API object cannot connect to CRIPT with the given host and token\n\n    ## Troubleshooting\n    The best way to fix this error is to check that your host and token are written and used correctly within\n    the cript.API object. This error could also be shown if the API is unresponsive and the cript.API object\n    just cannot successfully connect to it.\n    \"\"\"\n\n    def __init__(self, host, token):\n        self.host = host\n        # Do not store full token in stack trace for security reasons\n        uncovered_chars = len(token) // 4\n        self.token = token[:uncovered_chars]\n        self.token += \"*\" * (len(token) - 2 * uncovered_chars)\n        self.token += token[-uncovered_chars:]\n\n    def __str__(self) -&gt; str:\n        error_message = f\"Could not connect to CRIPT with the given host ({self.host}) and token ({self.token}). \" f\"Please be sure both host and token are entered correctly.\"\n\n        return error_message\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.CRIPTDuplicateNameError","title":"<code>CRIPTDuplicateNameError</code>","text":"<p>             Bases: <code>CRIPTAPISaveError</code></p> <p>Exception raised when attempting to save a node with a name that already exists in CRIPT.</p> <p>This exception class extends <code>CRIPTAPISaveError</code> and is used to handle errors that occur when a node's name duplicates an existing node's name in the CRIPT database.</p> <p>Parameters:</p> Name Type Description Default <code>api_response</code> <code>dict</code> <p>The response returned from the API that contains the error details.</p> required <code>json_data</code> <code>str</code> <p>The JSON data of the node that caused the duplication error.</p> required <code>parent_cript_save_error</code> <code>CRIPTAPISaveError</code> <p>The original <code>CRIPTAPISaveError</code> instance containing additional context of the error.</p> required <code>Make</code> required <code>If</code> required Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class CRIPTDuplicateNameError(CRIPTAPISaveError):\n    \"\"\"\n    Exception raised when attempting to save a node with a name that already exists in CRIPT.\n\n    This exception class extends `CRIPTAPISaveError` and is used to handle errors\n    that occur when a node's name duplicates an existing node's name in the CRIPT database.\n\n    Parameters\n    ----------\n    api_response : dict\n        The response returned from the API that contains the error details.\n    json_data : str\n        The JSON data of the node that caused the duplication error.\n    parent_cript_save_error : CRIPTAPISaveError\n        The original `CRIPTAPISaveError` instance containing additional context of the error.\n\n    ## Troubleshooting\n    #### Duplicate Name Errors\n    Make sure that the name you are using to save a node is unique and does not already exist in the database.\n    If you encounter a `CRIPTDuplicateNameError`, check the name of your node and try a different name.\n    \"\"\"\n\n    def __init__(self, api_response, json_data: str, parent_cript_save_error: CRIPTAPISaveError):\n        super().__init__(\n            parent_cript_save_error.api_host_domain, api_response[\"code\"], api_response=api_response[\"error\"], patch_request=parent_cript_save_error.patch_request, pre_saved_nodes=parent_cript_save_error.pre_saved_nodes, json_data=json_data\n        )\n\n        # We don't care if the data is invalid JSON\n        # So let's catch a couple of common exceptions and ensure still meaning error messages\n        # (and debug info in case it does happen.)\n        try:\n            json_dict = json.loads(self.json_data)\n        except (TypeError, json.JSONDecodeError):\n            self.name = \"unknown_name\"\n            self.node = \"UnknownType\"\n        try:\n            self.name = json_dict[\"name\"]\n        except KeyError:\n            self.name = \"unknown_name_key\"\n        try:\n            self.node = json_dict[\"node\"][0]\n        except KeyError:\n            self.node = \"UnknownTypeKey\"\n        except IndexError:\n            self.node = \"UnknownTypeIdx\"\n\n    def __str__(self) -&gt; str:\n        return f\"The name '{self.name}' for your {self.node} node is already present in CRIPT. Please use a unique name\"\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.FileDownloadError","title":"<code>FileDownloadError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.FileDownloadError--definition","title":"Definition","text":"<p>This error is raised when the API wants to download a file from an AWS S3 URL via the <code>cript.API.download_file()</code> method, but the status is something other than 200.</p> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class FileDownloadError(CRIPTException):\n    \"\"\"\n    ## Definition\n    This error is raised when the API wants to download a file from an AWS S3 URL\n    via the `cript.API.download_file()` method, but the status is something other than 200.\n    \"\"\"\n\n    error_message: str = \"\"\n\n    def __init__(self, error_message: str) -&gt; None:\n        self.error_message = error_message\n\n    def __str__(self) -&gt; str:\n        return self.error_message\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.InvalidHostError","title":"<code>InvalidHostError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.InvalidHostError--definition","title":"Definition","text":"<p>Exception is raised when the host given to the API is invalid</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.InvalidHostError--troubleshooting","title":"Troubleshooting","text":"<p>This is a simple error to fix, simply put <code>http://</code> or preferably <code>https://</code> in front of your domain when passing in the host to the cript.API class such as <code>https://api.criptapp.org/</code></p> <p>Currently, the only web protocol that is supported with the CRIPT Python SDK is <code>HTTP</code>.</p>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.InvalidHostError--example","title":"Example","text":"<pre><code>import cript\n\nmy_valid_host = \"https://api.criptapp.org/\"\nmy_token = \"123456\" # To use your token securely, please consider using environment variables\n\nmy_api = cript.API(host=my_valid_host, token=my_token)\n</code></pre> Warnings <p>Please consider always using HTTPS as that is a secure protocol and avoid using <code>HTTP</code> as it is insecure. The CRIPT Python SDK will give a warning in the terminal when it detects a host with <code>HTTP</code></p> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class InvalidHostError(CRIPTException):\n    \"\"\"\n    ## Definition\n    Exception is raised when the host given to the API is invalid\n\n    ## Troubleshooting\n    This is a simple error to fix, simply put `http://` or preferably `https://` in front of your domain\n    when passing in the host to the cript.API class such as `https://api.criptapp.org/`\n\n    Currently, the only web protocol that is supported with the CRIPT Python SDK is `HTTP`.\n\n    ### Example\n    ```python\n    import cript\n\n    my_valid_host = \"https://api.criptapp.org/\"\n    my_token = \"123456\" # To use your token securely, please consider using environment variables\n\n    my_api = cript.API(host=my_valid_host, token=my_token)\n    ```\n\n    Warnings\n    --------\n    Please consider always using [HTTPS](https://developer.mozilla.org/en-US/docs/Glossary/HTTPS)\n    as that is a secure protocol and avoid using `HTTP` as it is insecure.\n    The CRIPT Python SDK will give a warning in the terminal when it detects a host with `HTTP`\n\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        pass\n\n    def __str__(self) -&gt; str:\n        return \"The host must start with http or https\"\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.InvalidVocabulary","title":"<code>InvalidVocabulary</code>","text":"<p>             Bases: <code>CRIPTException</code></p> <p>Raised when the CRIPT controlled vocabulary is invalid</p> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class InvalidVocabulary(CRIPTException):\n    \"\"\"\n    Raised when the CRIPT controlled vocabulary is invalid\n    \"\"\"\n\n    vocab: str = \"\"\n    possible_vocab: List[str] = []\n\n    def __init__(self, vocab: str, possible_vocab: List[str]) -&gt; None:\n        self.vocab = vocab\n        self.possible_vocab = possible_vocab\n\n    def __str__(self) -&gt; str:\n        error_message = f\"The vocabulary '{self.vocab}' entered does not exist within the CRIPT controlled vocabulary.\" f\" Please pick a valid CRIPT vocabulary from {self.possible_vocab}\"\n        return error_message\n</code></pre>"},{"location":"exceptions/api_exceptions/#cript.api.exceptions.InvalidVocabularyCategory","title":"<code>InvalidVocabularyCategory</code>","text":"<p>             Bases: <code>CRIPTException</code></p> <p>Raised when the CRIPT controlled vocabulary category is unknown and gives the user a list of all valid vocabulary categories</p> Source code in <code>src/cript/api/exceptions.py</code> <pre><code>class InvalidVocabularyCategory(CRIPTException):\n    \"\"\"\n    Raised when the CRIPT controlled vocabulary category is unknown\n    and gives the user a list of all valid vocabulary categories\n    \"\"\"\n\n    def __init__(self, vocab_category: str, valid_vocab_category: List[str]):\n        self.vocab_category = vocab_category\n        self.valid_vocab_category = valid_vocab_category\n\n    def __str__(self) -&gt; str:\n        error_message = f\"The vocabulary category {self.vocab_category} does not exist within the CRIPT controlled vocabulary. \" f\"Please pick a valid CRIPT vocabulary category from {self.valid_vocab_category}.\"\n\n        return error_message\n</code></pre>"},{"location":"exceptions/node_exceptions/","title":"Node Exceptions","text":""},{"location":"exceptions/node_exceptions/#node-exceptions","title":"Node Exceptions","text":""},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTAttributeModificationError","title":"<code>CRIPTAttributeModificationError</code>","text":"<p>             Bases: <code>CRIPTException</code></p> <p>Exception that is thrown when a node attribute is modified, that wasn't intended to be modified.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTAttributeModificationError(CRIPTException):\n    \"\"\"\n    Exception that is thrown when a node attribute is modified, that wasn't intended to be modified.\n    \"\"\"\n\n    def __init__(self, name, key, value):\n        self.name = name\n        self.key = key\n        self.value = value\n\n    def __str__(self):\n        return (\n            f\"Attempt to modify an attribute of a node ({self.name}) that wasn't intended to be modified.\\n\"\n            f\"Here the non-existing attribute {self.key} of {self.name} was attempted to be modified.\\n\"\n            \"Most likely this is due to a typo in the attribute that was intended to be modified i.e. `project.materials` instead of `project.material`.\\n\"\n            \"To ensure compatibility with the underlying CRIPT data model we do not allow custom attributes.\\n\"\n        )\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTDeserializationUIDError","title":"<code>CRIPTDeserializationUIDError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTDeserializationUIDError--definition","title":"Definition","text":"<p>This exception is raised when converting a node from JSON to Python class fails, because a node is specified with its UID only, but not part of the data graph elsewhere.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTDeserializationUIDError--error-example","title":"Error Example","text":"<p>Invalid JSON that cannot be deserialized to a CRIPT Python SDK Node</p> <p><pre><code>{\n\"node\": [\"Algorithm\"],\n\"key\": \"mc_barostat\",\n\"type\": \"barostat\",\n\"parameter\": {\"node\": [\"Parameter\"], \"uid\": \"uid-string\"}\n}\n</code></pre> Here the algorithm has a parameter attribute, but the parameter is specified as uid only.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTDeserializationUIDError--valid-example","title":"Valid Example","text":"<p>Valid JSON that can be deserialized to a CRIPT Python SDK Node</p> <p><pre><code>{\n   \"node\":[\"Algorithm\"],\n   \"key\":\"mc_barostat\",\n   \"type\":\"barostat\",\n   \"parameter\":{\n      \"node\":[\"Parameter\"],\n      \"uid\":\"uid-string\",\n      \"key\":\"update_frequency\",\n      \"value\":1,\n      \"unit\":\"1/second\"\n   }\n}\n</code></pre> Now the node is fully specified.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTDeserializationUIDError--troubleshooting","title":"Troubleshooting","text":"<p>Specify the full node instead. This error might appear if you try to partially load previously generated JSON.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTDeserializationUIDError(CRIPTException):\n    \"\"\"\n    ## Definition\n    This exception is raised when converting a node from JSON to Python class fails,\n    because a node is specified with its UID only, but not part of the data graph elsewhere.\n\n    ### Error Example\n    Invalid JSON that cannot be deserialized to a CRIPT Python SDK Node\n\n    ```json\n    {\n    \"node\": [\"Algorithm\"],\n    \"key\": \"mc_barostat\",\n    \"type\": \"barostat\",\n    \"parameter\": {\"node\": [\"Parameter\"], \"uid\": \"uid-string\"}\n    }\n    ```\n    Here the algorithm has a parameter attribute, but the parameter is specified as uid only.\n\n    ### Valid Example\n    Valid JSON that can be deserialized to a CRIPT Python SDK Node\n\n    ```json\n    {\n       \"node\":[\"Algorithm\"],\n       \"key\":\"mc_barostat\",\n       \"type\":\"barostat\",\n       \"parameter\":{\n          \"node\":[\"Parameter\"],\n          \"uid\":\"uid-string\",\n          \"key\":\"update_frequency\",\n          \"value\":1,\n          \"unit\":\"1/second\"\n       }\n    }\n    ```\n    Now the node is fully specified.\n\n    ## Troubleshooting\n    Specify the full node instead. This error might appear if you try to partially load previously generated JSON.\n    \"\"\"\n\n    def __init__(self, node_type: str, uid: str) -&gt; None:\n        self.node_type = node_type\n        self.uid = uid\n\n    def __str__(self) -&gt; str:\n        return f\"JSON deserialization failed for node type {self.node_type} with unknown UID: {self.uid}\"\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonDeserializationError","title":"<code>CRIPTJsonDeserializationError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonDeserializationError--definition","title":"Definition","text":"<p>This exception is raised when converting a node from JSON to Python class fails. This process fails when the attributes within the JSON does not match the node's class attributes within the <code>JsonAttributes</code> of that specific node</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonDeserializationError--error-example","title":"Error Example","text":"<p>Invalid JSON that cannot be deserialized to a CRIPT Python SDK Node</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonDeserializationError--valid-example","title":"Valid Example","text":"<p>Valid JSON that can be deserialized to a CRIPT Python SDK Node</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonDeserializationError--troubleshooting","title":"Troubleshooting","text":"Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTJsonDeserializationError(CRIPTException):\n    \"\"\"\n    ## Definition\n    This exception is raised when converting a node from JSON to Python class fails.\n    This process fails when the attributes within the JSON does not match the node's class\n    attributes within the `JsonAttributes` of that specific node\n\n    ### Error Example\n    Invalid JSON that cannot be deserialized to a CRIPT Python SDK Node\n\n    ```json\n    ```\n\n\n    ### Valid Example\n    Valid JSON that can be deserialized to a CRIPT Python SDK Node\n\n    ```json\n    ```\n\n    ## Troubleshooting\n    \"\"\"\n\n    def __init__(self, node_type: str, json_str: str) -&gt; None:\n        self.node_type = node_type\n        self.json_str = json_str\n\n    def __str__(self) -&gt; str:\n        return f\"JSON deserialization failed for node type {self.node_type} with JSON str: {self.json_str}\"\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonNodeError","title":"<code>CRIPTJsonNodeError</code>","text":"<p>             Bases: <code>CRIPTJsonDeserializationError</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonNodeError--definition","title":"Definition","text":"<p>This exception is raised if a <code>node</code> attribute is present in JSON, but the list has more or less than exactly one type of node type.</p> <p>Note: It is expected that there is only a single node type per JSON object.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonNodeError--example","title":"Example","text":"<p>Valid JSON representation of a Material node</p> <pre><code>{\n  \"node\": [\n    \"Material\"\n  ],\n  \"name\": \"Whey protein isolate\",\n  \"uid\": \"_:Whey protein isolate\"\n},\n</code></pre> Invalid JSON representation of a Material node <pre><code>{\n  \"node\": [\n    \"Material\",\n    \"Property\"\n  ],\n  \"name\": \"Whey protein isolate\",\n  \"uid\": \"_:Whey protein isolate\"\n},\n</code></pre> <pre><code>{\n  \"node\": [],\n  \"name\": \"Whey protein isolate\",\n  \"uid\": \"_:Whey protein isolate\"\n},\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonNodeError--troubleshooting","title":"Troubleshooting","text":"<p>Debugging skills are most helpful here as there is no one-size-fits-all approach.</p> <p>It is best to identify whether the invalid JSON was created in the Python SDK or if the invalid JSON was given from the API.</p> <p>If the Python SDK created invalid JSON during serialization, then it is helpful to track down and identify the point where the invalid JSON was started.</p> <p>You may consider, inspecting the python objects to see if the node type are written incorrectly in python and the issue is only being caught during serialization or if the Python node is written correctly and the issue is created during serialization.</p> <p>If the problem is with the Python SDK or API, it is best to leave an issue or create a discussion within the Python SDK GitHub repository for one of the members of the CRIPT team to look into any issues that there could have been.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTJsonNodeError(CRIPTJsonDeserializationError):\n    \"\"\"\n    ## Definition\n    This exception is raised if a `node` attribute is present in JSON,\n    but the list has more or less than exactly one type of node type.\n\n    &gt; Note: It is expected that there is only a single node type per JSON object.\n\n    ### Example\n    !!! Example \"Valid JSON representation of a Material node\"\n        ```json\n        {\n          \"node\": [\n            \"Material\"\n          ],\n          \"name\": \"Whey protein isolate\",\n          \"uid\": \"_:Whey protein isolate\"\n        },\n        ```\n\n    ??? Example \"Invalid JSON representation of a Material node\"\n\n        ```json\n        {\n          \"node\": [\n            \"Material\",\n            \"Property\"\n          ],\n          \"name\": \"Whey protein isolate\",\n          \"uid\": \"_:Whey protein isolate\"\n        },\n        ```\n\n        ---\n\n        ```json\n        {\n          \"node\": [],\n          \"name\": \"Whey protein isolate\",\n          \"uid\": \"_:Whey protein isolate\"\n        },\n        ```\n\n\n    ## Troubleshooting\n    Debugging skills are most helpful here as there is no one-size-fits-all approach.\n\n    It is best to identify whether the invalid JSON was created in the Python SDK\n    or if the invalid JSON was given from the API.\n\n    If the Python SDK created invalid JSON during serialization, then it is helpful to track down and\n    identify the point where the invalid JSON was started.\n\n    You may consider, inspecting the python objects to see if the node type are written incorrectly in python\n    and the issue is only being caught during serialization or if the Python node is written correctly\n    and the issue is created during serialization.\n\n    If the problem is with the Python SDK or API, it is best to leave an issue or create a discussion within the\n    [Python SDK GitHub repository](https://github.com/C-Accel-CRIPT/Python-SDK) for one of the members of the\n    CRIPT team to look into any issues that there could have been.\n    \"\"\"\n\n    def __init__(self, node_list: List, json_str: str) -&gt; None:\n        self.node_list = node_list\n        self.json_str = json_str\n\n    def __str__(self) -&gt; str:\n        error_message: str = f\"The 'node' attribute in the JSON string must be a single element list with the node name \" f\" such as `'node: ['Material']`. The `node` attribute provided was: `{self.node_list}`\" f\"The full JSON was: {self.json_str}.\"\n\n        return error_message\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonSerializationError","title":"<code>CRIPTJsonSerializationError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonSerializationError--definition","title":"Definition","text":"<p>This Exception is raised if serialization of node from JSON to Python Object fails.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTJsonSerializationError--troubleshooting","title":"Troubleshooting","text":"Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTJsonSerializationError(CRIPTException):\n    \"\"\"\n    ## Definition\n    This Exception is raised if serialization of node from JSON to Python Object fails.\n\n    ## Troubleshooting\n    \"\"\"\n\n    def __init__(self, node_type: str, json_dict: str) -&gt; None:\n        self.node_type = node_type\n        self.json_str = str(json_dict)\n\n    def __str__(self) -&gt; str:\n        return f\"JSON Serialization failed for node type {self.node_type} with JSON dict: {self.json_str}\"\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTMaterialIdentifierWarning","title":"<code>CRIPTMaterialIdentifierWarning</code>","text":"<p>             Bases: <code>CRIPTWarning</code></p> <p>Every material node needs to have at least one identifier set.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTMaterialIdentifierWarning(CRIPTWarning):\n    \"\"\"Every material node needs to have at least one identifier set.\"\"\"\n\n    def __init__(self, material_node):\n        self.material_node = material_node\n\n    def __str__(self) -&gt; str:\n        error_message = \"Every Material node needs at least one identifier from \"\n        error_message += \" [ 'amino_acid', 'bigsmiles', 'chem_formula', 'chem_repeat', 'chemical_id', 'inchi', 'lot_number', 'names', 'pubchem_cid', 'smiles','vendor'] set.\"\n        error_message += f\" This node {self.material_node} has none set.\"\n        return error_message\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTNodeSchemaError","title":"<code>CRIPTNodeSchemaError</code>","text":"<p>             Bases: <code>CRIPTException</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTNodeSchemaError--definition","title":"Definition","text":"<p>This error is raised when the CRIPT json database schema validation fails for a node.</p> <p>Please keep in mind that the CRIPT Python SDK converts all the Python nodes inside the Project into a giant JSON and sends an HTTP <code>POST</code> or <code>PATCH</code> request to the API to be processed.</p> <p>However, before a request is sent to the API, the JSON is validated against API database schema via the JSON Schema library, and if the database schema validation fails for whatever reason this error is shown.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTNodeSchemaError--possible-reasons","title":"Possible Reasons","text":"<ol> <li>There was a mistake in nesting of the nodes</li> <li>There was a mistake in creating the nodes</li> <li>Nodes are missing</li> <li>Nodes have invalid vocabulary<ul> <li>The database schema wants something a different controlled vocabulary than what is provided</li> </ul> </li> <li>There was an error with the way the JSON was created within the Python SDK<ul> <li>The format of the JSON the CRIPT Python SDK created was invalid</li> </ul> </li> <li>There is something wrong with the database schema</li> </ol>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTNodeSchemaError--troubleshooting","title":"Troubleshooting","text":"<p>The easiest way to troubleshoot this is to examine the JSON that the SDK created via printing out the Project node's JSON and checking the place that the schema validation says failed</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTNodeSchemaError--example","title":"Example","text":"<pre><code>print(my_project.json)\n</code></pre> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTNodeSchemaError(CRIPTException):\n    \"\"\"\n    ## Definition\n    This error is raised when the CRIPT [json database schema](https://json-schema.org/)\n    validation fails for a node.\n\n    Please keep in mind that the CRIPT Python SDK converts all the Python nodes inside the\n    [Project](../../nodes/primary_nodes/project) into a giant JSON\n    and sends an HTTP `POST` or `PATCH` request to the API to be processed.\n\n    However, before a request is sent to the API, the JSON is validated against API database schema\n    via the [JSON Schema library](https://python-jsonschema.readthedocs.io/en/stable/),\n    and if the database schema validation fails for whatever reason this error is shown.\n\n    ### Possible Reasons\n\n    1. There was a mistake in nesting of the nodes\n    1. There was a mistake in creating the nodes\n    1. Nodes are missing\n    1. Nodes have invalid vocabulary\n        * The database schema wants something a different controlled vocabulary than what is provided\n    1. There was an error with the way the JSON was created within the Python SDK\n        * The format of the JSON the CRIPT Python SDK created was invalid\n    1. There is something wrong with the database schema\n\n    ## Troubleshooting\n    The easiest way to troubleshoot this is to examine the JSON that the SDK created via printing out the\n    [Project](../../nodes/primary_nodes/project) node's JSON and checking the place that the schema validation\n    says failed\n\n    ### Example\n    ```python\n    print(my_project.json)\n    ```\n    \"\"\"\n\n    node_type: str = \"\"\n    json_schema_validation_error: str = \"\"\n\n    def __init__(self, node_type: str, json_schema_validation_error: str) -&gt; None:\n        self.json_schema_validation_error: str = json_schema_validation_error\n        self.node_type = node_type\n\n    def __str__(self) -&gt; str:\n        error_message: str = f\"JSON database schema validation for node {self.node_type} failed.\"\n        error_message += f\"Error: {self.json_schema_validation_error}\"\n\n        return error_message\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedComputationWarning","title":"<code>CRIPTOrphanedComputationWarning</code>","text":"<p>             Bases: <code>CRIPTOrphanedExperimentWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedComputationWarning--definition","title":"Definition","text":"<p>CRIPTOrphanedExperimentWarning, but specific for orphaned Computation node that should be listed in one of the experiments.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedComputationWarning--troubleshooting","title":"Troubleshooting","text":"<p>Handle this error by adding the orphaned node into one the parent project's experiments <code>Computation</code> attribute.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedComputationWarning(CRIPTOrphanedExperimentWarning):\n    \"\"\"\n    ## Definition\n    CRIPTOrphanedExperimentWarning, but specific for orphaned Computation node that should be\n    listed in one of the experiments.\n\n    ## Troubleshooting\n    Handle this error by adding the orphaned node into one the parent project's experiments\n    `Computation` attribute.\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        super().__init__(orphaned_node)\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedComputationalProcessWarning","title":"<code>CRIPTOrphanedComputationalProcessWarning</code>","text":"<p>             Bases: <code>CRIPTOrphanedExperimentWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedComputationalProcessWarning--definition","title":"Definition","text":"<p>CRIPTOrphanedExperimentWarning, but specific for orphaned ComputationalProcess node that should be listed in one of the experiments.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedComputationalProcessWarning--troubleshooting","title":"Troubleshooting","text":"<p>Handle this error by adding the orphaned node into one the parent project's experiments <code>ComputationalProcess</code> attribute.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedComputationalProcessWarning(CRIPTOrphanedExperimentWarning):\n    \"\"\"\n    ## Definition\n    CRIPTOrphanedExperimentWarning, but specific for orphaned ComputationalProcess\n    node that should be listed in one of the experiments.\n\n    ## Troubleshooting\n    Handle this error by adding the orphaned node into one the parent project's experiments\n    `ComputationalProcess` attribute.\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        super().__init__(orphaned_node)\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedDataWarning","title":"<code>CRIPTOrphanedDataWarning</code>","text":"<p>             Bases: <code>CRIPTOrphanedExperimentWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedDataWarning--definition","title":"Definition","text":"<p>CRIPTOrphanedExperimentWarning, but specific for orphaned Data node that should be listed in one of the experiments.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedDataWarning--troubleshooting","title":"Troubleshooting","text":"<p>Handle this error by adding the orphaned node into one the parent project's experiments <code>data</code> attribute.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedDataWarning(CRIPTOrphanedExperimentWarning):\n    \"\"\"\n    ## Definition\n    CRIPTOrphanedExperimentWarning, but specific for orphaned Data node that should be listed in one of the experiments.\n\n    ## Troubleshooting\n    Handle this error by adding the orphaned node into one the parent project's experiments `data` attribute.\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        super().__init__(orphaned_node)\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedExperimentWarning","title":"<code>CRIPTOrphanedExperimentWarning</code>","text":"<p>             Bases: <code>CRIPTOrphanedNodesWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedExperimentWarning--definition","title":"Definition","text":"<p>CRIPTOrphanedNodesWarning, but specific for orphaned nodes that should be listed in one of the experiments.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedExperimentWarning--troubleshooting","title":"Troubleshooting","text":"<p>Handle this error by adding the orphaned node into one the parent project's experiments.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedExperimentWarning(CRIPTOrphanedNodesWarning):\n    \"\"\"\n    ## Definition\n    CRIPTOrphanedNodesWarning, but specific for orphaned nodes that should be listed in one of the experiments.\n\n    ## Troubleshooting\n    Handle this error by adding the orphaned node into one the parent project's experiments.\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        super().__init__(orphaned_node)\n\n    def __str__(self) -&gt; str:\n        node_name = self.orphaned_node.node_type.lower()\n        ret_string = f\"While validating a project graph, an orphaned {node_name} node was found. \"\n        ret_string += f\"This {node_name} node is present in the graph, but not listed in any of the experiments of the  project. \"\n        ret_string += f\"Please add the node like: `your_experiment.{node_name} += [orphaned_{node_name}]`. \"\n        ret_string += f\"The orphaned {node_name} was {self.orphaned_node}.\"\n        return ret_string\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedMaterialWarning","title":"<code>CRIPTOrphanedMaterialWarning</code>","text":"<p>             Bases: <code>CRIPTOrphanedNodesWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedMaterialWarning--definition","title":"Definition","text":"<p>CRIPTOrphanedNodesWarning, but specific for orphaned materials.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedMaterialWarning--troubleshooting","title":"Troubleshooting","text":"<p>Handle this error by adding the orphaned materials into the parent project or its inventories.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedMaterialWarning(CRIPTOrphanedNodesWarning):\n    \"\"\"\n    ## Definition\n    CRIPTOrphanedNodesWarning, but specific for orphaned materials.\n\n    ## Troubleshooting\n    Handle this error by adding the orphaned materials into the parent project or its inventories.\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        super().__init__(orphaned_node)\n\n    def __str__(self):\n        ret_string = \"While validating a project graph, an orphaned material node was found. \"\n        ret_string += \"This material is present in the graph, but not listed in the project. \"\n        ret_string += \"Please add the node like: `my_project.material += [orphaned_material]`. \"\n        ret_string += f\"The orphaned material was {self.orphaned_node}.\"\n        return ret_string\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedNodesWarning","title":"<code>CRIPTOrphanedNodesWarning</code>","text":"<p>             Bases: <code>CRIPTWarning</code>, <code>ABC</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedNodesWarning--definition","title":"Definition","text":"<p>This error is raised when a child node is not attached to the appropriate parent node. For example, all material nodes used within a project must belong to the project inventory or are explicitly listed as material of that project. If there is a material node that is used within a project but not a part of the inventory and the validation code finds it then it raises an <code>CRIPTOrphanedNodeWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedNodesWarning--troubleshooting","title":"Troubleshooting","text":"<p>Fixing this is simple and easy, just take the node that CRIPT Python SDK found a problem with and associate it with the appropriate parent via</p> <pre><code>my_project.material += my_orphaned_material_node\n</code></pre> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedNodesWarning(CRIPTWarning, ABC):\n    \"\"\"\n    ## Definition\n    This error is raised when a child node is not attached to the\n    appropriate parent node. For example, all material nodes used\n    within a project must belong to the project inventory or are explicitly listed as material of that project.\n    If there is a material node that is used within a project but not a part of the\n    inventory and the validation code finds it then it raises an `CRIPTOrphanedNodeWarning`\n\n    ## Troubleshooting\n    Fixing this is simple and easy, just take the node that CRIPT Python SDK\n    found a problem with and associate it with the appropriate parent via\n\n    ```\n    my_project.material += my_orphaned_material_node\n    ```\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        self.orphaned_node = orphaned_node\n\n    @abstractmethod\n    def __str__(self):\n        pass\n</code></pre>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedProcessWarning","title":"<code>CRIPTOrphanedProcessWarning</code>","text":"<p>             Bases: <code>CRIPTOrphanedExperimentWarning</code></p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedProcessWarning--definition","title":"Definition","text":"<p>CRIPTOrphanedExperimentWarning, but specific for orphaned Process node that should be listed in one of the experiments.</p>"},{"location":"exceptions/node_exceptions/#cript.nodes.exceptions.CRIPTOrphanedProcessWarning--troubleshooting","title":"Troubleshooting","text":"<p>Handle this error by adding the orphaned node into one the parent project's experiments <code>process</code> attribute.</p> Source code in <code>src/cript/nodes/exceptions.py</code> <pre><code>class CRIPTOrphanedProcessWarning(CRIPTOrphanedExperimentWarning):\n    \"\"\"\n    ## Definition\n    CRIPTOrphanedExperimentWarning, but specific for orphaned Process node that should be\n    listed in one of the experiments.\n\n    ## Troubleshooting\n    Handle this error by adding the orphaned node into one the parent project's experiments\n    `process` attribute.\n    \"\"\"\n\n    def __init__(self, orphaned_node):\n        super().__init__(orphaned_node)\n</code></pre>"},{"location":"nodes/uuid_base/","title":"UUIDBase","text":""},{"location":"nodes/uuid_base/#cript.nodes.uuid_base.UUIDBaseNode","title":"<code>UUIDBaseNode</code>","text":"<p>             Bases: <code>BaseNode</code>, <code>ABC</code></p> <p>Base node that handles UUIDs and URLs.</p> Source code in <code>src/cript/nodes/uuid_base.py</code> <pre><code>class UUIDBaseNode(BaseNode, ABC):\n    \"\"\"\n    Base node that handles UUIDs and URLs.\n    \"\"\"\n\n    # Class attribute that caches all nodes created\n    _uuid_cache: Dict = {}\n\n    @dataclass(frozen=True)\n    class JsonAttributes(BaseNode.JsonAttributes):\n        \"\"\"\n        All shared attributes between all Primary nodes and set to their default values\n        \"\"\"\n\n        uuid: str = field(default_factory=lambda: str(uuid.uuid4()))\n        updated_by: Any = None\n        created_by: Any = None\n        created_at: str = \"\"\n        updated_at: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    def __new__(cls, *args, **kwargs):\n        uuid: Optional[str] = str(kwargs.get(\"uuid\"))\n        if uuid and uuid in UUIDBaseNode._uuid_cache:\n            existing_node_to_overwrite = UUIDBaseNode._uuid_cache[uuid]\n            if type(existing_node_to_overwrite) is not cls:\n                raise CRIPTUUIDException(uuid, type(existing_node_to_overwrite), cls)\n            return existing_node_to_overwrite\n        new_uuid_node = super().__new__(cls)\n        return new_uuid_node\n\n    def __init__(self, **kwargs):\n        from cript.nodes.util.core import get_uuid_from_uid\n\n        # initialize Base class with node\n        super().__init__(**kwargs)\n        # Respect uuid if passed as argument, otherwise construct uuid from uid\n        uuid: str = kwargs.get(\"uuid\", get_uuid_from_uid(self.uid))\n        # replace name and notes within PrimaryBase\n        self._json_attrs = replace(self._json_attrs, uuid=uuid)\n        UUIDBaseNode._uuid_cache[uuid] = self\n\n    @property\n    @beartype\n    def uuid(self) -&gt; str:\n        if not isinstance(self._json_attrs.uuid, str):\n            # Some JSON decoding automatically converted this to UUID objects, which we don't want\n            self._json_attrs = replace(self._json_attrs, uuid=str(self._json_attrs.uuid))\n\n        return self._json_attrs.uuid\n\n    @property\n    def url(self):\n        from cript.api.api import _get_global_cached_api\n\n        api = _get_global_cached_api()\n        return f\"{api.host}/{api.api_prefix}/{api.api_version}/{self.uuid}\"\n\n    @property\n    def updated_by(self):\n        return self._json_attrs.updated_by\n\n    @property\n    def created_by(self):\n        return self._json_attrs.created_by\n\n    @property\n    def updated_at(self):\n        return self._json_attrs.updated_at\n\n    @property\n    def created_at(self):\n        return self._json_attrs.created_at\n\n    def __iter__(self) -&gt; NodeIterator:\n        \"\"\"Enables DFS iteration over all children.\"\"\"\n        return NodeIterator(self)\n</code></pre>"},{"location":"nodes/uuid_base/#cript.nodes.uuid_base.UUIDBaseNode.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>All shared attributes between all Primary nodes and set to their default values</p> Source code in <code>src/cript/nodes/uuid_base.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(BaseNode.JsonAttributes):\n    \"\"\"\n    All shared attributes between all Primary nodes and set to their default values\n    \"\"\"\n\n    uuid: str = field(default_factory=lambda: str(uuid.uuid4()))\n    updated_by: Any = None\n    created_by: Any = None\n    created_at: str = \"\"\n    updated_at: str = \"\"\n</code></pre>"},{"location":"nodes/uuid_base/#cript.nodes.uuid_base.UUIDBaseNode.__iter__","title":"<code>__iter__()</code>","text":"<p>Enables DFS iteration over all children.</p> Source code in <code>src/cript/nodes/uuid_base.py</code> <pre><code>def __iter__(self) -&gt; NodeIterator:\n    \"\"\"Enables DFS iteration over all children.\"\"\"\n    return NodeIterator(self)\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/","title":"BaseNode","text":"<p>             Bases: <code>ABC</code></p> <p>This abstract class is the base of all CRIPT nodes. It offers access to a json attribute class, which reflects the data model JSON attributes. Also, some basic shared functionality is provided by this base class.</p> Source code in <code>src/cript/nodes/core.py</code> <pre><code>class BaseNode(ABC):\n    \"\"\"\n    This abstract class is the base of all CRIPT nodes.\n    It offers access to a json attribute class,\n    which reflects the data model JSON attributes.\n    Also, some basic shared functionality is provided by this base class.\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes:\n        node: List[str] = dataclasses.field(default_factory=list)\n        uid: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @classproperty\n    def node_type(self):\n        name = type(self).__name__\n        if name == \"ABCMeta\":\n            name = self.__name__\n        return name\n\n    @classproperty\n    def node_type_snake_case(self):\n        camel_case = self.node_type\n        # Regex to convert camel case to snake case.\n        snake_case = re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", camel_case).lower()\n        return snake_case\n\n    # Prevent new attributes being set.\n    # This might just be temporary, but for now, I don't want to accidentally add new attributes, when I mean to modify one.\n    def __setattr__(self, key, value):\n        if not hasattr(self, key):\n            raise CRIPTAttributeModificationError(self.node_type, key, value)\n        super().__setattr__(key, value)\n\n    def __init__(self, **kwargs):\n        for kwarg in kwargs:\n            if kwarg not in tolerated_extra_json:\n                if kwarg.endswith(\"_count\"):\n                    try:\n                        possible_array = getattr(self._json_attrs.kwarg[: -len(\"_count\")])\n                        if not isinstance(possible_array, list):\n                            raise CRIPTExtraJsonAttributes(self.node_type, kwarg)\n                    except AttributeError:\n                        raise CRIPTExtraJsonAttributes(self.node_type, kwarg)\n                else:\n                    try:\n                        getattr(self._json_attrs, kwarg)\n                    except AttributeError:\n                        raise CRIPTExtraJsonAttributes(self.node_type, kwarg)\n\n        uid = get_new_uid()\n        self._json_attrs = replace(self._json_attrs, node=[self.node_type], uid=uid)\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of a node data model attributes.\n\n        Returns\n        -------\n        str\n            A string representation of the node.\n        \"\"\"\n        return str(self._json_attrs)\n\n    @property\n    def uid(self):\n        return self._json_attrs.uid\n\n    @property\n    def node(self):\n        return self._json_attrs.node\n\n    def _update_json_attrs_if_valid(self, new_json_attr: JsonAttributes) -&gt; None:\n        \"\"\"\n        tries to update the node if valid and then checks if it is valid or not\n\n        1. updates the node with the new information\n        1. run db schema validation on it\n            1. if db schema validation succeeds then update and continue\n            1. else: raise an error and tell the user what went wrong\n\n        Parameters\n        ----------\n        new_json_attr\n\n        Raises\n        ------\n        Exception\n\n        Returns\n        -------\n        None\n        \"\"\"\n        old_json_attrs = self._json_attrs\n        self._json_attrs = new_json_attr\n\n        try:\n            self.validate()\n        except Exception as exc:\n            self._json_attrs = old_json_attrs\n            raise exc\n\n    def validate(self, api=None, is_patch: bool = False, force_validation: bool = False) -&gt; None:\n        \"\"\"\n        Validate this node (and all its children) against the schema provided by the data bank.\n\n        Raises:\n        -------\n        Exception with more error information.\n        \"\"\"\n        from cript.api.api import _get_global_cached_api\n\n        if api is None:\n            api = _get_global_cached_api()\n        api.schema.is_node_schema_valid(self.get_json(is_patch=is_patch).json, is_patch=is_patch, force_validation=force_validation)\n\n    @classmethod\n    def _from_json(cls, json_dict: dict):\n        # TODO find a way to handle uuid nodes only\n\n        # Child nodes can inherit and overwrite this.\n        # They should call super()._from_json first, and modified the returned object after if necessary\n        # We create manually a dict that contains all elements from the send dict.\n        # That eliminates additional fields and doesn't require asdict.\n        arguments = {}\n        default_dataclass = cls.JsonAttributes()\n        for field in json_dict:\n            try:\n                getattr(default_dataclass, field)\n            except AttributeError:\n                pass\n            else:\n                arguments[field] = json_dict[field]\n        try:  # TODO remove this hack to work with compatible model versions\n            del arguments[\"model_version\"]\n        except KeyError:\n            pass\n\n        # add omitted fields from default (necessary if they are required)\n        for field_name in [field.name for field in dataclasses.fields(default_dataclass)]:\n            if field_name not in arguments:\n                arguments[field_name] = getattr(default_dataclass, field_name)\n\n        try:\n            node = cls(**arguments)\n        # TODO we should not catch all exceptions if we are handling them, and instead let it fail\n        #  to create a good error message that points to the correct place that it failed to make debugging easier\n        except Exception as exc:\n            print(cls, arguments)\n            raise exc\n\n        attrs = cls.JsonAttributes(**arguments)\n\n        # Handle default attributes manually.\n        for field in attrs.__dict__:\n            # Conserve newly assigned uid if uid is default (empty)\n            if getattr(attrs, field) == getattr(default_dataclass, field):\n                attrs = replace(attrs, **{str(field): getattr(node, field)})\n\n        try:  # TODO remove this temporary solution\n            if not attrs.uid.startswith(\"_:\"):\n                attrs = replace(attrs, uid=\"_:\" + attrs.uid)\n        except AttributeError:\n            pass\n\n        # But here we force even usually unwritable fields to be set.\n        node._update_json_attrs_if_valid(attrs)\n\n        return node\n\n    def __deepcopy__(self, memo):\n        from cript.nodes.util.core import get_uuid_from_uid\n\n        # Ideally I would call `asdict`, but that is not allowed inside a deepcopy chain.\n        # Making a manual transform into a dictionary here.\n        arguments = {}\n        for field in self.JsonAttributes().__dataclass_fields__:\n            arguments[field] = copy.deepcopy(getattr(self._json_attrs, field), memo)\n        # TODO URL handling\n\n        # Since we excluded 'uuid' from arguments,\n        # a new uid will prompt the creation of a new matching uuid.\n        uid = get_new_uid()\n        arguments[\"uid\"] = uid\n        if \"uuid\" in arguments:\n            arguments[\"uuid\"] = get_uuid_from_uid(uid)\n\n        # Create node and init constructor attributes\n        node = self.__class__(**arguments)\n        # Update none constructor writable attributes.\n        node._update_json_attrs_if_valid(self.JsonAttributes(**arguments))\n        return node\n\n    @property\n    def json(self):\n        \"\"\"\n        Property to obtain a simple json string.\n        Calls `get_json` with default arguments.\n        \"\"\"\n        # We cannot validate in `get_json` because we call it inside `validate`.\n        # But most uses are probably the property, so we can validate the node here.\n        json_string: str = self.get_json().json\n\n        from cript.api.api import _get_global_cached_api\n\n        api = _get_global_cached_api()\n        api.schema.is_node_schema_valid(json_string, force_validation=True)\n\n        return json_string\n\n    def get_expanded_json(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generates a long-form JSON representation of the current node and its hierarchy.\n\n        The long-form JSON includes complete details of the node, eliminating the need for\n         references to UUIDs to nodes stored in the CRIPT database. This comprehensive representation\n         is useful for offline storage of CRIPT nodes, transferring nodes between different CRIPT instances,\n         or for backup purposes.\n\n        The generated long-form JSON can be reloaded into the SDK using\n        [`cript.load_nodes_from_json()`](../../../utility_functions/#cript.nodes.util.load_nodes_from_json),\n        ensuring consistency and completeness of the node data.\n        However, it's important to note that this long-form JSON might not comply directly with the JSON schema\n        required for POST or PATCH requests to the CRIPT API.\n\n        Optional keyword arguments (`kwargs`) are supported and are passed directly to `json.dumps()`.\n        These arguments allow customization of the JSON output, such as formatting for readability\n        or pretty printing.\n\n        Parameters\n        ----------\n        **kwargs : dict, optional\n            Additional keyword arguments for `json.dumps()` to customize the JSON output, such as `indent`\n            for pretty-printing.\n\n        Returns\n        -------\n        str\n            A comprehensive JSON string representing the current node and its entire hierarchy in long-form.\n\n        Notes\n        -----\n        The `get_expanded_json()` method differs from the standard [`json`](./#cript.nodes.core.BaseNode.json)\n        property or method, which might provide a more condensed version of the node's data.\n\n        &gt; For more information on condensed JSON and deserialization, please feel free to reference our discussion\n        &gt; on [deserializing Python nodes to JSON](https://github.com/C-Accel-CRIPT/Python-SDK/discussions/177)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; # ============= Create all needed nodes =============\n        &gt;&gt;&gt; my_project = cript.Project(name=f\"my_Project\")\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection\")\n        &gt;&gt;&gt; my_material_1 = cript.Material(\n        ...     name=\"my material 1\", bigsmiles = \"my material 1 bigsmiles\"\n        ... )\n        &gt;&gt;&gt; my_material_2 = cript.Material(\n        ...     name=\"my material 2\", bigsmiles = \"my material 2 bigsmiles\"\n        ... )\n        &gt;&gt;&gt; my_inventory = cript.Inventory(\n        ...     name=\"my inventory\", material=[my_material_1, my_material_2]\n        ... )\n        &gt;&gt;&gt; #  ============= Assemble nodes =============\n        &gt;&gt;&gt; my_project.collection = [my_collection]\n        &gt;&gt;&gt; my_project.collection[0].inventory = [my_inventory]\n        &gt;&gt;&gt; #  ============= Get long form JSON =============\n        &gt;&gt;&gt; long_form_json = my_project.get_expanded_json(indent=4)\n\n        ???+ info \"Condensed JSON VS Expanded JSON\"\n            # Default Condensed JSON\n            &gt; This is the JSON when `my_project.json` is called\n\n            ```json linenums=\"1\"\n            {\n               \"node\":[\n                  \"Project\"\n               ],\n               \"uid\":\"_:d0d1b3c9-d552-4d4f-afd2-76f01538b87a\",\n               \"uuid\":\"d0d1b3c9-d552-4d4f-afd2-76f01538b87a\",\n               \"name\":\"my_Project\",\n               \"collection\":[\n                  {\n                     \"node\":[\n                        \"Collection\"\n                     ],\n                     \"uid\":\"_:07765ac8-862a-459e-9d99-d0439d6a6a09\",\n                     \"uuid\":\"07765ac8-862a-459e-9d99-d0439d6a6a09\",\n                     \"name\":\"my collection\",\n                     \"inventory\":[\n                        {\n                           \"node\":[\n                              \"Inventory\"\n                           ],\n                           \"uid\":\"_:4cf2bbee-3dc0-400b-8269-709f99d89d9f\",\n                           \"uuid\":\"4cf2bbee-3dc0-400b-8269-709f99d89d9f\",\n                           \"name\":\"my inventory\",\n                           \"material\":[\n                              {\n                                 \"uuid\":\"0cf14572-4da2-43f2-8cb9-e8374086368e\"\n                              },\n                              {\n                                 \"uuid\":\"6302a8b0-4265-4a3a-a40f-bbcbb7293046\"\n                              }\n                           ]\n                        }\n                     ]\n                  }\n               ]\n            }\n            ```\n\n            # Expanded JSON\n            &gt; This is what is created when `my_project.get_expanded_json()`\n\n            ```json linenums=\"1\"\n            {\n               \"node\":[\n                  \"Project\"\n               ],\n               \"uid\":\"_:afe4bb2f-fa75-4736-b692-418a5143e6f5\",\n               \"uuid\":\"afe4bb2f-fa75-4736-b692-418a5143e6f5\",\n               \"name\":\"my_Project\",\n               \"collection\":[\n                  {\n                     \"node\":[\n                        \"Collection\"\n                     ],\n                     \"uid\":\"_:8b5c8125-c956-472a-9d07-8cb7b402b101\",\n                     \"uuid\":\"8b5c8125-c956-472a-9d07-8cb7b402b101\",\n                     \"name\":\"my collection\",\n                     \"inventory\":[\n                        {\n                           \"node\":[\n                              \"Inventory\"\n                           ],\n                           \"uid\":\"_:1bd3c966-cb35-494d-85cd-3515cde570f3\",\n                           \"uuid\":\"1bd3c966-cb35-494d-85cd-3515cde570f3\",\n                           \"name\":\"my inventory\",\n                           \"material\":[\n                              {\n                                 \"node\":[\n                                    \"Material\"\n                                 ],\n                                 \"uid\":\"_:07bc3e4f-757f-4ac7-ae8a-7a0c68272531\",\n                                 \"uuid\":\"07bc3e4f-757f-4ac7-ae8a-7a0c68272531\",\n                                 \"name\":\"my material 1\",\n                                 \"bigsmiles\":\"my material 1 bigsmiles\"\n                              },\n                              {\n                                 \"node\":[\n                                    \"Material\"\n                                 ],\n                                 \"uid\":\"_:64565687-5707-4d67-860f-5ee4a057a45f\",\n                                 \"uuid\":\"64565687-5707-4d67-860f-5ee4a057a45f\",\n                                 \"name\":\"my material 2\",\n                                 \"bigsmiles\":\"my material 2 bigsmiles\"\n                              }\n                           ]\n                        }\n                     ]\n                  }\n               ]\n            }\n            ```\n        \"\"\"\n        return self.get_json(handled_ids=None, known_uuid=None, suppress_attributes=None, is_patch=False, condense_to_uuid={}, **kwargs).json\n\n    def get_json(\n        self,\n        handled_ids: Optional[Set[str]] = None,\n        known_uuid: Optional[Set[str]] = None,\n        suppress_attributes: Optional[Dict[str, Set[str]]] = None,\n        is_patch: bool = False,\n        condense_to_uuid: Dict[str, Set[str]] = {\n            \"Material\": {\"parent_material\", \"component\"},\n            \"Experiment\": {\"data\"},\n            \"Inventory\": {\"material\"},\n            \"Ingredient\": {\"material\"},\n            \"Property\": {\"component\"},\n            \"ComputationProcess\": {\"material\"},\n            \"Data\": {\"material\"},\n            \"Process\": {\"product\", \"waste\"},\n            \"Project\": {\"member\", \"admin\"},\n            \"Collection\": {\"member\", \"admin\"},\n        },\n        **kwargs\n    ):\n        \"\"\"\n        User facing access to get the JSON of a node.\n        Opposed to the also available property json this functions allows further control.\n        Additionally, this function does not call `self.validate()` but the property `json` does.\n        We also accept `kwargs`, that are passed on to the JSON decoding via `json.dumps()` this can be used for example to prettify the output.\n\n\n        Returns named tuple with json and handled ids as result.\n        \"\"\"\n\n        @dataclass(frozen=True)\n        class ReturnTuple:\n            json: str\n            json_dict: dict\n            handled_ids: set\n\n        # Do not check for circular references, since we handle them manually\n        kwargs[\"check_circular\"] = kwargs.get(\"check_circular\", False)\n\n        # Delayed import to avoid circular imports\n        from cript.nodes.util import NodeEncoder\n\n        if handled_ids is None:\n            handled_ids = set()\n        previous_handled_nodes = copy.deepcopy(NodeEncoder.handled_ids)\n        NodeEncoder.handled_ids = handled_ids\n\n        # Similar to uid, we handle pre-saved known uuid such that they are UUID edges only\n        if known_uuid is None:\n            known_uuid = set()\n        previous_known_uuid = copy.deepcopy(NodeEncoder.known_uuid)\n        NodeEncoder.known_uuid = known_uuid\n        previous_suppress_attributes = copy.deepcopy(NodeEncoder.suppress_attributes)\n        NodeEncoder.suppress_attributes = suppress_attributes\n        previous_condense_to_uuid = copy.deepcopy(NodeEncoder.condense_to_uuid)\n        NodeEncoder.condense_to_uuid = condense_to_uuid\n\n        try:\n            tmp_json = json.dumps(self, cls=NodeEncoder, **kwargs)\n            tmp_dict = json.loads(tmp_json)\n            if is_patch:\n                del tmp_dict[\"uuid\"]  # patches do not allow UUID is the parent most node\n\n            return ReturnTuple(json.dumps(tmp_dict, **kwargs), tmp_dict, NodeEncoder.handled_ids)\n        except Exception as exc:\n            # TODO this handling that doesn't tell the user what happened and how they can fix it\n            #   this just tells the user that something is wrong\n            #   this should be improved to tell the user what went wrong and where\n            raise CRIPTJsonSerializationError(str(type(self)), str(self._json_attrs)) from exc\n        finally:\n            NodeEncoder.handled_ids = previous_handled_nodes\n            NodeEncoder.known_uuid = previous_known_uuid\n            NodeEncoder.suppress_attributes = previous_suppress_attributes\n            NodeEncoder.condense_to_uuid = previous_condense_to_uuid\n\n    def find_children(self, search_attr: dict, search_depth: int = -1, handled_nodes: Optional[List] = None) -&gt; List:\n        \"\"\"\n        Finds all the children in a given tree of nodes (specified by its root),\n        that match the criteria of search_attr.\n        If a node is present multiple times in the graph, it is only once in the search results.\n\n        Parameters\n        ----------\n        search_attr: dict\n            What you are searching for within the JSON.\n            Dictionary that specifies which JSON attributes have to be present in a given node.\n            If an attribute is a list, it is sufficient if the specified attributes are in the list,\n            if others are present too, that does not exclude the child.\n        search_depth: int default -1\n            Max depth of the search into the tree. Helpful if circles are expected. -1 specifies no limit\n        handled_nodes: Optional[List] default None\n            A list used to track nodes that have already been processed during the search.\n            This parameter is primarily used internally to prevent infinite loops in cases\n            where the node graph contains cycles. When a node is processed, it is added to this list.\n            If a node is encountered that is already in this list, it is skipped to avoid redundant processing.\n            By default, this parameter is `None`, which means that the search starts with an empty list of handled nodes.\n            In most use cases, users do not need to provide this parameter, as it is managed internally by the\n            method.\n\n        Returns\n        -------\n        List\n            list of all nodes that match the criteria found within the graph\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; # ============= Create nodes =============\n        &gt;&gt;&gt; my_project = cript.Project(name=f\"my_Project\")\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection\")\n        &gt;&gt;&gt; my_material_1 = cript.Material(\n        ...     name=\"my material 1\", bigsmiles = \"my material 1 bigsmiles\"\n        ... )\n        &gt;&gt;&gt; my_material_2 = cript.Material(\n        ...     name=\"my material 2\", bigsmiles = \"my material 2 bigsmiles\"\n        ... )\n        &gt;&gt;&gt; my_inventory = cript.Inventory(\n        ...     name=\"my inventory\", material=[my_material_1, my_material_2]\n        ... )\n        &gt;&gt;&gt; #  ============= Assemble nodes =============\n        &gt;&gt;&gt; my_project.collection = [my_collection]\n        &gt;&gt;&gt; my_project.collection[0].inventory = [my_inventory]\n        &gt;&gt;&gt; #  ============= Get list of all material nodes in project =============\n        &gt;&gt;&gt; all_materials_in_project: list = my_project.find_children({\"node\": [\"Material\"]})\n\n        Notes\n        -----\n        The `find_children` method is versatile and can be used to search for nodes based on various criteria.\n        Here are some examples to illustrate its usage:\n\n        * Searching for Specific Node Types:\n          `search_attr = {\"node\": [\"Parameter\"]}` will find all nodes of type \"Parameter\".\n        * Searching with Additional Attributes:\n          `search_attr = {\"node\": [\"Algorithm\"], \"parameter\": {\"name\" : \"update_frequency\"}}`\n          will locate \"Algorithm\" nodes containing a parameter named \"update_frequency\".\n          Note: For list attributes, a match occurs if the specified attribute is part of the list.\n            * Alternate notation: `{\"node\": [\"Algorithm\"], \"parameter\": [{\"name\" : \"update_frequency\"}]}`.\n          In this case, nodes with additional parameters are also included.\n        * Combining Multiple Search Criteria:\n          ```python\n          search_attr = {\n              \"node\": [\"Algorithm\"],\n              \"parameter\": [{\"name\": \"update_frequency\"}, {\"name\": \"cutoff_distance\"}]\n          }\n          ```\n          This finds all \"Algorithm\" nodes with both \"update_frequency\" and \"cutoff_distance\" parameters.\n\n        The `search_depth` parameter controls how deep the search goes into the node tree.\n        A value of `-1` indicates no depth limit.\n        The method effectively handles cycles in the graph by ensuring each node is processed only once.\n        This makes the function suitable for complex node structures.\n        \"\"\"\n\n        def is_attr_present(node: BaseNode, key, value):\n            \"\"\"\n            Helper function that checks if an attribute is present in a node.\n            \"\"\"\n            try:\n                attr_key = getattr(node._json_attrs, key)\n            except AttributeError:\n                return False\n\n            # To save code paths, I convert non-lists into lists with one element.\n            if not isinstance(attr_key, list):\n                attr_key = [attr_key]\n            if not isinstance(value, list):\n                value = [value]\n\n            # The definition of search is, that all values in a list have to be present.\n            # To fulfill this AND condition, we count the number of occurrences of that value condition\n            number_values_found = 0\n            # Runtime contribution: O(m), where is is the number of search keys\n            for v in value:\n                # Test for simple values (not-nodes)\n                if v in attr_key:\n                    number_values_found += 1\n\n                # Test if value is present in one of the specified attributes (OR condition)\n                # Runtime contribution: O(m), where m is the number of nodes in the attribute list.\n                for attr in attr_key:\n                    # if the attribute is a node and the search value is a dictionary,\n                    # we can verify that this condition is met if it finds the node itself with `find_children`.\n                    if isinstance(attr, BaseNode) and isinstance(v, dict):\n                        # Since we only want to test the node itself and not any of its children, we set recursion to 0.\n                        # Runtime contribution: recursive call, with depth search depth of the search dictionary O(h)\n                        if len(attr.find_children(v, 0)) &gt; 0:\n                            number_values_found += 1\n                            # Since this an OR condition, we abort early.\n                            # This also doesn't inflate the number_values_count,\n                            # since every OR condition should only add a max of 1.\n                            break\n            # Check if the AND condition of the values is met\n            return number_values_found == len(value)\n\n        if handled_nodes is None:\n            handled_nodes = []\n\n        found_children = []\n\n        node_iterator = NodeIterator(self, search_depth)\n        for node in node_iterator:\n            found_attr = 0\n            for key, value in search_attr.items():\n                if is_attr_present(node, key, value):\n                    found_attr += 1\n            # If exactly all attributes are found, it matches the search criterion\n            if found_attr == len(search_attr):\n                found_children += [node]\n\n        return found_children\n\n    def remove_child(self, child) -&gt; bool:\n        \"\"\"\n        This safely removes the first found child node from the parent.\n        This requires exact node as we test with `is` instead of `==`.\n\n        returns True if child was found and deleted, False if child not found,\n        raise DB schema exception if deletion violates DB schema.\n        \"\"\"\n\n        # If we delete a child, we have to replace that with a default value.\n        # The easiest way to access this default value is to get it from the the default JsonAttribute of that class\n        default_json_attrs = self.JsonAttributes()\n        new_attrs = self._json_attrs\n        for field in self._json_attrs.__dataclass_fields__:\n            value = getattr(self._json_attrs, field)\n            if value is child:\n                new_attrs = replace(new_attrs, **{field: getattr(default_json_attrs, field)})\n                # We only want to delete the first found child\n            elif not isinstance(value, str):  # Strings are iterable, but we don't want them\n                try:  # Try if we are facing a list at the moment\n                    new_attr_list = [element for element in value]\n                except TypeError:\n                    pass  # It is OK if this field is not a list\n                else:\n                    found_child = False\n                    for i, list_value in enumerate(value):\n                        if list_value is child:\n                            found_child = True\n                            del new_attr_list[i]\n                            # Only delete first child.\n                            # Important to break loop here, since value and new_attr_list are not identical any more.\n                    if found_child:\n                        new_attrs = replace(new_attrs, **{field: new_attr_list})  # type: ignore\n                        # Again only first found place is removed\n                        break\n        # Let's see if we found the child aka the new_attrs are different than the old ones\n        if new_attrs is self._json_attrs:\n            return False\n        self._update_json_attrs_if_valid(new_attrs)\n        return True\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.json","title":"<code>json</code>  <code>property</code>","text":"<p>Property to obtain a simple json string. Calls <code>get_json</code> with default arguments.</p>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of a node data model attributes.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the node.</p> Source code in <code>src/cript/nodes/core.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of a node data model attributes.\n\n    Returns\n    -------\n    str\n        A string representation of the node.\n    \"\"\"\n    return str(self._json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.find_children","title":"<code>find_children(search_attr, search_depth=-1, handled_nodes=None)</code>","text":"<p>Finds all the children in a given tree of nodes (specified by its root), that match the criteria of search_attr. If a node is present multiple times in the graph, it is only once in the search results.</p> <p>Parameters:</p> Name Type Description Default <code>search_attr</code> <code>dict</code> <p>What you are searching for within the JSON. Dictionary that specifies which JSON attributes have to be present in a given node. If an attribute is a list, it is sufficient if the specified attributes are in the list, if others are present too, that does not exclude the child.</p> required <code>search_depth</code> <code>int</code> <p>Max depth of the search into the tree. Helpful if circles are expected. -1 specifies no limit</p> <code>-1</code> <code>handled_nodes</code> <code>Optional[List]</code> <p>A list used to track nodes that have already been processed during the search. This parameter is primarily used internally to prevent infinite loops in cases where the node graph contains cycles. When a node is processed, it is added to this list. If a node is encountered that is already in this list, it is skipped to avoid redundant processing. By default, this parameter is <code>None</code>, which means that the search starts with an empty list of handled nodes. In most use cases, users do not need to provide this parameter, as it is managed internally by the method.</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>list of all nodes that match the criteria found within the graph</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; # ============= Create nodes =============\n&gt;&gt;&gt; my_project = cript.Project(name=f\"my_Project\")\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection\")\n&gt;&gt;&gt; my_material_1 = cript.Material(\n...     name=\"my material 1\", bigsmiles = \"my material 1 bigsmiles\"\n... )\n&gt;&gt;&gt; my_material_2 = cript.Material(\n...     name=\"my material 2\", bigsmiles = \"my material 2 bigsmiles\"\n... )\n&gt;&gt;&gt; my_inventory = cript.Inventory(\n...     name=\"my inventory\", material=[my_material_1, my_material_2]\n... )\n&gt;&gt;&gt; #  ============= Assemble nodes =============\n&gt;&gt;&gt; my_project.collection = [my_collection]\n&gt;&gt;&gt; my_project.collection[0].inventory = [my_inventory]\n&gt;&gt;&gt; #  ============= Get list of all material nodes in project =============\n&gt;&gt;&gt; all_materials_in_project: list = my_project.find_children({\"node\": [\"Material\"]})\n</code></pre> Notes <p>The <code>find_children</code> method is versatile and can be used to search for nodes based on various criteria. Here are some examples to illustrate its usage:</p> <ul> <li>Searching for Specific Node Types:   <code>search_attr = {\"node\": [\"Parameter\"]}</code> will find all nodes of type \"Parameter\".</li> <li>Searching with Additional Attributes:   <code>search_attr = {\"node\": [\"Algorithm\"], \"parameter\": {\"name\" : \"update_frequency\"}}</code>   will locate \"Algorithm\" nodes containing a parameter named \"update_frequency\".   Note: For list attributes, a match occurs if the specified attribute is part of the list.<ul> <li>Alternate notation: <code>{\"node\": [\"Algorithm\"], \"parameter\": [{\"name\" : \"update_frequency\"}]}</code>.   In this case, nodes with additional parameters are also included.</li> </ul> </li> <li>Combining Multiple Search Criteria:   <pre><code>search_attr = {\n    \"node\": [\"Algorithm\"],\n    \"parameter\": [{\"name\": \"update_frequency\"}, {\"name\": \"cutoff_distance\"}]\n}\n</code></pre>   This finds all \"Algorithm\" nodes with both \"update_frequency\" and \"cutoff_distance\" parameters.</li> </ul> <p>The <code>search_depth</code> parameter controls how deep the search goes into the node tree. A value of <code>-1</code> indicates no depth limit. The method effectively handles cycles in the graph by ensuring each node is processed only once. This makes the function suitable for complex node structures.</p> Source code in <code>src/cript/nodes/core.py</code> <pre><code>def find_children(self, search_attr: dict, search_depth: int = -1, handled_nodes: Optional[List] = None) -&gt; List:\n    \"\"\"\n    Finds all the children in a given tree of nodes (specified by its root),\n    that match the criteria of search_attr.\n    If a node is present multiple times in the graph, it is only once in the search results.\n\n    Parameters\n    ----------\n    search_attr: dict\n        What you are searching for within the JSON.\n        Dictionary that specifies which JSON attributes have to be present in a given node.\n        If an attribute is a list, it is sufficient if the specified attributes are in the list,\n        if others are present too, that does not exclude the child.\n    search_depth: int default -1\n        Max depth of the search into the tree. Helpful if circles are expected. -1 specifies no limit\n    handled_nodes: Optional[List] default None\n        A list used to track nodes that have already been processed during the search.\n        This parameter is primarily used internally to prevent infinite loops in cases\n        where the node graph contains cycles. When a node is processed, it is added to this list.\n        If a node is encountered that is already in this list, it is skipped to avoid redundant processing.\n        By default, this parameter is `None`, which means that the search starts with an empty list of handled nodes.\n        In most use cases, users do not need to provide this parameter, as it is managed internally by the\n        method.\n\n    Returns\n    -------\n    List\n        list of all nodes that match the criteria found within the graph\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; # ============= Create nodes =============\n    &gt;&gt;&gt; my_project = cript.Project(name=f\"my_Project\")\n    &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection\")\n    &gt;&gt;&gt; my_material_1 = cript.Material(\n    ...     name=\"my material 1\", bigsmiles = \"my material 1 bigsmiles\"\n    ... )\n    &gt;&gt;&gt; my_material_2 = cript.Material(\n    ...     name=\"my material 2\", bigsmiles = \"my material 2 bigsmiles\"\n    ... )\n    &gt;&gt;&gt; my_inventory = cript.Inventory(\n    ...     name=\"my inventory\", material=[my_material_1, my_material_2]\n    ... )\n    &gt;&gt;&gt; #  ============= Assemble nodes =============\n    &gt;&gt;&gt; my_project.collection = [my_collection]\n    &gt;&gt;&gt; my_project.collection[0].inventory = [my_inventory]\n    &gt;&gt;&gt; #  ============= Get list of all material nodes in project =============\n    &gt;&gt;&gt; all_materials_in_project: list = my_project.find_children({\"node\": [\"Material\"]})\n\n    Notes\n    -----\n    The `find_children` method is versatile and can be used to search for nodes based on various criteria.\n    Here are some examples to illustrate its usage:\n\n    * Searching for Specific Node Types:\n      `search_attr = {\"node\": [\"Parameter\"]}` will find all nodes of type \"Parameter\".\n    * Searching with Additional Attributes:\n      `search_attr = {\"node\": [\"Algorithm\"], \"parameter\": {\"name\" : \"update_frequency\"}}`\n      will locate \"Algorithm\" nodes containing a parameter named \"update_frequency\".\n      Note: For list attributes, a match occurs if the specified attribute is part of the list.\n        * Alternate notation: `{\"node\": [\"Algorithm\"], \"parameter\": [{\"name\" : \"update_frequency\"}]}`.\n      In this case, nodes with additional parameters are also included.\n    * Combining Multiple Search Criteria:\n      ```python\n      search_attr = {\n          \"node\": [\"Algorithm\"],\n          \"parameter\": [{\"name\": \"update_frequency\"}, {\"name\": \"cutoff_distance\"}]\n      }\n      ```\n      This finds all \"Algorithm\" nodes with both \"update_frequency\" and \"cutoff_distance\" parameters.\n\n    The `search_depth` parameter controls how deep the search goes into the node tree.\n    A value of `-1` indicates no depth limit.\n    The method effectively handles cycles in the graph by ensuring each node is processed only once.\n    This makes the function suitable for complex node structures.\n    \"\"\"\n\n    def is_attr_present(node: BaseNode, key, value):\n        \"\"\"\n        Helper function that checks if an attribute is present in a node.\n        \"\"\"\n        try:\n            attr_key = getattr(node._json_attrs, key)\n        except AttributeError:\n            return False\n\n        # To save code paths, I convert non-lists into lists with one element.\n        if not isinstance(attr_key, list):\n            attr_key = [attr_key]\n        if not isinstance(value, list):\n            value = [value]\n\n        # The definition of search is, that all values in a list have to be present.\n        # To fulfill this AND condition, we count the number of occurrences of that value condition\n        number_values_found = 0\n        # Runtime contribution: O(m), where is is the number of search keys\n        for v in value:\n            # Test for simple values (not-nodes)\n            if v in attr_key:\n                number_values_found += 1\n\n            # Test if value is present in one of the specified attributes (OR condition)\n            # Runtime contribution: O(m), where m is the number of nodes in the attribute list.\n            for attr in attr_key:\n                # if the attribute is a node and the search value is a dictionary,\n                # we can verify that this condition is met if it finds the node itself with `find_children`.\n                if isinstance(attr, BaseNode) and isinstance(v, dict):\n                    # Since we only want to test the node itself and not any of its children, we set recursion to 0.\n                    # Runtime contribution: recursive call, with depth search depth of the search dictionary O(h)\n                    if len(attr.find_children(v, 0)) &gt; 0:\n                        number_values_found += 1\n                        # Since this an OR condition, we abort early.\n                        # This also doesn't inflate the number_values_count,\n                        # since every OR condition should only add a max of 1.\n                        break\n        # Check if the AND condition of the values is met\n        return number_values_found == len(value)\n\n    if handled_nodes is None:\n        handled_nodes = []\n\n    found_children = []\n\n    node_iterator = NodeIterator(self, search_depth)\n    for node in node_iterator:\n        found_attr = 0\n        for key, value in search_attr.items():\n            if is_attr_present(node, key, value):\n                found_attr += 1\n        # If exactly all attributes are found, it matches the search criterion\n        if found_attr == len(search_attr):\n            found_children += [node]\n\n    return found_children\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.get_expanded_json","title":"<code>get_expanded_json(**kwargs)</code>","text":"<p>Generates a long-form JSON representation of the current node and its hierarchy.</p> <p>The long-form JSON includes complete details of the node, eliminating the need for  references to UUIDs to nodes stored in the CRIPT database. This comprehensive representation  is useful for offline storage of CRIPT nodes, transferring nodes between different CRIPT instances,  or for backup purposes.</p> <p>The generated long-form JSON can be reloaded into the SDK using <code>cript.load_nodes_from_json()</code>, ensuring consistency and completeness of the node data. However, it's important to note that this long-form JSON might not comply directly with the JSON schema required for POST or PATCH requests to the CRIPT API.</p> <p>Optional keyword arguments (<code>kwargs</code>) are supported and are passed directly to <code>json.dumps()</code>. These arguments allow customization of the JSON output, such as formatting for readability or pretty printing.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments for <code>json.dumps()</code> to customize the JSON output, such as <code>indent</code> for pretty-printing.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A comprehensive JSON string representing the current node and its entire hierarchy in long-form.</p> Notes <p>The <code>get_expanded_json()</code> method differs from the standard <code>json</code> property or method, which might provide a more condensed version of the node's data.</p> <p>For more information on condensed JSON and deserialization, please feel free to reference our discussion on deserializing Python nodes to JSON</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; # ============= Create all needed nodes =============\n&gt;&gt;&gt; my_project = cript.Project(name=f\"my_Project\")\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection\")\n&gt;&gt;&gt; my_material_1 = cript.Material(\n...     name=\"my material 1\", bigsmiles = \"my material 1 bigsmiles\"\n... )\n&gt;&gt;&gt; my_material_2 = cript.Material(\n...     name=\"my material 2\", bigsmiles = \"my material 2 bigsmiles\"\n... )\n&gt;&gt;&gt; my_inventory = cript.Inventory(\n...     name=\"my inventory\", material=[my_material_1, my_material_2]\n... )\n&gt;&gt;&gt; #  ============= Assemble nodes =============\n&gt;&gt;&gt; my_project.collection = [my_collection]\n&gt;&gt;&gt; my_project.collection[0].inventory = [my_inventory]\n&gt;&gt;&gt; #  ============= Get long form JSON =============\n&gt;&gt;&gt; long_form_json = my_project.get_expanded_json(indent=4)\n</code></pre> Condensed JSON VS Expanded JSON Source code in <code>src/cript/nodes/core.py</code> <pre><code>def get_expanded_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generates a long-form JSON representation of the current node and its hierarchy.\n\n    The long-form JSON includes complete details of the node, eliminating the need for\n     references to UUIDs to nodes stored in the CRIPT database. This comprehensive representation\n     is useful for offline storage of CRIPT nodes, transferring nodes between different CRIPT instances,\n     or for backup purposes.\n\n    The generated long-form JSON can be reloaded into the SDK using\n    [`cript.load_nodes_from_json()`](../../../utility_functions/#cript.nodes.util.load_nodes_from_json),\n    ensuring consistency and completeness of the node data.\n    However, it's important to note that this long-form JSON might not comply directly with the JSON schema\n    required for POST or PATCH requests to the CRIPT API.\n\n    Optional keyword arguments (`kwargs`) are supported and are passed directly to `json.dumps()`.\n    These arguments allow customization of the JSON output, such as formatting for readability\n    or pretty printing.\n\n    Parameters\n    ----------\n    **kwargs : dict, optional\n        Additional keyword arguments for `json.dumps()` to customize the JSON output, such as `indent`\n        for pretty-printing.\n\n    Returns\n    -------\n    str\n        A comprehensive JSON string representing the current node and its entire hierarchy in long-form.\n\n    Notes\n    -----\n    The `get_expanded_json()` method differs from the standard [`json`](./#cript.nodes.core.BaseNode.json)\n    property or method, which might provide a more condensed version of the node's data.\n\n    &gt; For more information on condensed JSON and deserialization, please feel free to reference our discussion\n    &gt; on [deserializing Python nodes to JSON](https://github.com/C-Accel-CRIPT/Python-SDK/discussions/177)\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; # ============= Create all needed nodes =============\n    &gt;&gt;&gt; my_project = cript.Project(name=f\"my_Project\")\n    &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection\")\n    &gt;&gt;&gt; my_material_1 = cript.Material(\n    ...     name=\"my material 1\", bigsmiles = \"my material 1 bigsmiles\"\n    ... )\n    &gt;&gt;&gt; my_material_2 = cript.Material(\n    ...     name=\"my material 2\", bigsmiles = \"my material 2 bigsmiles\"\n    ... )\n    &gt;&gt;&gt; my_inventory = cript.Inventory(\n    ...     name=\"my inventory\", material=[my_material_1, my_material_2]\n    ... )\n    &gt;&gt;&gt; #  ============= Assemble nodes =============\n    &gt;&gt;&gt; my_project.collection = [my_collection]\n    &gt;&gt;&gt; my_project.collection[0].inventory = [my_inventory]\n    &gt;&gt;&gt; #  ============= Get long form JSON =============\n    &gt;&gt;&gt; long_form_json = my_project.get_expanded_json(indent=4)\n\n    ???+ info \"Condensed JSON VS Expanded JSON\"\n        # Default Condensed JSON\n        &gt; This is the JSON when `my_project.json` is called\n\n        ```json linenums=\"1\"\n        {\n           \"node\":[\n              \"Project\"\n           ],\n           \"uid\":\"_:d0d1b3c9-d552-4d4f-afd2-76f01538b87a\",\n           \"uuid\":\"d0d1b3c9-d552-4d4f-afd2-76f01538b87a\",\n           \"name\":\"my_Project\",\n           \"collection\":[\n              {\n                 \"node\":[\n                    \"Collection\"\n                 ],\n                 \"uid\":\"_:07765ac8-862a-459e-9d99-d0439d6a6a09\",\n                 \"uuid\":\"07765ac8-862a-459e-9d99-d0439d6a6a09\",\n                 \"name\":\"my collection\",\n                 \"inventory\":[\n                    {\n                       \"node\":[\n                          \"Inventory\"\n                       ],\n                       \"uid\":\"_:4cf2bbee-3dc0-400b-8269-709f99d89d9f\",\n                       \"uuid\":\"4cf2bbee-3dc0-400b-8269-709f99d89d9f\",\n                       \"name\":\"my inventory\",\n                       \"material\":[\n                          {\n                             \"uuid\":\"0cf14572-4da2-43f2-8cb9-e8374086368e\"\n                          },\n                          {\n                             \"uuid\":\"6302a8b0-4265-4a3a-a40f-bbcbb7293046\"\n                          }\n                       ]\n                    }\n                 ]\n              }\n           ]\n        }\n        ```\n\n        # Expanded JSON\n        &gt; This is what is created when `my_project.get_expanded_json()`\n\n        ```json linenums=\"1\"\n        {\n           \"node\":[\n              \"Project\"\n           ],\n           \"uid\":\"_:afe4bb2f-fa75-4736-b692-418a5143e6f5\",\n           \"uuid\":\"afe4bb2f-fa75-4736-b692-418a5143e6f5\",\n           \"name\":\"my_Project\",\n           \"collection\":[\n              {\n                 \"node\":[\n                    \"Collection\"\n                 ],\n                 \"uid\":\"_:8b5c8125-c956-472a-9d07-8cb7b402b101\",\n                 \"uuid\":\"8b5c8125-c956-472a-9d07-8cb7b402b101\",\n                 \"name\":\"my collection\",\n                 \"inventory\":[\n                    {\n                       \"node\":[\n                          \"Inventory\"\n                       ],\n                       \"uid\":\"_:1bd3c966-cb35-494d-85cd-3515cde570f3\",\n                       \"uuid\":\"1bd3c966-cb35-494d-85cd-3515cde570f3\",\n                       \"name\":\"my inventory\",\n                       \"material\":[\n                          {\n                             \"node\":[\n                                \"Material\"\n                             ],\n                             \"uid\":\"_:07bc3e4f-757f-4ac7-ae8a-7a0c68272531\",\n                             \"uuid\":\"07bc3e4f-757f-4ac7-ae8a-7a0c68272531\",\n                             \"name\":\"my material 1\",\n                             \"bigsmiles\":\"my material 1 bigsmiles\"\n                          },\n                          {\n                             \"node\":[\n                                \"Material\"\n                             ],\n                             \"uid\":\"_:64565687-5707-4d67-860f-5ee4a057a45f\",\n                             \"uuid\":\"64565687-5707-4d67-860f-5ee4a057a45f\",\n                             \"name\":\"my material 2\",\n                             \"bigsmiles\":\"my material 2 bigsmiles\"\n                          }\n                       ]\n                    }\n                 ]\n              }\n           ]\n        }\n        ```\n    \"\"\"\n    return self.get_json(handled_ids=None, known_uuid=None, suppress_attributes=None, is_patch=False, condense_to_uuid={}, **kwargs).json\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.get_expanded_json--default-condensed-json","title":"Default Condensed JSON","text":"<p>This is the JSON when <code>my_project.json</code> is called</p> <pre><code>{\n   \"node\":[\n      \"Project\"\n   ],\n   \"uid\":\"_:d0d1b3c9-d552-4d4f-afd2-76f01538b87a\",\n   \"uuid\":\"d0d1b3c9-d552-4d4f-afd2-76f01538b87a\",\n   \"name\":\"my_Project\",\n   \"collection\":[\n      {\n         \"node\":[\n            \"Collection\"\n         ],\n         \"uid\":\"_:07765ac8-862a-459e-9d99-d0439d6a6a09\",\n         \"uuid\":\"07765ac8-862a-459e-9d99-d0439d6a6a09\",\n         \"name\":\"my collection\",\n         \"inventory\":[\n            {\n               \"node\":[\n                  \"Inventory\"\n               ],\n               \"uid\":\"_:4cf2bbee-3dc0-400b-8269-709f99d89d9f\",\n               \"uuid\":\"4cf2bbee-3dc0-400b-8269-709f99d89d9f\",\n               \"name\":\"my inventory\",\n               \"material\":[\n                  {\n                     \"uuid\":\"0cf14572-4da2-43f2-8cb9-e8374086368e\"\n                  },\n                  {\n                     \"uuid\":\"6302a8b0-4265-4a3a-a40f-bbcbb7293046\"\n                  }\n               ]\n            }\n         ]\n      }\n   ]\n}\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.get_expanded_json--expanded-json","title":"Expanded JSON","text":"<p>This is what is created when <code>my_project.get_expanded_json()</code></p> <pre><code>{\n   \"node\":[\n      \"Project\"\n   ],\n   \"uid\":\"_:afe4bb2f-fa75-4736-b692-418a5143e6f5\",\n   \"uuid\":\"afe4bb2f-fa75-4736-b692-418a5143e6f5\",\n   \"name\":\"my_Project\",\n   \"collection\":[\n      {\n         \"node\":[\n            \"Collection\"\n         ],\n         \"uid\":\"_:8b5c8125-c956-472a-9d07-8cb7b402b101\",\n         \"uuid\":\"8b5c8125-c956-472a-9d07-8cb7b402b101\",\n         \"name\":\"my collection\",\n         \"inventory\":[\n            {\n               \"node\":[\n                  \"Inventory\"\n               ],\n               \"uid\":\"_:1bd3c966-cb35-494d-85cd-3515cde570f3\",\n               \"uuid\":\"1bd3c966-cb35-494d-85cd-3515cde570f3\",\n               \"name\":\"my inventory\",\n               \"material\":[\n                  {\n                     \"node\":[\n                        \"Material\"\n                     ],\n                     \"uid\":\"_:07bc3e4f-757f-4ac7-ae8a-7a0c68272531\",\n                     \"uuid\":\"07bc3e4f-757f-4ac7-ae8a-7a0c68272531\",\n                     \"name\":\"my material 1\",\n                     \"bigsmiles\":\"my material 1 bigsmiles\"\n                  },\n                  {\n                     \"node\":[\n                        \"Material\"\n                     ],\n                     \"uid\":\"_:64565687-5707-4d67-860f-5ee4a057a45f\",\n                     \"uuid\":\"64565687-5707-4d67-860f-5ee4a057a45f\",\n                     \"name\":\"my material 2\",\n                     \"bigsmiles\":\"my material 2 bigsmiles\"\n                  }\n               ]\n            }\n         ]\n      }\n   ]\n}\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.get_json","title":"<code>get_json(handled_ids=None, known_uuid=None, suppress_attributes=None, is_patch=False, condense_to_uuid={'Material': {'parent_material', 'component'}, 'Experiment': {'data'}, 'Inventory': {'material'}, 'Ingredient': {'material'}, 'Property': {'component'}, 'ComputationProcess': {'material'}, 'Data': {'material'}, 'Process': {'product', 'waste'}, 'Project': {'member', 'admin'}, 'Collection': {'member', 'admin'}}, **kwargs)</code>","text":"<p>User facing access to get the JSON of a node. Opposed to the also available property json this functions allows further control. Additionally, this function does not call <code>self.validate()</code> but the property <code>json</code> does. We also accept <code>kwargs</code>, that are passed on to the JSON decoding via <code>json.dumps()</code> this can be used for example to prettify the output.</p> <p>Returns named tuple with json and handled ids as result.</p> Source code in <code>src/cript/nodes/core.py</code> <pre><code>def get_json(\n    self,\n    handled_ids: Optional[Set[str]] = None,\n    known_uuid: Optional[Set[str]] = None,\n    suppress_attributes: Optional[Dict[str, Set[str]]] = None,\n    is_patch: bool = False,\n    condense_to_uuid: Dict[str, Set[str]] = {\n        \"Material\": {\"parent_material\", \"component\"},\n        \"Experiment\": {\"data\"},\n        \"Inventory\": {\"material\"},\n        \"Ingredient\": {\"material\"},\n        \"Property\": {\"component\"},\n        \"ComputationProcess\": {\"material\"},\n        \"Data\": {\"material\"},\n        \"Process\": {\"product\", \"waste\"},\n        \"Project\": {\"member\", \"admin\"},\n        \"Collection\": {\"member\", \"admin\"},\n    },\n    **kwargs\n):\n    \"\"\"\n    User facing access to get the JSON of a node.\n    Opposed to the also available property json this functions allows further control.\n    Additionally, this function does not call `self.validate()` but the property `json` does.\n    We also accept `kwargs`, that are passed on to the JSON decoding via `json.dumps()` this can be used for example to prettify the output.\n\n\n    Returns named tuple with json and handled ids as result.\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class ReturnTuple:\n        json: str\n        json_dict: dict\n        handled_ids: set\n\n    # Do not check for circular references, since we handle them manually\n    kwargs[\"check_circular\"] = kwargs.get(\"check_circular\", False)\n\n    # Delayed import to avoid circular imports\n    from cript.nodes.util import NodeEncoder\n\n    if handled_ids is None:\n        handled_ids = set()\n    previous_handled_nodes = copy.deepcopy(NodeEncoder.handled_ids)\n    NodeEncoder.handled_ids = handled_ids\n\n    # Similar to uid, we handle pre-saved known uuid such that they are UUID edges only\n    if known_uuid is None:\n        known_uuid = set()\n    previous_known_uuid = copy.deepcopy(NodeEncoder.known_uuid)\n    NodeEncoder.known_uuid = known_uuid\n    previous_suppress_attributes = copy.deepcopy(NodeEncoder.suppress_attributes)\n    NodeEncoder.suppress_attributes = suppress_attributes\n    previous_condense_to_uuid = copy.deepcopy(NodeEncoder.condense_to_uuid)\n    NodeEncoder.condense_to_uuid = condense_to_uuid\n\n    try:\n        tmp_json = json.dumps(self, cls=NodeEncoder, **kwargs)\n        tmp_dict = json.loads(tmp_json)\n        if is_patch:\n            del tmp_dict[\"uuid\"]  # patches do not allow UUID is the parent most node\n\n        return ReturnTuple(json.dumps(tmp_dict, **kwargs), tmp_dict, NodeEncoder.handled_ids)\n    except Exception as exc:\n        # TODO this handling that doesn't tell the user what happened and how they can fix it\n        #   this just tells the user that something is wrong\n        #   this should be improved to tell the user what went wrong and where\n        raise CRIPTJsonSerializationError(str(type(self)), str(self._json_attrs)) from exc\n    finally:\n        NodeEncoder.handled_ids = previous_handled_nodes\n        NodeEncoder.known_uuid = previous_known_uuid\n        NodeEncoder.suppress_attributes = previous_suppress_attributes\n        NodeEncoder.condense_to_uuid = previous_condense_to_uuid\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.remove_child","title":"<code>remove_child(child)</code>","text":"<p>This safely removes the first found child node from the parent. This requires exact node as we test with <code>is</code> instead of <code>==</code>.</p> <p>returns True if child was found and deleted, False if child not found, raise DB schema exception if deletion violates DB schema.</p> Source code in <code>src/cript/nodes/core.py</code> <pre><code>def remove_child(self, child) -&gt; bool:\n    \"\"\"\n    This safely removes the first found child node from the parent.\n    This requires exact node as we test with `is` instead of `==`.\n\n    returns True if child was found and deleted, False if child not found,\n    raise DB schema exception if deletion violates DB schema.\n    \"\"\"\n\n    # If we delete a child, we have to replace that with a default value.\n    # The easiest way to access this default value is to get it from the the default JsonAttribute of that class\n    default_json_attrs = self.JsonAttributes()\n    new_attrs = self._json_attrs\n    for field in self._json_attrs.__dataclass_fields__:\n        value = getattr(self._json_attrs, field)\n        if value is child:\n            new_attrs = replace(new_attrs, **{field: getattr(default_json_attrs, field)})\n            # We only want to delete the first found child\n        elif not isinstance(value, str):  # Strings are iterable, but we don't want them\n            try:  # Try if we are facing a list at the moment\n                new_attr_list = [element for element in value]\n            except TypeError:\n                pass  # It is OK if this field is not a list\n            else:\n                found_child = False\n                for i, list_value in enumerate(value):\n                    if list_value is child:\n                        found_child = True\n                        del new_attr_list[i]\n                        # Only delete first child.\n                        # Important to break loop here, since value and new_attr_list are not identical any more.\n                if found_child:\n                    new_attrs = replace(new_attrs, **{field: new_attr_list})  # type: ignore\n                    # Again only first found place is removed\n                    break\n    # Let's see if we found the child aka the new_attrs are different than the old ones\n    if new_attrs is self._json_attrs:\n        return False\n    self._update_json_attrs_if_valid(new_attrs)\n    return True\n</code></pre>"},{"location":"nodes/primary_nodes/base_node/#cript.nodes.core.BaseNode.validate","title":"<code>validate(api=None, is_patch=False, force_validation=False)</code>","text":"<p>Validate this node (and all its children) against the schema provided by the data bank.</p> Raises: <p>Exception with more error information.</p> Source code in <code>src/cript/nodes/core.py</code> <pre><code>def validate(self, api=None, is_patch: bool = False, force_validation: bool = False) -&gt; None:\n    \"\"\"\n    Validate this node (and all its children) against the schema provided by the data bank.\n\n    Raises:\n    -------\n    Exception with more error information.\n    \"\"\"\n    from cript.api.api import _get_global_cached_api\n\n    if api is None:\n        api = _get_global_cached_api()\n    api.schema.is_node_schema_valid(self.get_json(is_patch=is_patch).json, is_patch=is_patch, force_validation=force_validation)\n</code></pre>"},{"location":"nodes/primary_nodes/collection/","title":"Collection","text":""},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection","title":"<code>Collection</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection--definition","title":"Definition","text":"<p>A Collection node is nested inside a Project node.</p> <p>A Collection node can be thought as a folder/bucket that can hold experiment or Inventories node.</p> attribute type example description experiment list[Experiment] experiment that relate to the collection inventory list[Inventory] inventory owned by the collection doi str <code>10.1038/1781168a0</code> DOI: digital object identifier for a published collection; CRIPT generated DOI citation list[Citation] reference to a book, paper, or scholarly work notes str \"my awesome notes\" miscellaneous information, or custom data structure"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection--json-representation","title":"JSON Representation","text":"<pre><code>{\n\"name\": \"my collection JSON\",\n \"node\":[\"Collection\"],\n \"uid\":\"_:fccd3549-07cb-4e23-ba79-323597ec9bfd\",\n \"uuid\":\"fccd3549-07cb-4e23-ba79-323597ec9bfd\"\n\n \"experiment\":[\n    {\n       \"name\":\"my experiment name\",\n       \"node\":[\"Experiment\"],\n       \"uid\":\"_:8256b75b-1f4e-4f69-9fe6-3bcb2298e470\",\n       \"uuid\":\"8256b75b-1f4e-4f69-9fe6-3bcb2298e470\"\n    }\n ],\n \"inventory\":[],\n \"citation\":[],\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/collection.py</code> <pre><code>class Collection(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n\n    A\n    [Collection node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=8)\n    is nested inside a [Project](../project) node.\n\n    A Collection node can be thought as a folder/bucket that can hold [experiment](../experiment)\n    or [Inventories](../inventory) node.\n\n    | attribute  | type             | example             | description                                                                    |\n    |------------|------------------|---------------------|--------------------------------------------------------------------------------|\n    | experiment | list[Experiment] |                     | experiment that relate to the collection                                       |\n    | inventory  | list[Inventory]  |                     | inventory owned by the collection                                              |\n    | doi        | str              | `10.1038/1781168a0` | DOI: digital object identifier for a published collection; CRIPT generated DOI |\n    | citation   | list[Citation]   |                     | reference to a book, paper, or scholarly work                                  |\n    | notes      | str              | \"my awesome notes\"  | miscellaneous information, or custom data structure                            |\n\n\n    ## JSON Representation\n    ```json\n    {\n    \"name\": \"my collection JSON\",\n     \"node\":[\"Collection\"],\n     \"uid\":\"_:fccd3549-07cb-4e23-ba79-323597ec9bfd\",\n     \"uuid\":\"fccd3549-07cb-4e23-ba79-323597ec9bfd\"\n\n     \"experiment\":[\n        {\n           \"name\":\"my experiment name\",\n           \"node\":[\"Experiment\"],\n           \"uid\":\"_:8256b75b-1f4e-4f69-9fe6-3bcb2298e470\",\n           \"uuid\":\"8256b75b-1f4e-4f69-9fe6-3bcb2298e470\"\n        }\n     ],\n     \"inventory\":[],\n     \"citation\":[],\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Collection attributes\n        \"\"\"\n\n        # TODO add proper typing in future, using Any for now to avoid circular import error\n        member: List[Union[User, UIDProxy]] = field(default_factory=list)\n        admin: List[Union[User, UIDProxy]] = field(default_factory=list)\n        experiment: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        inventory: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        doi: str = \"\"\n        citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self, name: str, experiment: Optional[List[Union[Any, UIDProxy]]] = None, inventory: Optional[List[Union[Any, UIDProxy]]] = None, doi: str = \"\", citation: Optional[List[Union[Any, UIDProxy]]] = None, notes: str = \"\", **kwargs\n    ) -&gt; None:\n        \"\"\"\n        create a Collection with a name\n        add list of experiment, inventory, citation, doi, and notes if available.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n\n        Parameters\n        ----------\n        name: str\n            name of the Collection you want to make\n        experiment: Optional[List[Experiment]], default=None\n            list of experiment within the Collection\n        inventory: Optional[List[Inventory]], default=None\n            list of inventories within this collection\n        doi: str = \"\", default=\"\"\n            cript doi\n        citation: Optional[List[Citation]], default=None\n            List of citations for this collection\n\n        Returns\n        -------\n        None\n            Instantiates a Collection node\n        \"\"\"\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        if experiment is None:\n            experiment = []\n\n        if inventory is None:\n            inventory = []\n\n        if citation is None:\n            citation = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            name=name,\n            experiment=experiment,\n            inventory=inventory,\n            doi=doi,\n            citation=citation,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def member(self) -&gt; List[Union[User, UIDProxy]]:\n        return self._json_attrs.member.copy()\n\n    @property\n    @beartype\n    def admin(self) -&gt; List[Union[User, UIDProxy]]:\n        return self._json_attrs.admin\n\n    @property\n    @beartype\n    def experiment(self) -&gt; List[Any]:\n        \"\"\"\n        List of all [experiment](../experiment) within this Collection\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_collection.experiment = [my_experiment]\n\n        Returns\n        -------\n        List[Experiment]\n            list of all [experiment](../experiment) within this Collection\n        \"\"\"\n        return self._json_attrs.experiment.copy()  # type: ignore\n\n    @experiment.setter\n    @beartype\n    def experiment(self, new_experiment: List[Any]) -&gt; None:\n        \"\"\"\n        sets the Experiment list within this collection\n\n        Parameters\n        ----------\n        new_experiment: List[Experiment]\n            list of experiment\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, experiment=new_experiment)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def inventory(self) -&gt; List[Any]:\n        \"\"\"\n        List of [inventory](../inventory) that belongs to this collection\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n        &gt;&gt;&gt; material_1 = cript.Material(\n        ...     name=\"material 1\",\n        ...     bigsmiles = \"material 1 bigsmiles\",\n        ... )\n        &gt;&gt;&gt; material_2 = cript.Material(\n        ...     name=\"material 2\",\n        ...     bigsmiles = \"material 2 bigsmiles\",\n        ... )\n        &gt;&gt;&gt; my_inventory = cript.Inventory(\n        ...     name=\"my inventory name\", material=[material_1, material_2]\n        ... )\n        &gt;&gt;&gt; my_collection.inventory = [my_inventory]\n\n        Returns\n        -------\n        inventory: List[Inventory]\n            list of inventories in this collection\n        \"\"\"\n        return self._json_attrs.inventory.copy()  # type: ignore\n\n    @inventory.setter\n    @beartype\n    def inventory(self, new_inventory: List[Any]) -&gt; None:\n        \"\"\"\n        Sets the List of inventories within this collection to a new list\n\n        Parameters\n        ----------\n        new_inventory: List[Inventory]\n            new list of inventories for the collection to overwrite the current list\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, inventory=new_inventory)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def doi(self) -&gt; str:\n        \"\"\"\n        The CRIPT DOI for this collection\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n        &gt;&gt;&gt; my_collection.doi = \"10.1038/1781168a0\"\n\n        Returns\n        -------\n        doi: str\n            the CRIPT DOI e.g. `10.1038/1781168a0`\n        \"\"\"\n        return self._json_attrs.doi\n\n    @doi.setter\n    @beartype\n    def doi(self, new_doi: str) -&gt; None:\n        \"\"\"\n        set the CRIPT DOI for this collection to new CRIPT DOI\n\n        Parameters\n        ----------\n        new_doi: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, doi=new_doi)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Any]:\n        \"\"\"\n        List of Citations within this Collection\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=\"title\",\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n        &gt;&gt;&gt; my_collection.citation = [my_citation]\n\n        Returns\n        -------\n        citation: List[Citation]:\n            list of Citations within this Collection\n        \"\"\"\n        return self._json_attrs.citation.copy()  # type: ignore\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of citations for this Collection\n\n        Parameters\n        ----------\n        new_citation: List[Citation]\n            set the list of citations for this Collection\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection.citation","title":"<code>citation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of Citations within this Collection</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n&gt;&gt;&gt; my_reference = cript.Reference(\n...     type=\"journal_article\",\n...     title=\"title\",\n...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n...     journal=\"Computer Physics Communications\",\n...     publisher=\"Elsevier\",\n...     year=2019,\n...     pages=[463, 476],\n...     doi=\"10.1016/j.cpc.2018.08.011\",\n...     issn=\"0010-4655\",\n...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n... )\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n&gt;&gt;&gt; my_collection.citation = [my_citation]\n</code></pre> <p>Returns:</p> Name Type Description <code>citation</code> <code>List[Citation]:</code> <p>list of Citations within this Collection</p>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection.doi","title":"<code>doi: str</code>  <code>property</code> <code>writable</code>","text":"<p>The CRIPT DOI for this collection</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n&gt;&gt;&gt; my_collection.doi = \"10.1038/1781168a0\"\n</code></pre> <p>Returns:</p> Name Type Description <code>doi</code> <code>str</code> <p>the CRIPT DOI e.g. <code>10.1038/1781168a0</code></p>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection.experiment","title":"<code>experiment: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of all experiment within this Collection</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_collection.experiment = [my_experiment]\n</code></pre> <p>Returns:</p> Type Description <code>List[Experiment]</code> <p>list of all experiment within this Collection</p>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection.inventory","title":"<code>inventory: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of inventory that belongs to this collection</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n&gt;&gt;&gt; material_1 = cript.Material(\n...     name=\"material 1\",\n...     bigsmiles = \"material 1 bigsmiles\",\n... )\n&gt;&gt;&gt; material_2 = cript.Material(\n...     name=\"material 2\",\n...     bigsmiles = \"material 2 bigsmiles\",\n... )\n&gt;&gt;&gt; my_inventory = cript.Inventory(\n...     name=\"my inventory name\", material=[material_1, material_2]\n... )\n&gt;&gt;&gt; my_collection.inventory = [my_inventory]\n</code></pre> <p>Returns:</p> Name Type Description <code>inventory</code> <code>List[Inventory]</code> <p>list of inventories in this collection</p>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Collection attributes</p> Source code in <code>src/cript/nodes/primary_nodes/collection.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Collection attributes\n    \"\"\"\n\n    # TODO add proper typing in future, using Any for now to avoid circular import error\n    member: List[Union[User, UIDProxy]] = field(default_factory=list)\n    admin: List[Union[User, UIDProxy]] = field(default_factory=list)\n    experiment: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    inventory: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    doi: str = \"\"\n    citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/collection/#cript.nodes.primary_nodes.collection.Collection.__init__","title":"<code>__init__(name, experiment=None, inventory=None, doi='', citation=None, notes='', **kwargs)</code>","text":"<p>create a Collection with a name add list of experiment, inventory, citation, doi, and notes if available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the Collection you want to make</p> required <code>experiment</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of experiment within the Collection</p> <code>None</code> <code>inventory</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of inventories within this collection</p> <code>None</code> <code>doi</code> <code>str</code> <p>cript doi</p> <code>''</code> <code>citation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>List of citations for this collection</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Instantiates a Collection node</p> Source code in <code>src/cript/nodes/primary_nodes/collection.py</code> <pre><code>@beartype\ndef __init__(\n    self, name: str, experiment: Optional[List[Union[Any, UIDProxy]]] = None, inventory: Optional[List[Union[Any, UIDProxy]]] = None, doi: str = \"\", citation: Optional[List[Union[Any, UIDProxy]]] = None, notes: str = \"\", **kwargs\n) -&gt; None:\n    \"\"\"\n    create a Collection with a name\n    add list of experiment, inventory, citation, doi, and notes if available.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_collection = cript.Collection(name=\"my collection name\")\n\n    Parameters\n    ----------\n    name: str\n        name of the Collection you want to make\n    experiment: Optional[List[Experiment]], default=None\n        list of experiment within the Collection\n    inventory: Optional[List[Inventory]], default=None\n        list of inventories within this collection\n    doi: str = \"\", default=\"\"\n        cript doi\n    citation: Optional[List[Citation]], default=None\n        List of citations for this collection\n\n    Returns\n    -------\n    None\n        Instantiates a Collection node\n    \"\"\"\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    if experiment is None:\n        experiment = []\n\n    if inventory is None:\n        inventory = []\n\n    if citation is None:\n        citation = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        name=name,\n        experiment=experiment,\n        inventory=inventory,\n        doi=doi,\n        citation=citation,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/computation/","title":"Computation","text":""},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation","title":"<code>Computation</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation--definition","title":"Definition","text":"<p>The Computation node describes the transformation of data or the creation of a computational data set.</p> <p>Common computations for simulations are energy minimization, annealing, quenching, or NPT/NVT (isothermal-isobaric/canonical ensemble) simulations.</p> <p>Common computations for experimental data include fitting a reaction model to kinetic data to determine rate constants, a plateau modulus from a time-temperature-superposition, or calculating radius of gyration with the Debye function from small angle scattering data.</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation--attributes","title":"Attributes","text":"attribute type example description required vocab type str general molecular dynamics simulation category of computation True True input_data list[Data] input data nodes output_data list[Data] output data nodes software_ configurations list[Software  Configuration] software and algorithms used condition list[Condition] setup information prerequisite_computation Computation prior computation method in chain citation list[Citation] reference to a book, paper, or scholarly work notes str additional description of the step"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my computation name\",\n   \"node\":[\"Computation\"],\n   \"type\":\"analysis\",\n   \"uid\":\"_:69f29bec-e30a-4932-b78d-2e4585b37d74\",\n   \"uuid\":\"69f29bec-e30a-4932-b78d-2e4585b37d74\"\n   \"citation\":[],\n}\n</code></pre>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation--available-subobjects","title":"Available Subobjects","text":"<ul> <li>Software Configuration</li> <li>Condition</li> <li>Citation</li> </ul> Source code in <code>src/cript/nodes/primary_nodes/computation.py</code> <pre><code>class Computation(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n\n    The\n    [Computation node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=14)\n    describes the transformation of data or the creation of a computational data\n    set.\n\n    **Common computations for simulations** are energy minimization, annealing, quenching, or\n    NPT/NVT (isothermal-isobaric/canonical ensemble) simulations.\n\n    **Common computations for experimental** data include fitting a reaction model to kinetic data\n    to determine rate constants, a plateau modulus from a time-temperature-superposition, or calculating radius of\n    gyration with the Debye function from small angle scattering data.\n\n\n\n    ## Attributes\n    | attribute                | type                          | example                               | description                                   | required | vocab |\n    |--------------------------|-------------------------------|---------------------------------------|-----------------------------------------------|----------|-------|\n    | type                     | str                           | general molecular dynamics simulation | category of computation                       | True     | True  |\n    | input_data               | list[Data]                    |                                       | input data nodes                              |          |       |\n    | output_data              | list[Data]                    |                                       | output data nodes                             |          |       |\n    | software_ configurations | list[Software  Configuration] |                                       | software and algorithms used                  |          |       |\n    | condition                | list[Condition]               |                                       | setup information                             |          |       |\n    | prerequisite_computation | Computation                   |                                       | prior computation method in chain             |          |       |\n    | citation                 | list[Citation]                |                                       | reference to a book, paper, or scholarly work |          |       |\n    | notes                    | str                           |                                       | additional description of the step            |          |       |\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my computation name\",\n       \"node\":[\"Computation\"],\n       \"type\":\"analysis\",\n       \"uid\":\"_:69f29bec-e30a-4932-b78d-2e4585b37d74\",\n       \"uuid\":\"69f29bec-e30a-4932-b78d-2e4585b37d74\"\n       \"citation\":[],\n    }\n    ```\n\n\n    ## Available Subobjects\n    * [Software Configuration](../../subobjects/software_configuration)\n    * [Condition](../../subobjects/condition)\n    * [Citation](../../subobjects/citation)\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all computation nodes attributes\n        \"\"\"\n\n        type: str = \"\"\n        # TODO add proper typing in future, using Any for now to avoid circular import error\n        input_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        output_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        software_configuration: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        condition: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        prerequisite_computation: Optional[Union[\"Computation\", UIDProxy]] = None\n        citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        name: str,\n        type: str,\n        input_data: Optional[List[Union[Any, UIDProxy]]] = None,\n        output_data: Optional[List[Union[Any, UIDProxy]]] = None,\n        software_configuration: Optional[List[Union[Any, UIDProxy]]] = None,\n        condition: Optional[List[Union[Any, UIDProxy]]] = None,\n        prerequisite_computation: Optional[Union[\"Computation\", UIDProxy]] = None,\n        citation: Optional[List[Union[Any, UIDProxy]]] = None,\n        notes: str = \"\",\n        **kwargs\n    ) -&gt; None:\n        \"\"\"\n        create a computation node\n\n        Parameters\n        ----------\n        name: str\n            name of computation node\n        type: str\n            type of computation node. Computation type must come from CRIPT controlled vocabulary\n        input_data: List[Data] default=None\n            input data (data node)\n        output_data: List[Data] default=None\n            output data (data node)\n        software_configuration: List[SoftwareConfiguration] default=None\n            software configuration of computation node\n        condition: List[Condition] default=None\n            condition for the computation node\n        prerequisite_computation: Computation default=None\n            prerequisite computation\n        citation: List[Citation] default=None\n            list of citations\n        notes: str = \"\"\n            any notes for this computation node\n        **kwargs\n            for internal use of deserialize JSON from API to node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n\n        Returns\n        -------\n        None\n            instantiate a computation node\n\n        \"\"\"\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        if input_data is None:\n            input_data = []\n\n        if output_data is None:\n            output_data = []\n\n        if software_configuration is None:\n            software_configuration = []\n\n        if condition is None:\n            condition = []\n\n        if citation is None:\n            citation = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            type=type,\n            input_data=input_data,\n            output_data=output_data,\n            software_configuration=software_configuration,\n            condition=condition,\n            prerequisite_computation=prerequisite_computation,\n            citation=citation,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    # ------------------ Properties ------------------\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        The type of computation\n\n        The [computation type](https://app.criptapp.org/vocab/computation_type)\n        must come from CRIPT controlled vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_computation.type = type=\"analysis\"\n\n        Returns\n        -------\n        str\n            type of computation\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_computation_type: str) -&gt; None:\n        \"\"\"\n        set the computation type\n\n        the computation type must come from CRIPT controlled vocabulary\n\n        Parameters\n        ----------\n        new_computation_type: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_computation_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def input_data(self) -&gt; List[Any]:\n        \"\"\"\n        List of input data (data nodes) for this node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_input_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_computation.input_data = [my_input_data]\n\n        Returns\n        -------\n        List[Data]\n            list of input data for this computation\n        \"\"\"\n        return self._json_attrs.input_data.copy()\n\n    @input_data.setter\n    @beartype\n    def input_data(self, new_input_data_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the input data list\n\n        Parameters\n        ----------\n        new_input_data_list: List[Data]\n            list of input data (data nodes) to replace the current\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, input_data=new_input_data_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def output_data(self) -&gt; List[Any]:\n        \"\"\"\n        List of output data (data nodes)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_output_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_computation.output_data = [my_output_data]\n\n        Returns\n        -------\n        List[Data]\n            list of output data for this computation\n        \"\"\"\n        return self._json_attrs.output_data.copy()\n\n    @output_data.setter\n    @beartype\n    def output_data(self, new_output_data_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of output data (data nodes) for this node\n\n        Parameters\n        ----------\n        new_output_data_list: List[Data]\n            replace the current list of output data for this node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, output_data=new_output_data_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def software_configuration(self) -&gt; List[Any]:\n        \"\"\"\n        List of software_configuration for this computation node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n        &gt;&gt;&gt; my_computation.software_configuration = [my_software_configuration]\n\n        Returns\n        -------\n        List[SoftwareConfiguration]\n            list of software configurations\n        \"\"\"\n        return self._json_attrs.software_configuration.copy()\n\n    @software_configuration.setter\n    @beartype\n    def software_configuration(self, new_software_configuration_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of software_configuration for this computation node\n\n        Parameters\n        ----------\n        new_software_configuration_list: List[software_configuration]\n            new_software_configuration_list to replace the current one\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, software_configuration=new_software_configuration_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def condition(self) -&gt; List[Any]:\n        \"\"\"\n        List of condition for this computation node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"min\", value=1)\n        &gt;&gt;&gt; my_computation.condition = [my_condition]\n\n        Returns\n        -------\n        List[Condition]\n            list of condition for the computation node\n        \"\"\"\n        return self._json_attrs.condition.copy()\n\n    @condition.setter\n    @beartype\n    def condition(self, new_condition_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of condition for this node\n\n        Parameters\n        ----------\n        new_condition_list: List[Condition]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, condition=new_condition_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def prerequisite_computation(self) -&gt; Optional[Union[\"Computation\", UIDProxy]]:\n        \"\"\"\n        prerequisite computation\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_prerequisite_computation = cript.Computation(\n        ...     name=\"my prerequisite computation name\", type=\"data_fit\"\n        ... )\n        &gt;&gt;&gt; my_computation.prerequisite_computation = my_prerequisite_computation\n\n        Returns\n        -------\n        Computation\n            prerequisite computation\n        \"\"\"\n        return self._json_attrs.prerequisite_computation\n\n    @prerequisite_computation.setter\n    @beartype\n    def prerequisite_computation(self, new_prerequisite_computation: Optional[Union[\"Computation\", UIDProxy]]) -&gt; None:\n        \"\"\"\n        set new prerequisite_computation\n\n        Parameters\n        ----------\n        new_prerequisite_computation: \"Computation\"\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, prerequisite_computation=new_prerequisite_computation)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Any]:\n        \"\"\"\n        List of citations\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n        &gt;&gt;&gt; my_computation.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of citations for this computation node\n        \"\"\"\n        return self._json_attrs.citation.copy()  # type: ignore\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the List of citations\n\n        Parameters\n        ----------\n        new_citation_list: List[Citation]\n            list of citations for this computation node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.citation","title":"<code>citation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of citations</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n&gt;&gt;&gt; my_computation.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of citations for this computation node</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.condition","title":"<code>condition: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of condition for this computation node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"min\", value=1)\n&gt;&gt;&gt; my_computation.condition = [my_condition]\n</code></pre> <p>Returns:</p> Type Description <code>List[Condition]</code> <p>list of condition for the computation node</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.input_data","title":"<code>input_data: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of input data (data nodes) for this node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_input_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_computation.input_data = [my_input_data]\n</code></pre> <p>Returns:</p> Type Description <code>List[Data]</code> <p>list of input data for this computation</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.output_data","title":"<code>output_data: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of output data (data nodes)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_output_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_computation.output_data = [my_output_data]\n</code></pre> <p>Returns:</p> Type Description <code>List[Data]</code> <p>list of output data for this computation</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.prerequisite_computation","title":"<code>prerequisite_computation: Optional[Union[Computation, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>prerequisite computation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_prerequisite_computation = cript.Computation(\n...     name=\"my prerequisite computation name\", type=\"data_fit\"\n... )\n&gt;&gt;&gt; my_computation.prerequisite_computation = my_prerequisite_computation\n</code></pre> <p>Returns:</p> Type Description <code>Computation</code> <p>prerequisite computation</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.software_configuration","title":"<code>software_configuration: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of software_configuration for this computation node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n&gt;&gt;&gt; my_computation.software_configuration = [my_software_configuration]\n</code></pre> <p>Returns:</p> Type Description <code>List[SoftwareConfiguration]</code> <p>list of software configurations</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>The type of computation</p> <p>The computation type must come from CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_computation.type = type=\"analysis\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>type of computation</p>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all computation nodes attributes</p> Source code in <code>src/cript/nodes/primary_nodes/computation.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all computation nodes attributes\n    \"\"\"\n\n    type: str = \"\"\n    # TODO add proper typing in future, using Any for now to avoid circular import error\n    input_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    output_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    software_configuration: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    condition: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    prerequisite_computation: Optional[Union[\"Computation\", UIDProxy]] = None\n    citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/computation/#cript.nodes.primary_nodes.computation.Computation.__init__","title":"<code>__init__(name, type, input_data=None, output_data=None, software_configuration=None, condition=None, prerequisite_computation=None, citation=None, notes='', **kwargs)</code>","text":"<p>create a computation node</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of computation node</p> required <code>type</code> <code>str</code> <p>type of computation node. Computation type must come from CRIPT controlled vocabulary</p> required <code>input_data</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>input data (data node)</p> <code>None</code> <code>output_data</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>output data (data node)</p> <code>None</code> <code>software_configuration</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>software configuration of computation node</p> <code>None</code> <code>condition</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>condition for the computation node</p> <code>None</code> <code>prerequisite_computation</code> <code>Optional[Union[Computation, UIDProxy]]</code> <p>prerequisite computation</p> <code>None</code> <code>citation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of citations</p> <code>None</code> <code>notes</code> <code>str</code> <p>any notes for this computation node</p> <code>''</code> <code>**kwargs</code> <p>for internal use of deserialize JSON from API to node</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>instantiate a computation node</p> Source code in <code>src/cript/nodes/primary_nodes/computation.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    name: str,\n    type: str,\n    input_data: Optional[List[Union[Any, UIDProxy]]] = None,\n    output_data: Optional[List[Union[Any, UIDProxy]]] = None,\n    software_configuration: Optional[List[Union[Any, UIDProxy]]] = None,\n    condition: Optional[List[Union[Any, UIDProxy]]] = None,\n    prerequisite_computation: Optional[Union[\"Computation\", UIDProxy]] = None,\n    citation: Optional[List[Union[Any, UIDProxy]]] = None,\n    notes: str = \"\",\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    create a computation node\n\n    Parameters\n    ----------\n    name: str\n        name of computation node\n    type: str\n        type of computation node. Computation type must come from CRIPT controlled vocabulary\n    input_data: List[Data] default=None\n        input data (data node)\n    output_data: List[Data] default=None\n        output data (data node)\n    software_configuration: List[SoftwareConfiguration] default=None\n        software configuration of computation node\n    condition: List[Condition] default=None\n        condition for the computation node\n    prerequisite_computation: Computation default=None\n        prerequisite computation\n    citation: List[Citation] default=None\n        list of citations\n    notes: str = \"\"\n        any notes for this computation node\n    **kwargs\n        for internal use of deserialize JSON from API to node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n\n    Returns\n    -------\n    None\n        instantiate a computation node\n\n    \"\"\"\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    if input_data is None:\n        input_data = []\n\n    if output_data is None:\n        output_data = []\n\n    if software_configuration is None:\n        software_configuration = []\n\n    if condition is None:\n        condition = []\n\n    if citation is None:\n        citation = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        type=type,\n        input_data=input_data,\n        output_data=output_data,\n        software_configuration=software_configuration,\n        condition=condition,\n        prerequisite_computation=prerequisite_computation,\n        citation=citation,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/computation_process/","title":"Computation Process","text":""},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess","title":"<code>ComputationProcess</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess--definition","title":"Definition","text":"<p>A Computational_Process is a simulation that processes or changes a virtual material. Examples include simulations of chemical reactions, chain scission, cross-linking, strong shear, etc. A computational process may also encapsulate any computation that dramatically changes the materials properties, molecular topology, and physical aspects like molecular orientation, etc. The computation_forcefield of a simulation is associated with a material. As a consequence, if the forcefield changes or gets refined via a computational procedure (density functional theory, iterative Boltzmann inversion for coarse-graining etc.) this forcefield changing step must be described as a computational_process and a new material node with a different computation_forcefield needs to be created.</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess--attributes","title":"Attributes","text":"attribute type example description required vocab type str general molecular dynamics simulation category of computation True True input_data list[Data] input data nodes True output_data list[Data] output data nodes ingredient list[Ingredient] ingredients True software_ configurations list[Software  Configuration] software and algorithms used condition list[Condition] setup information property list[Property] computation process properties citation list[Citation] reference to a book, paper, or scholarly work notes str additional description of the step"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess--available-subobjects","title":"Available Subobjects","text":"<ul> <li>ingredient</li> <li>software_configuration</li> <li>property</li> <li>condition</li> <li>citation</li> </ul>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my computational process node name\",\n   \"node\":[\"ComputationProcess\"],\n   \"type\":\"cross_linking\",\n   \"uid\":\"_:b88ac0a5-b5c0-4197-a63d-b37e1fe8c6c6\",\n   \"uuid\":\"b88ac0a5-b5c0-4197-a63d-b37e1fe8c6c6\"\n   \"ingredient\":[\n      {\n        \"node\":[\"Ingredient\"],\n        \"uid\":\"_:f68d6fff-9327-48b1-9249-33ce498005e8\",\n         \"uuid\":\"f68d6fff-9327-48b1-9249-33ce498005e8\"\n         \"keyword\":[\"catalyst\"],\n         \"material\":{\n            \"name\":\"my material name\",\n            \"node\":[\"Material\"],\n            \"uid\":\"_:3b12f92c-2121-4520-920e-b4c5622de34a\",\n            \"uuid\":\"3b12f92c-2121-4520-920e-b4c5622de34a\",\n            \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n         },\n\n         \"quantity\":[\n            {\n               \"key\":\"mass\",\n               \"node\":[\"Quantity\"],\n               \"uid\":\"_:07c4a6a9-9385-4505-a30a-ca3549cedcd8\",\n               \"uuid\":\"07c4a6a9-9385-4505-a30a-ca3549cedcd8\",\n               \"uncertainty\":0.2,\n               \"uncertainty_type\":\"stdev\",\n               \"unit\":\"kg\",\n               \"value\":11.2\n            }\n         ]\n      }\n   ],\n   \"input_data\":[\n      {\n        \"name\":\"my data name\",\n         \"node\":[\"Data\"],\n         \"type\":\"afm_amp\",\n         \"uid\":\"_:3c16bb05-ded1-4f52-9d02-c88c1a1de915\",\n         \"uuid\":\"3c16bb05-ded1-4f52-9d02-c88c1a1de915\"\n         \"file\":[\n            {\n               \"name\":\"my file node name\",\n               \"node\":[\"File\"],\n               \"source\":\"https://criptapp.org\",\n               \"type\":\"calibration\",\n                \"data_dictionary\":\"my file's data dictionary\",\n               \"extension\":\".csv\",\n               \"uid\":\"_:ee8153db-4108-49e4-8c5b-ffc26d4e6f71\",\n               \"uuid\":\"ee8153db-4108-49e4-8c5b-ffc26d4e6f71\"\n            }\n         ],\n      }\n   ],\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/computation_process.py</code> <pre><code>class ComputationProcess(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n\n    A\n    [Computational_Process](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=15)\n    is a simulation that processes or changes a virtual material. Examples\n    include simulations of chemical reactions, chain scission, cross-linking, strong shear, etc. A\n    computational process may also encapsulate any computation that dramatically changes the\n    materials properties, molecular topology, and physical aspects like molecular orientation, etc. The\n    computation_forcefield of a simulation is associated with a material. As a consequence, if the\n    forcefield changes or gets refined via a computational procedure (density functional theory,\n    iterative Boltzmann inversion for coarse-graining etc.) this forcefield changing step must be\n    described as a computational_process and a new material node with a different\n    computation_forcefield needs to be created.\n\n    ## Attributes\n    | attribute                | type                          | example                               | description                                   | required | vocab |\n    |--------------------------|-------------------------------|---------------------------------------|-----------------------------------------------|----------|-------|\n    | type                     | str                           | general molecular dynamics simulation | category of computation                       | True     | True  |\n    | input_data               | list[Data]                    |                                       | input data nodes                              | True     |       |\n    | output_data              | list[Data]                    |                                       | output data nodes                             |          |       |\n    | ingredient               | list[Ingredient]              |                                       | ingredients                                   | True     |       |\n    | software_ configurations | list[Software  Configuration] |                                       | software and algorithms used                  |          |       |\n    | condition                | list[Condition]               |                                       | setup information                             |          |       |\n    | property                 | list[Property]                |                                       | computation process properties                |          |       |\n    | citation                 | list[Citation]                |                                       | reference to a book, paper, or scholarly work |          |       |\n    | notes                    | str                           |                                       | additional description of the step            |          |       |\n\n\n    ## Available Subobjects\n    * [ingredient](../../subobjects/ingredient)\n    * [software_configuration](../../subobjects/software_configuration)\n    * [property](../../subobjects/property)\n    * [condition](../../subobjects/condition)\n    * [citation](../../subobjects/citation)\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my computational process node name\",\n       \"node\":[\"ComputationProcess\"],\n       \"type\":\"cross_linking\",\n       \"uid\":\"_:b88ac0a5-b5c0-4197-a63d-b37e1fe8c6c6\",\n       \"uuid\":\"b88ac0a5-b5c0-4197-a63d-b37e1fe8c6c6\"\n       \"ingredient\":[\n          {\n            \"node\":[\"Ingredient\"],\n            \"uid\":\"_:f68d6fff-9327-48b1-9249-33ce498005e8\",\n             \"uuid\":\"f68d6fff-9327-48b1-9249-33ce498005e8\"\n             \"keyword\":[\"catalyst\"],\n             \"material\":{\n                \"name\":\"my material name\",\n                \"node\":[\"Material\"],\n                \"uid\":\"_:3b12f92c-2121-4520-920e-b4c5622de34a\",\n                \"uuid\":\"3b12f92c-2121-4520-920e-b4c5622de34a\",\n                \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n             },\n\n             \"quantity\":[\n                {\n                   \"key\":\"mass\",\n                   \"node\":[\"Quantity\"],\n                   \"uid\":\"_:07c4a6a9-9385-4505-a30a-ca3549cedcd8\",\n                   \"uuid\":\"07c4a6a9-9385-4505-a30a-ca3549cedcd8\",\n                   \"uncertainty\":0.2,\n                   \"uncertainty_type\":\"stdev\",\n                   \"unit\":\"kg\",\n                   \"value\":11.2\n                }\n             ]\n          }\n       ],\n       \"input_data\":[\n          {\n            \"name\":\"my data name\",\n             \"node\":[\"Data\"],\n             \"type\":\"afm_amp\",\n             \"uid\":\"_:3c16bb05-ded1-4f52-9d02-c88c1a1de915\",\n             \"uuid\":\"3c16bb05-ded1-4f52-9d02-c88c1a1de915\"\n             \"file\":[\n                {\n                   \"name\":\"my file node name\",\n                   \"node\":[\"File\"],\n                   \"source\":\"https://criptapp.org\",\n                   \"type\":\"calibration\",\n                    \"data_dictionary\":\"my file's data dictionary\",\n                   \"extension\":\".csv\",\n                   \"uid\":\"_:ee8153db-4108-49e4-8c5b-ffc26d4e6f71\",\n                   \"uuid\":\"ee8153db-4108-49e4-8c5b-ffc26d4e6f71\"\n                }\n             ],\n          }\n       ],\n    }\n    ```\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all computational_process nodes attributes\n        \"\"\"\n\n        type: str = \"\"\n        # TODO add proper typing in future, using Any for now to avoid circular import error\n        input_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        output_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        ingredient: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        software_configuration: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        condition: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        property: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        name: str,\n        type: str,\n        input_data: List[Union[Any, UIDProxy]],\n        ingredient: List[Union[Any, UIDProxy]],\n        output_data: Optional[List[Union[Any, UIDProxy]]] = None,\n        software_configuration: Optional[List[Union[Any, UIDProxy]]] = None,\n        condition: Optional[List[Union[Any, UIDProxy]]] = None,\n        property: Optional[List[Union[Any, UIDProxy]]] = None,\n        citation: Optional[List[Union[Any, UIDProxy]]] = None,\n        notes: str = \"\",\n        **kwargs\n    ):\n        \"\"\"\n        create a computational_process node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; data_files = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; input_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[data_files])\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...     name=\"my material\",\n        ...     names = [\"my material alternative name\"]\n        ... )\n        &gt;&gt;&gt; my_quantity = cript.Quantity(key=\"mass\", value=1.23, unit=\"kg\")\n        &gt;&gt;&gt; ingredient = cript.Ingredient(\n        ...     material=my_material,\n        ...     quantity=[my_quantity],\n        ... )\n        &gt;&gt;&gt; my_computation_process = cript.ComputationProcess(\n        ...     name=\"my computational process name\",\n        ...     type=\"cross_linking\",\n        ...     input_data=[input_data],\n        ...     ingredient=[ingredient],\n        ... )\n\n\n        Parameters\n        ----------\n        name: str\n            computational process name\n        type: str\n            type of computation process from CRIPT controlled vocabulary\n        input_data: List[Data]\n            list of input data for computational process\n        ingredient: List[Ingredient]\n            list of ingredients for this computational process node\n        output_data: List[Data] default=None\n            list of output data for this computational process node\n        software_configuration: List[SoftwareConfiguration] default=None\n            list of software configurations for this computational process node\n        condition: List[Condition] default=None\n            list of condition for this computational process node\n        property: List[Property] default=None\n            list of properties for this computational process node\n        citation: List[Citation] default=None\n            list of citation for this computational process node\n        notes: str default=\"\"\n            optional notes for the computational process node\n\n        Returns\n        -------\n        None\n            instantiate computationalProcess node\n        \"\"\"\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        if input_data is None:\n            input_data = []\n\n        if ingredient is None:\n            ingredient = []\n\n        if output_data is None:\n            output_data = []\n\n        if software_configuration is None:\n            software_configuration = []\n\n        if condition is None:\n            condition = []\n\n        if property is None:\n            property = []\n\n        if citation is None:\n            citation = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            type=type,\n            input_data=input_data,\n            ingredient=ingredient,\n            output_data=output_data,\n            software_configuration=software_configuration,\n            condition=condition,\n            property=property,\n            citation=citation,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        The [computational process type](https://app.criptapp.org/vocab/computational_process_type)\n        must come from CRIPT Controlled vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computation_process.type = \"DPD\"   # doctest: +SKIP\n\n        Returns\n        -------\n        str\n            computational process type\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_type: str) -&gt; None:\n        \"\"\"\n        set the computational_process type\n\n        computational_process type must come from CRIPT controlled vocabulary\n\n        Parameters\n        ----------\n        new_type: str\n            new computational process type.\n            computational process type must come from CRIPT controlled vocabulary\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def input_data(self) -&gt; List[Any]:\n        \"\"\"\n        List of input data for the computational process node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     data_dictionary=\"my file's data dictionary\",\n        ...     extension=\".csv\",\n        ... )\n        &gt;&gt;&gt; my_input_data = cript.Data(name=\"my input data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_computation_process.input_data = [my_input_data]     # doctest: +SKIP\n\n        Returns\n        -------\n        List[Data]\n            list of input data for this computational process node\n        \"\"\"\n        return self._json_attrs.input_data.copy()\n\n    @input_data.setter\n    @beartype\n    def input_data(self, new_input_data_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the input data for this computational process\n\n        Parameters\n        ----------\n        new_input_data_list: List[Data]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, input_data=new_input_data_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def output_data(self) -&gt; List[Any]:\n        \"\"\"\n        List of the output data for the computational_process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_output_data = cript.Data(name=\"my output data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_computation_process.output_data = [my_output_data]    # doctest: +SKIP\n\n        Returns\n        -------\n        List[Data]\n            list of output data from this computational process node\n        \"\"\"\n        return self._json_attrs.output_data.copy()\n\n    @output_data.setter\n    @beartype\n    def output_data(self, new_output_data_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the output_data list for the computational_process\n\n        Parameters\n        ----------\n        new_output_data_list: List[Data]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, output_data=new_output_data_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def ingredient(self) -&gt; List[Any]:\n        \"\"\"\n        List of ingredients for the computational_process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"my bigsmiles\")\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n        ... )\n        &gt;&gt;&gt; my_computation_process.ingredient = [my_ingredient]   # doctest: +SKIP\n\n        Returns\n        -------\n        List[Ingredient]\n            list of ingredients for this computational process\n        \"\"\"\n        return self._json_attrs.ingredient.copy()\n\n    @ingredient.setter\n    @beartype\n    def ingredient(self, new_ingredient_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the ingredients list for this computational process\n\n        Parameters\n        ----------\n        new_ingredient_list: List[Ingredient]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, ingredient=new_ingredient_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def software_configuration(self) -&gt; List[Any]:\n        \"\"\"\n        List of software_configuration for the computational process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n        &gt;&gt;&gt; my_computation_process.software_configuration = [my_software_configuration]   # doctest: +SKIP\n\n        Returns\n        -------\n        List[SoftwareConfiguration]\n            List of software configurations used for this computational process node\n        \"\"\"\n        return self._json_attrs.software_configuration.copy()\n\n    @software_configuration.setter\n    @beartype\n    def software_configuration(self, new_software_configuration_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of software_configuration for the computational process\n\n        Parameters\n        ----------\n        new_software_configuration_list: List[SoftwareConfiguration]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, software_configuration=new_software_configuration_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def condition(self) -&gt; List[Any]:\n        \"\"\"\n        List of condition for the computational process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"min\", value=1)\n        &gt;&gt;&gt; my_computation_process.condition = [my_condition]     # doctest: +SKIP\n\n        Returns\n        -------\n        List[Condition]\n            list of condition for this computational process node\n        \"\"\"\n        return self._json_attrs.condition.copy()\n\n    @condition.setter\n    @beartype\n    def condition(self, new_condition: List[Any]) -&gt; None:\n        \"\"\"\n        set the condition for the computational process\n\n        Parameters\n        ----------\n        new_condition: List[Condition]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, condition=new_condition)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Any]:\n        \"\"\"\n        List of citation for the computational process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n        &gt;&gt;&gt; my_computation_process.citation = [my_citation]     # doctest: +SKIP\n\n        Returns\n        -------\n        List[Citation]\n            list of citation for this computational process\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the citation list for the computational process node\n\n        Parameters\n        ----------\n        new_citation_list: List[Citation]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def property(self) -&gt; List[Any]:\n        \"\"\"\n        List of properties\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.23, unit=\"J\")\n        &gt;&gt;&gt; my_computation_process.property = [my_property]     # doctest: +SKIP\n\n        Returns\n        -------\n        List[Property]\n            list of properties for this computational process node\n        \"\"\"\n        return self._json_attrs.property.copy()\n\n    @property.setter\n    @beartype\n    def property(self, new_property_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the properties list for the computational process\n\n        Parameters\n        ----------\n        new_property_list: List[Property]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, property=new_property_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.citation","title":"<code>citation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of citation for the computational process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n&gt;&gt;&gt; my_computation_process.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of citation for this computational process</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.condition","title":"<code>condition: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of condition for the computational process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"min\", value=1)\n&gt;&gt;&gt; my_computation_process.condition = [my_condition]\n</code></pre> <p>Returns:</p> Type Description <code>List[Condition]</code> <p>list of condition for this computational process node</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.ingredient","title":"<code>ingredient: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of ingredients for the computational_process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"my bigsmiles\")\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient = cript.Ingredient(\n...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n... )\n&gt;&gt;&gt; my_computation_process.ingredient = [my_ingredient]\n</code></pre> <p>Returns:</p> Type Description <code>List[Ingredient]</code> <p>list of ingredients for this computational process</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.input_data","title":"<code>input_data: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of input data for the computational process node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     data_dictionary=\"my file's data dictionary\",\n...     extension=\".csv\",\n... )\n&gt;&gt;&gt; my_input_data = cript.Data(name=\"my input data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_computation_process.input_data = [my_input_data]\n</code></pre> <p>Returns:</p> Type Description <code>List[Data]</code> <p>list of input data for this computational process node</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.output_data","title":"<code>output_data: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of the output data for the computational_process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_output_data = cript.Data(name=\"my output data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_computation_process.output_data = [my_output_data]\n</code></pre> <p>Returns:</p> Type Description <code>List[Data]</code> <p>list of output data from this computational process node</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.property","title":"<code>property: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of properties</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.23, unit=\"J\")\n&gt;&gt;&gt; my_computation_process.property = [my_property]\n</code></pre> <p>Returns:</p> Type Description <code>List[Property]</code> <p>list of properties for this computational process node</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.software_configuration","title":"<code>software_configuration: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of software_configuration for the computational process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n&gt;&gt;&gt; my_computation_process.software_configuration = [my_software_configuration]\n</code></pre> <p>Returns:</p> Type Description <code>List[SoftwareConfiguration]</code> <p>List of software configurations used for this computational process node</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>The computational process type must come from CRIPT Controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computation_process.type = \"DPD\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>computational process type</p>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all computational_process nodes attributes</p> Source code in <code>src/cript/nodes/primary_nodes/computation_process.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all computational_process nodes attributes\n    \"\"\"\n\n    type: str = \"\"\n    # TODO add proper typing in future, using Any for now to avoid circular import error\n    input_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    output_data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    ingredient: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    software_configuration: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    condition: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    property: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/computation_process/#cript.nodes.primary_nodes.computation_process.ComputationProcess.__init__","title":"<code>__init__(name, type, input_data, ingredient, output_data=None, software_configuration=None, condition=None, property=None, citation=None, notes='', **kwargs)</code>","text":"<p>create a computational_process node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; data_files = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; input_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[data_files])\n&gt;&gt;&gt; my_material = cript.Material(\n...     name=\"my material\",\n...     names = [\"my material alternative name\"]\n... )\n&gt;&gt;&gt; my_quantity = cript.Quantity(key=\"mass\", value=1.23, unit=\"kg\")\n&gt;&gt;&gt; ingredient = cript.Ingredient(\n...     material=my_material,\n...     quantity=[my_quantity],\n... )\n&gt;&gt;&gt; my_computation_process = cript.ComputationProcess(\n...     name=\"my computational process name\",\n...     type=\"cross_linking\",\n...     input_data=[input_data],\n...     ingredient=[ingredient],\n... )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>computational process name</p> required <code>type</code> <code>str</code> <p>type of computation process from CRIPT controlled vocabulary</p> required <code>input_data</code> <code>List[Union[Any, UIDProxy]]</code> <p>list of input data for computational process</p> required <code>ingredient</code> <code>List[Union[Any, UIDProxy]]</code> <p>list of ingredients for this computational process node</p> required <code>output_data</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of output data for this computational process node</p> <code>None</code> <code>software_configuration</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of software configurations for this computational process node</p> <code>None</code> <code>condition</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of condition for this computational process node</p> <code>None</code> <code>property</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of properties for this computational process node</p> <code>None</code> <code>citation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of citation for this computational process node</p> <code>None</code> <code>notes</code> <code>str</code> <p>optional notes for the computational process node</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>instantiate computationalProcess node</p> Source code in <code>src/cript/nodes/primary_nodes/computation_process.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    name: str,\n    type: str,\n    input_data: List[Union[Any, UIDProxy]],\n    ingredient: List[Union[Any, UIDProxy]],\n    output_data: Optional[List[Union[Any, UIDProxy]]] = None,\n    software_configuration: Optional[List[Union[Any, UIDProxy]]] = None,\n    condition: Optional[List[Union[Any, UIDProxy]]] = None,\n    property: Optional[List[Union[Any, UIDProxy]]] = None,\n    citation: Optional[List[Union[Any, UIDProxy]]] = None,\n    notes: str = \"\",\n    **kwargs\n):\n    \"\"\"\n    create a computational_process node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; data_files = cript.File(\n    ...     name=\"my file node name\",\n    ...     source=\"https://criptapp.org\",\n    ...     type=\"calibration\",\n    ...     extension=\".csv\",\n    ...     data_dictionary=\"my file's data dictionary\"\n    ... )\n    &gt;&gt;&gt; input_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[data_files])\n    &gt;&gt;&gt; my_material = cript.Material(\n    ...     name=\"my material\",\n    ...     names = [\"my material alternative name\"]\n    ... )\n    &gt;&gt;&gt; my_quantity = cript.Quantity(key=\"mass\", value=1.23, unit=\"kg\")\n    &gt;&gt;&gt; ingredient = cript.Ingredient(\n    ...     material=my_material,\n    ...     quantity=[my_quantity],\n    ... )\n    &gt;&gt;&gt; my_computation_process = cript.ComputationProcess(\n    ...     name=\"my computational process name\",\n    ...     type=\"cross_linking\",\n    ...     input_data=[input_data],\n    ...     ingredient=[ingredient],\n    ... )\n\n\n    Parameters\n    ----------\n    name: str\n        computational process name\n    type: str\n        type of computation process from CRIPT controlled vocabulary\n    input_data: List[Data]\n        list of input data for computational process\n    ingredient: List[Ingredient]\n        list of ingredients for this computational process node\n    output_data: List[Data] default=None\n        list of output data for this computational process node\n    software_configuration: List[SoftwareConfiguration] default=None\n        list of software configurations for this computational process node\n    condition: List[Condition] default=None\n        list of condition for this computational process node\n    property: List[Property] default=None\n        list of properties for this computational process node\n    citation: List[Citation] default=None\n        list of citation for this computational process node\n    notes: str default=\"\"\n        optional notes for the computational process node\n\n    Returns\n    -------\n    None\n        instantiate computationalProcess node\n    \"\"\"\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    if input_data is None:\n        input_data = []\n\n    if ingredient is None:\n        ingredient = []\n\n    if output_data is None:\n        output_data = []\n\n    if software_configuration is None:\n        software_configuration = []\n\n    if condition is None:\n        condition = []\n\n    if property is None:\n        property = []\n\n    if citation is None:\n        citation = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        type=type,\n        input_data=input_data,\n        ingredient=ingredient,\n        output_data=output_data,\n        software_configuration=software_configuration,\n        condition=condition,\n        property=property,\n        citation=citation,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/data/","title":"Data","text":""},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data","title":"<code>Data</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data--definition","title":"Definition","text":"<p>A Data node  node contains the meta-data to describe raw data that is beyond a single value, (i.e. n-dimensional data).  Each <code>Data</code> node must be linked to a single <code>Experiment</code> node.</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data--available-sub-objects","title":"Available Sub-Objects","text":"<ul> <li>Citation</li> </ul>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data--attributes","title":"Attributes","text":"Attribute Type Example Description Required name str <code>\"my_data_name\"</code> Name of the data node True type str <code>\"nmr_h1\"</code> Pick from CRIPT data type controlled vocabulary True file List[File] <code>[file_1, file_2, file_3]</code> list of file nodes False sample_preparation Process False computation List[Computation] data produced from this Computation method False computation_process Computational Process data was produced from this computation process False material List[Material] materials with attributes associated with the data node False process List[Process] processes with attributes associated with the data node False citation Citation reference to a book, paper, or scholarly work False notes str \"my awesome notes\" miscellaneous information, or custom data structure False <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n</code></pre>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my data name\",\n   \"node\":[\"Data\"],\n   \"type\":\"afm_amp\",\n   \"uid\":\"_:80b02470-73d0-416e-8d93-12fdf69e481a\",\n   \"uuid\":\"80b02470-73d0-416e-8d93-12fdf69e481a\"\n   \"file\":[\n      {\n        \"node\":[\"File\"],\n        \"name\":\"my file node name\",\n         \"uid\":\"_:535779ea-0d1f-4b23-b3e8-60052f717307\",\n         \"uuid\":\"535779ea-0d1f-4b23-b3e8-60052f717307\"\n         \"type\":\"calibration\",\n         \"source\":\"https://criptapp.org\",\n         \"extension\":\".csv\",\n         \"data_dictionary\":\"my file's data dictionary\",\n      }\n   ]\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/data.py</code> <pre><code>class Data(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n    A [Data node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=13)\n     node contains the meta-data to describe raw data that is beyond a single value, (i.e. n-dimensional data).\n     Each `Data` node must be linked to a single `Experiment` node.\n\n    ## Available Sub-Objects\n    * [Citation](../../subobjects/citation)\n\n    ## Attributes\n    | Attribute           | Type                                              | Example                    | Description                                                                                  | Required |\n    |---------------------|---------------------------------------------------|----------------------------|----------------------------------------------------------------------------------------------|----------|\n    | name                | str                                               | `\"my_data_name\"`           | Name of the data node                                                                        | True     |\n    | type                | str                                               | `\"nmr_h1\"`                 | Pick from [CRIPT data type controlled vocabulary](https://app.criptapp.org/vocab/data_type/) | True     |\n    | file                | List[[File](../supporting_nodes/file.md)]         | `[file_1, file_2, file_3]` | list of file nodes                                                                           | False    |\n    | sample_preparation  | [Process](process.md)                             |                            |                                                                                              | False    |\n    | computation         | List[[Computation](computation.md)]               |                            | data produced from this Computation method                                                   | False    |\n    | computation_process | [Computational Process](./computation_process.md) |                            | data was produced from this computation process                                              | False    |\n    | material            | List[[Material](./material.md)]                   |                            | materials with attributes associated with the data node                                      | False    |\n    | process             | List[[Process](./process.md)]                     |                            | processes with attributes associated with the data node                                      | False    |\n    | citation            | [Citation](../subobjects/citation.md)             |                            | reference to a book, paper, or scholarly work                                                | False    |\n    | notes               | str                                               | \"my awesome notes\"         | miscellaneous information, or custom data structure                                          | False    |\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_file = cript.File(\n    ...    name=\"my file node name\",\n    ...    source=\"https://criptapp.org\",\n    ...    type=\"calibration\",\n    ...    extension=\".csv\",\n    ...    data_dictionary=\"my file's data dictionary\"\n    ... )\n    &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my data name\",\n       \"node\":[\"Data\"],\n       \"type\":\"afm_amp\",\n       \"uid\":\"_:80b02470-73d0-416e-8d93-12fdf69e481a\",\n       \"uuid\":\"80b02470-73d0-416e-8d93-12fdf69e481a\"\n       \"file\":[\n          {\n            \"node\":[\"File\"],\n            \"name\":\"my file node name\",\n             \"uid\":\"_:535779ea-0d1f-4b23-b3e8-60052f717307\",\n             \"uuid\":\"535779ea-0d1f-4b23-b3e8-60052f717307\"\n             \"type\":\"calibration\",\n             \"source\":\"https://criptapp.org\",\n             \"extension\":\".csv\",\n             \"data_dictionary\":\"my file's data dictionary\",\n          }\n       ]\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Data attributes\n        \"\"\"\n\n        type: str = \"\"\n        # TODO add proper typing in future, using Any for now to avoid circular import error\n        file: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        sample_preparation: Union[Any, UIDProxy] = field(default_factory=list)\n        computation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        computation_process: Union[Any, UIDProxy] = field(default_factory=list)\n        material: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        process: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        name: str,\n        type: str,\n        file: List[Union[Any, UIDProxy]],\n        sample_preparation: Union[Any, UIDProxy] = None,\n        computation: Optional[List[Union[Any, UIDProxy]]] = None,\n        computation_process: Optional[Union[Any, UIDProxy]] = None,\n        material: Optional[List[Union[Any, UIDProxy]]] = None,\n        process: Optional[List[Union[Any, UIDProxy]]] = None,\n        citation: Optional[List[Union[Any, UIDProxy]]] = None,\n        notes: str = \"\",\n        **kwargs\n    ) -&gt; None:\n        \"\"\"\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n        ...      type=\"calibration\",\n        ...      extension=\".pdf\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(\n        ...     name=\"my data node name\",\n        ...     type=\"afm_amp\",\n        ...     file=[my_file],\n        ... )\n\n        Parameters\n        ----------\n        name: str\n            data node name\n        type: str\n            [data type](https://app.criptapp.org/vocab/data_type) must come from CRIPT controlled vocabulary\n        file: List[File], default None\n            list of CRIPT file nodes within the data node\n        sample_preparation: Process, default None\n            sample preparation\n        computation: Optional[Computation], default None\n            data was produced from this computation method\n        computation_process: Optional[ComputationalProcess], default None\n            data was produced from this computation process\n        material: Optional[List[Material]], default None\n            materials with attributes associated with the data node\n        process: Optional[List[Process]], default None\n            processes with attributes associated with the data node\n        citation: Optional[List[Citation]], default None\n            reference to a book, paper, or scholarly work\n        notes: str, default \"\"\n            miscellaneous information, or custom data structure\n        kwargs\n            used for deserializing JSON into Python SDK nodes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        if file is None:\n            file = []\n\n        if sample_preparation is None:\n            sample_preparation = []\n\n        if computation is None:\n            computation = []\n\n        if computation_process is None:\n            computation_process = []\n\n        if material is None:\n            material = []\n\n        if process is None:\n            process = []\n\n        if citation is None:\n            citation = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            type=type,\n            file=file,\n            sample_preparation=sample_preparation,\n            computation=computation,\n            computation_process=computation_process,\n            material=material,\n            process=process,\n            citation=citation,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        The data type must come from [CRIPT data type vocabulary](https://app.criptapp.org/vocab/data_type)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_data.type = \"nmr_h1\"\n\n        Returns\n        -------\n        data type: str\n            data type for the data node must come from CRIPT controlled vocabulary\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_data_type: str) -&gt; None:\n        \"\"\"\n        set the data type.\n        The data type must come from [CRIPT data type vocabulary](https://app.criptapp.org/vocab/data_type)\n\n        Parameters\n        ----------\n        new_data_type: str\n            new data type to replace the current data type\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_data_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def file(self) -&gt; List[Any]:\n        \"\"\"\n        get the list of [files](../../supporting_nodes/file) for this data node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_new_file = cript.File(\n        ...    name=\"my new file node name\",\n        ...    source=\"path/to/local/file\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data.file += [my_new_file]\n\n        Returns\n        -------\n        List[File]\n            list of files for this data node\n        \"\"\"\n        return self._json_attrs.file.copy()\n\n    @file.setter\n    @beartype\n    def file(self, new_file_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of file for this data node\n\n        Parameters\n        ----------\n        new_files_list: List[File]\n            new list of file nodes to replace the current list\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, file=new_file_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def sample_preparation(self) -&gt; Union[Any, None]:\n        \"\"\"\n        The [sample preparation](../process) for this data node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_new_files = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://pubs.acs.org/doi/10.1021/acscentsci.3c00011\",\n        ...     type=\"computation_config\",\n        ...     extension=\".pdf\",\n        ...     data_dictionary=\"my data dictionary\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_new_files])\n        &gt;&gt;&gt; my_sample_preparation = cript.Process(name=\"my sample preparation name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_data.sample_preparation = my_sample_preparation\n\n        Returns\n        -------\n        sample_preparation: Process\n            sample preparation for this data node\n        \"\"\"\n        return self._json_attrs.sample_preparation\n\n    @sample_preparation.setter\n    @beartype\n    def sample_preparation(self, new_sample_preparation: Union[Any, None]) -&gt; None:\n        \"\"\"\n        set sample_preparation\n\n        Parameters\n        ----------\n        new_sample_preparation: Process\n            new_sample_preparation to replace the current one for this node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, sample_preparation=new_sample_preparation)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def computation(self) -&gt; List[Any]:\n        \"\"\"\n        list of [computation nodes](../computation/) for this material node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_data.computation = [my_computation]\n\n        Returns\n        -------\n        None\n            list of computation nodes\n        \"\"\"\n        return self._json_attrs.computation.copy()\n\n    @computation.setter\n    @beartype\n    def computation(self, new_computation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set list of computation  for this data node\n\n        Parameters\n        ----------\n        new_computation_list: List[Computation]\n            new computation list to replace the current one\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, computation=new_computation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def computation_process(self) -&gt; Union[Any, None]:\n        \"\"\"\n        The [computation_process](../computation_process) for this data node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(\n        ...     name=\"my data name\",\n        ...     type=\"afm_amp\",\n        ...     file=[my_file]\n        ... )\n        &gt;&gt;&gt; my_file_for_second_data_node = cript.File(\n        ...     name=\"my second file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_second_data_node = cript.Data(\n        ...     name=\"my data name\",\n        ...     type=\"afm_amp\",\n        ...     file=[my_file_for_second_data_node]\n        ... )\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...     name=\"my material name\",\n        ...     bigsmiles = \"123456\"\n        ... )\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ...     material=my_material,\n        ...     quantity=[my_quantity],\n        ...     keyword=[\"catalyst\"],\n        ... )\n        &gt;&gt;&gt; my_computational_process = cript.ComputationProcess(\n        ...     name=\"my computational process node name\",\n        ...     type=\"cross_linking\",\n        ...     input_data=[my_second_data_node],\n        ...     ingredient=[my_ingredient],\n        ... )\n\n        Returns\n        -------\n        ComputationalProcess\n            computational process node for this data node\n        \"\"\"\n        return self._json_attrs.computation_process\n\n    @computation_process.setter\n    @beartype\n    def computation_process(self, new_computation_process: Union[Any, None]) -&gt; None:\n        \"\"\"\n        set the computational process\n\n        Parameters\n        ----------\n        new_computation_process: ComputationalProcess\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, computation_process=new_computation_process)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def material(self) -&gt; List[Any]:\n        \"\"\"\n        List of [materials](../material) for this node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material name\", bigsmiles = \"123456\")\n        &gt;&gt;&gt; my_data.material = [my_material]\n\n        Returns\n        -------\n        List[Material]\n            list of material\n        \"\"\"\n        return self._json_attrs.material.copy()\n\n    @material.setter\n    @beartype\n    def material(self, new_material_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of materials for this data node\n\n        Parameters\n        ----------\n        new_material_list: List[Material]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, material=new_material_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def process(self) -&gt; List[Any]:\n        \"\"\"\n        list of [Process nodes](./process.md) for this data node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_data.process = [my_process]\n\n        Notes\n        -----\n        Please note that while the process attribute of the data node is currently set to `Any`\n        the software still expects a Process node in the data's process attribute\n        &gt; It is currently set to `Any` to avoid the circular import error\n\n        Returns\n        -------\n        List[Process]\n            list of process for the data node\n        \"\"\"\n        return self._json_attrs.process.copy()\n\n    @process.setter\n    @beartype\n    def process(self, new_process_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of process for this data node\n\n        Parameters\n        ----------\n        new_process_list: List[Process]\n            new list of Process\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, process=new_process_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Any]:\n        \"\"\"\n        List of [citation](../../subobjects/citation) within the data node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\"\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n        &gt;&gt;&gt; my_data.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of citations for this data node\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of citation\n\n        Parameters\n        ----------\n        new_citation_list: List[Citation]\n            new list of citation to replace the current one\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.citation","title":"<code>citation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of citation within the data node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n&gt;&gt;&gt; my_data.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of citations for this data node</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.computation","title":"<code>computation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>list of computation nodes for this material node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_data.computation = [my_computation]\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>list of computation nodes</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.computation_process","title":"<code>computation_process: Union[Any, None]</code>  <code>property</code> <code>writable</code>","text":"<p>The computation_process for this data node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(\n...     name=\"my data name\",\n...     type=\"afm_amp\",\n...     file=[my_file]\n... )\n&gt;&gt;&gt; my_file_for_second_data_node = cript.File(\n...     name=\"my second file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_second_data_node = cript.Data(\n...     name=\"my data name\",\n...     type=\"afm_amp\",\n...     file=[my_file_for_second_data_node]\n... )\n&gt;&gt;&gt; my_material = cript.Material(\n...     name=\"my material name\",\n...     bigsmiles = \"123456\"\n... )\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient = cript.Ingredient(\n...     material=my_material,\n...     quantity=[my_quantity],\n...     keyword=[\"catalyst\"],\n... )\n&gt;&gt;&gt; my_computational_process = cript.ComputationProcess(\n...     name=\"my computational process node name\",\n...     type=\"cross_linking\",\n...     input_data=[my_second_data_node],\n...     ingredient=[my_ingredient],\n... )\n</code></pre> <p>Returns:</p> Type Description <code>ComputationalProcess</code> <p>computational process node for this data node</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.file","title":"<code>file: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>get the list of files for this data node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_new_file = cript.File(\n...    name=\"my new file node name\",\n...    source=\"path/to/local/file\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data.file += [my_new_file]\n</code></pre> <p>Returns:</p> Type Description <code>List[File]</code> <p>list of files for this data node</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.material","title":"<code>material: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of materials for this node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material name\", bigsmiles = \"123456\")\n&gt;&gt;&gt; my_data.material = [my_material]\n</code></pre> <p>Returns:</p> Type Description <code>List[Material]</code> <p>list of material</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.process","title":"<code>process: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Process nodes for this data node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_data.process = [my_process]\n</code></pre> Notes <p>Please note that while the process attribute of the data node is currently set to <code>Any</code> the software still expects a Process node in the data's process attribute</p> <p>It is currently set to <code>Any</code> to avoid the circular import error</p> <p>Returns:</p> Type Description <code>List[Process]</code> <p>list of process for the data node</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.sample_preparation","title":"<code>sample_preparation: Union[Any, None]</code>  <code>property</code> <code>writable</code>","text":"<p>The sample preparation for this data node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_new_files = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://pubs.acs.org/doi/10.1021/acscentsci.3c00011\",\n...     type=\"computation_config\",\n...     extension=\".pdf\",\n...     data_dictionary=\"my data dictionary\",\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_new_files])\n&gt;&gt;&gt; my_sample_preparation = cript.Process(name=\"my sample preparation name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_data.sample_preparation = my_sample_preparation\n</code></pre> <p>Returns:</p> Name Type Description <code>sample_preparation</code> <code>Process</code> <p>sample preparation for this data node</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>The data type must come from CRIPT data type vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\"\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_data.type = \"nmr_h1\"\n</code></pre> <p>Returns:</p> Type Description <code>data type: str</code> <p>data type for the data node must come from CRIPT controlled vocabulary</p>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Data attributes</p> Source code in <code>src/cript/nodes/primary_nodes/data.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Data attributes\n    \"\"\"\n\n    type: str = \"\"\n    # TODO add proper typing in future, using Any for now to avoid circular import error\n    file: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    sample_preparation: Union[Any, UIDProxy] = field(default_factory=list)\n    computation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    computation_process: Union[Any, UIDProxy] = field(default_factory=list)\n    material: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    process: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/data/#cript.nodes.primary_nodes.data.Data.__init__","title":"<code>__init__(name, type, file, sample_preparation=None, computation=None, computation_process=None, material=None, process=None, citation=None, notes='', **kwargs)</code>","text":"<p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n...      type=\"calibration\",\n...      extension=\".pdf\",\n... )\n&gt;&gt;&gt; my_data = cript.Data(\n...     name=\"my data node name\",\n...     type=\"afm_amp\",\n...     file=[my_file],\n... )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>data node name</p> required <code>type</code> <code>str</code> <p>data type must come from CRIPT controlled vocabulary</p> required <code>file</code> <code>List[Union[Any, UIDProxy]]</code> <p>list of CRIPT file nodes within the data node</p> required <code>sample_preparation</code> <code>Union[Any, UIDProxy]</code> <p>sample preparation</p> <code>None</code> <code>computation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>data was produced from this computation method</p> <code>None</code> <code>computation_process</code> <code>Optional[Union[Any, UIDProxy]]</code> <p>data was produced from this computation process</p> <code>None</code> <code>material</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>materials with attributes associated with the data node</p> <code>None</code> <code>process</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>processes with attributes associated with the data node</p> <code>None</code> <code>citation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>reference to a book, paper, or scholarly work</p> <code>None</code> <code>notes</code> <code>str</code> <p>miscellaneous information, or custom data structure</p> <code>''</code> <code>kwargs</code> <p>used for deserializing JSON into Python SDK nodes</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/primary_nodes/data.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    name: str,\n    type: str,\n    file: List[Union[Any, UIDProxy]],\n    sample_preparation: Union[Any, UIDProxy] = None,\n    computation: Optional[List[Union[Any, UIDProxy]]] = None,\n    computation_process: Optional[Union[Any, UIDProxy]] = None,\n    material: Optional[List[Union[Any, UIDProxy]]] = None,\n    process: Optional[List[Union[Any, UIDProxy]]] = None,\n    citation: Optional[List[Union[Any, UIDProxy]]] = None,\n    notes: str = \"\",\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_file = cript.File(\n    ...     name=\"my file node name\",\n    ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n    ...      type=\"calibration\",\n    ...      extension=\".pdf\",\n    ... )\n    &gt;&gt;&gt; my_data = cript.Data(\n    ...     name=\"my data node name\",\n    ...     type=\"afm_amp\",\n    ...     file=[my_file],\n    ... )\n\n    Parameters\n    ----------\n    name: str\n        data node name\n    type: str\n        [data type](https://app.criptapp.org/vocab/data_type) must come from CRIPT controlled vocabulary\n    file: List[File], default None\n        list of CRIPT file nodes within the data node\n    sample_preparation: Process, default None\n        sample preparation\n    computation: Optional[Computation], default None\n        data was produced from this computation method\n    computation_process: Optional[ComputationalProcess], default None\n        data was produced from this computation process\n    material: Optional[List[Material]], default None\n        materials with attributes associated with the data node\n    process: Optional[List[Process]], default None\n        processes with attributes associated with the data node\n    citation: Optional[List[Citation]], default None\n        reference to a book, paper, or scholarly work\n    notes: str, default \"\"\n        miscellaneous information, or custom data structure\n    kwargs\n        used for deserializing JSON into Python SDK nodes\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    if file is None:\n        file = []\n\n    if sample_preparation is None:\n        sample_preparation = []\n\n    if computation is None:\n        computation = []\n\n    if computation_process is None:\n        computation_process = []\n\n    if material is None:\n        material = []\n\n    if process is None:\n        process = []\n\n    if citation is None:\n        citation = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        type=type,\n        file=file,\n        sample_preparation=sample_preparation,\n        computation=computation,\n        computation_process=computation_process,\n        material=material,\n        process=process,\n        citation=citation,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/experiment/","title":"Experiment","text":""},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment","title":"<code>Experiment</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment--definition","title":"Definition","text":"<p>An Experiment node is nested inside a Collection node.</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment--attributes","title":"Attributes","text":"attribute type description required collection Collection collection associated with the experiment True process List[Process] process nodes associated with this experiment False computations List[Computation] computation method nodes associated with this experiment False computation_process List[Computational  Process] computation process nodes associated with this experiment False data List[Data] data nodes associated with this experiment False funding List[str] funding source for experiment False citation List[Citation] reference to a book, paper, or scholarly work False notes str miscellaneous information, or custom data structure False"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment--sub-objects","title":"Sub-objects","text":"<p>An Experiment node can be thought as a folder/bucket that can hold:</p> <ul> <li>Process</li> <li>Computations</li> <li>Computation_Process</li> <li>Data</li> <li>Funding</li> <li>Citation</li> </ul> Warnings <p>Experiment names</p> <p>Experiment names MUST be unique within a Collection</p> Source code in <code>src/cript/nodes/primary_nodes/experiment.py</code> <pre><code>class Experiment(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n    An\n    [Experiment node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=9)\n    is nested inside a [Collection](../collection) node.\n\n    ## Attributes\n\n    | attribute           | type                         | description                                               | required |\n    |---------------------|------------------------------|-----------------------------------------------------------|----------|\n    | collection          | Collection                   | collection associated with the experiment                 | True     |\n    | process             | List[Process]                | process nodes associated with this experiment             | False    |\n    | computations        | List[Computation]            | computation method nodes associated with this experiment  | False    |\n    | computation_process | List[Computational  Process] | computation process nodes associated with this experiment | False    |\n    | data                | List[Data]                   | data nodes associated with this experiment                | False    |\n    | funding             | List[str]                    | funding source for experiment                             | False    |\n    | citation            | List[Citation]               | reference to a book, paper, or scholarly work             | False    |\n    | notes               | str                          | miscellaneous information, or custom data structure       | False    |\n\n\n    ## Sub-objects\n    An\n    [Experiment node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=9)\n    can be thought as a folder/bucket that can hold:\n\n    * [Process](../process)\n    * [Computations](../computation)\n    * [Computation_Process](../computation_process)\n    * [Data](../data)\n    * [Funding](./#cript.nodes.primary_nodes.experiment.Experiment.funding)\n    * [Citation](../../subobjects/citation)\n\n\n    Warnings\n    --------\n    !!! warning \"Experiment names\"\n        Experiment names **MUST** be unique within a [Collection](../collection)\n\n    ---\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my experiment name\",\n       \"node\":[\"Experiment\"],\n       \"uid\":\"_:886c4deb-2186-4f11-8134-a37111200b83\",\n       \"uuid\":\"886c4deb-2186-4f11-8134-a37111200b83\"\n    }\n    ```\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Collection attributes\n        \"\"\"\n\n        process: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        computation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        computation_process: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        funding: List[str] = field(default_factory=list)\n        citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        name: str,\n        process: Optional[List[Union[Any, UIDProxy]]] = None,\n        computation: Optional[List[Union[Any, UIDProxy]]] = None,\n        computation_process: Optional[List[Union[Any, UIDProxy]]] = None,\n        data: Optional[List[Union[Any, UIDProxy]]] = None,\n        funding: Optional[List[str]] = None,\n        citation: Optional[List[Union[Any, UIDProxy]]] = None,\n        notes: str = \"\",\n        **kwargs\n    ):\n        \"\"\"\n        create an Experiment node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n\n        Parameters\n        ----------\n        name: str\n            name of Experiment\n        process: List[Process]\n            list of Process nodes for this Experiment\n        computation: List[Computation]\n            list of computation nodes for this Experiment\n        computation_process: List[ComputationalProcess]\n            list of computational_process nodes for this Experiment\n        data: List[Data]\n            list of data nodes for this experiment\n        funding: List[str]\n            list of the funders names for this Experiment\n        citation: List[Citation]\n            list of Citation nodes for this experiment\n        notes: str default=\"\"\n            notes for the experiment node\n\n        Returns\n        -------\n        None\n            Instantiate an Experiment node\n        \"\"\"\n\n        if process is None:\n            process = []\n        if computation is None:\n            computation = []\n        if computation_process is None:\n            computation_process = []\n        if data is None:\n            data = []\n        if funding is None:\n            funding = []\n        if citation is None:\n            citation = []\n\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            name=name,\n            process=process,\n            computation=computation,\n            computation_process=computation_process,\n            data=data,\n            funding=funding,\n            citation=citation,\n            notes=notes,\n        )\n\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def process(self) -&gt; List[Any]:\n        \"\"\"\n        List of process for experiment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_experiment.process = [my_process]\n\n        Returns\n        -------\n        List[Process]\n            List of process that were performed in this experiment\n        \"\"\"\n        return self._json_attrs.process.copy()\n\n    @process.setter\n    @beartype\n    def process(self, new_process_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of process for this experiment\n\n        Parameters\n        ----------\n        new_process_list: List[Process]\n            new process list to replace the current process list\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, process=new_process_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def computation(self) -&gt; List[Any]:\n        \"\"\"\n        List of the [computations](../computation) in this experiment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_experiment.computation = [my_computation]\n\n        Returns\n        -------\n        List[Computation]\n            List of [computations](../computation) for this experiment\n        \"\"\"\n        return self._json_attrs.computation.copy()\n\n    @computation.setter\n    @beartype\n    def computation(self, new_computation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of computations for this experiment\n\n        Parameters\n        ----------\n        new_computation_list: List[Computation]\n            new list of computations to replace the current list of experiments\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, computation=new_computation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def computation_process(self) -&gt; List[Any]:\n        \"\"\"\n        List of [computation_process](../computation_process) for this experiment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...     name=\"my material name\", bigsmiles = \"123456\"\n        ... )\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ... key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ... material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n        ... )\n        &gt;&gt;&gt; my_computation_process = cript.ComputationProcess(\n        ...     name=\"my computational process name\",\n        ...     type=\"cross_linking\",         # must come from CRIPT Controlled Vocabulary\n        ...     input_data=[my_data],         # input data is another data node\n        ...     ingredient=[my_ingredient],  # output data is another data node\n        ... )\n        &gt;&gt;&gt; my_experiment.computation_process = [my_computation_process]\n\n        Returns\n        -------\n        List[ComputationalProcess]\n            computational process that were performed in this experiment\n        \"\"\"\n        return self._json_attrs.computation_process.copy()\n\n    @computation_process.setter\n    @beartype\n    def computation_process(self, new_computation_process_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of computation_process for this experiment\n\n        Parameters\n        ----------\n        new_computation_process_list: List[ComputationalProcess]\n            new list of computations to replace the current for the experiment\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, computation_process=new_computation_process_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def data(self) -&gt; List[Any]:\n        \"\"\"\n        List of [data nodes](../data) for this experiment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_file = cript.File(\n        ...    name=\"my file node name\",\n        ...    source=\"https://criptapp.org\",\n        ...    type=\"calibration\",\n        ...    extension=\".csv\",\n        ...    data_dictionary=\"my file's data dictionary\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_experiment.data = [my_data]\n\n        Returns\n        -------\n        List[Data]\n            list of [data nodes](../data) that belong to this experiment\n        \"\"\"\n        return self._json_attrs.data.copy()\n\n    @data.setter\n    @beartype\n    def data(self, new_data_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of data for this experiment\n\n        Parameters\n        ----------\n        new_data_list: List[Data]\n            new list of data to replace the current list for this experiment\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, data=new_data_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def funding(self) -&gt; List[str]:\n        \"\"\"\n        List of strings of all the funders for this experiment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_experiment.funding = [\"National Science Foundation\", \"IRIS\", \"NIST\"]\n\n        Returns\n        -------\n        List[str]\n            List of funders for this experiment\n        \"\"\"\n        return self._json_attrs.funding.copy()\n\n    @funding.setter\n    @beartype\n    def funding(self, new_funding_list: List[str]) -&gt; None:\n        \"\"\"\n        set the list of funders for this experiment\n\n        Parameters\n        ----------\n        new_funding_list: List[str]\n            replace the current list of funders\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, funding=new_funding_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Any]:\n        \"\"\"\n        List of [citation](../../subobjects/citation) for this experiment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=\"title\",\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n        &gt;&gt;&gt; my_experiment.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of citations of scholarly work that was used in this experiment\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of citations for this experiment\n\n        Parameters\n        ----------\n        new_citations_list: List[Citation]\n            replace the list of citations for this experiment with a new list of citations\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my experiment name\",\n   \"node\":[\"Experiment\"],\n   \"uid\":\"_:886c4deb-2186-4f11-8134-a37111200b83\",\n   \"uuid\":\"886c4deb-2186-4f11-8134-a37111200b83\"\n}\n</code></pre>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.citation","title":"<code>citation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of citation for this experiment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_reference = cript.Reference(\n...     type=\"journal_article\",\n...     title=\"title\",\n...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n...     journal=\"Computer Physics Communications\",\n...     publisher=\"Elsevier\",\n...     year=2019,\n...     pages=[463, 476],\n...     doi=\"10.1016/j.cpc.2018.08.011\",\n...     issn=\"0010-4655\",\n...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n... )\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n&gt;&gt;&gt; my_experiment.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of citations of scholarly work that was used in this experiment</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.computation","title":"<code>computation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of the computations in this experiment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_experiment.computation = [my_computation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Computation]</code> <p>List of computations for this experiment</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.computation_process","title":"<code>computation_process: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of computation_process for this experiment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\",\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_material = cript.Material(\n...     name=\"my material name\", bigsmiles = \"123456\"\n... )\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n... key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient = cript.Ingredient(\n... material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n... )\n&gt;&gt;&gt; my_computation_process = cript.ComputationProcess(\n...     name=\"my computational process name\",\n...     type=\"cross_linking\",         # must come from CRIPT Controlled Vocabulary\n...     input_data=[my_data],         # input data is another data node\n...     ingredient=[my_ingredient],  # output data is another data node\n... )\n&gt;&gt;&gt; my_experiment.computation_process = [my_computation_process]\n</code></pre> <p>Returns:</p> Type Description <code>List[ComputationalProcess]</code> <p>computational process that were performed in this experiment</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.data","title":"<code>data: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of data nodes for this experiment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_file = cript.File(\n...    name=\"my file node name\",\n...    source=\"https://criptapp.org\",\n...    type=\"calibration\",\n...    extension=\".csv\",\n...    data_dictionary=\"my file's data dictionary\",\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_experiment.data = [my_data]\n</code></pre> <p>Returns:</p> Type Description <code>List[Data]</code> <p>list of data nodes that belong to this experiment</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.funding","title":"<code>funding: List[str]</code>  <code>property</code> <code>writable</code>","text":"<p>List of strings of all the funders for this experiment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_experiment.funding = [\"National Science Foundation\", \"IRIS\", \"NIST\"]\n</code></pre> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of funders for this experiment</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.process","title":"<code>process: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of process for experiment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_experiment.process = [my_process]\n</code></pre> <p>Returns:</p> Type Description <code>List[Process]</code> <p>List of process that were performed in this experiment</p>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Collection attributes</p> Source code in <code>src/cript/nodes/primary_nodes/experiment.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Collection attributes\n    \"\"\"\n\n    process: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    computation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    computation_process: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    data: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    funding: List[str] = field(default_factory=list)\n    citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/experiment/#cript.nodes.primary_nodes.experiment.Experiment.__init__","title":"<code>__init__(name, process=None, computation=None, computation_process=None, data=None, funding=None, citation=None, notes='', **kwargs)</code>","text":"<p>create an Experiment node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of Experiment</p> required <code>process</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of Process nodes for this Experiment</p> <code>None</code> <code>computation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of computation nodes for this Experiment</p> <code>None</code> <code>computation_process</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of computational_process nodes for this Experiment</p> <code>None</code> <code>data</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of data nodes for this experiment</p> <code>None</code> <code>funding</code> <code>Optional[List[str]]</code> <p>list of the funders names for this Experiment</p> <code>None</code> <code>citation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of Citation nodes for this experiment</p> <code>None</code> <code>notes</code> <code>str</code> <p>notes for the experiment node</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>Instantiate an Experiment node</p> Source code in <code>src/cript/nodes/primary_nodes/experiment.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    name: str,\n    process: Optional[List[Union[Any, UIDProxy]]] = None,\n    computation: Optional[List[Union[Any, UIDProxy]]] = None,\n    computation_process: Optional[List[Union[Any, UIDProxy]]] = None,\n    data: Optional[List[Union[Any, UIDProxy]]] = None,\n    funding: Optional[List[str]] = None,\n    citation: Optional[List[Union[Any, UIDProxy]]] = None,\n    notes: str = \"\",\n    **kwargs\n):\n    \"\"\"\n    create an Experiment node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_experiment = cript.Experiment(name=\"my experiment name\")\n\n    Parameters\n    ----------\n    name: str\n        name of Experiment\n    process: List[Process]\n        list of Process nodes for this Experiment\n    computation: List[Computation]\n        list of computation nodes for this Experiment\n    computation_process: List[ComputationalProcess]\n        list of computational_process nodes for this Experiment\n    data: List[Data]\n        list of data nodes for this experiment\n    funding: List[str]\n        list of the funders names for this Experiment\n    citation: List[Citation]\n        list of Citation nodes for this experiment\n    notes: str default=\"\"\n        notes for the experiment node\n\n    Returns\n    -------\n    None\n        Instantiate an Experiment node\n    \"\"\"\n\n    if process is None:\n        process = []\n    if computation is None:\n        computation = []\n    if computation_process is None:\n        computation_process = []\n    if data is None:\n        data = []\n    if funding is None:\n        funding = []\n    if citation is None:\n        citation = []\n\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        name=name,\n        process=process,\n        computation=computation,\n        computation_process=computation_process,\n        data=data,\n        funding=funding,\n        citation=citation,\n        notes=notes,\n    )\n\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/inventory/","title":"Inventory","text":""},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory","title":"<code>Inventory</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory--definition","title":"Definition","text":"<p>An Inventory Node is a list of material nodes. An example of an inventory can be a grouping of materials that were extracted from literature and curated into a group for machine learning, or it can be a subset of chemicals that are used for a certain type of synthesis.</p>"},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory--attributes","title":"Attributes","text":"Attribute Type Example Description material list[Material] material that you like to group together notes str \"my awesome notes\" miscellaneous information, or custom data structure"},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my inventory name\",\n   \"node\":[\"Inventory\"],\n   \"uid\":\"_:90f45778-b7c9-4b77-8b83-a6ea9671a937\",\n   \"uuid\":\"90f45778-b7c9-4b77-8b83-a6ea9671a937\",\n   \"material\":[\n      {\n         \"node\":[\"Material\"],\n         \"name\":\"my material 1\",\n         \"uid\":\"_:9679ff12-f9b4-41f4-be95-080b78fa71fd\",\n         \"uuid\":\"9679ff12-f9b4-41f4-be95-080b78fa71fd\"\n         \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n      },\n      {\n         \"node\":[\"Material\"],\n         \"name\":\"my material 2\",\n         \"uid\":\"_:1ee41708-3531-43eb-8049-4bb91ad73df6\",\n         \"uuid\":\"1ee41708-3531-43eb-8049-4bb91ad73df6\"\n         \"bigsmiles\":\"654321\",\n      }\n   ]\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/inventory.py</code> <pre><code>class Inventory(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n    An\n    [Inventory Node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=9)\n    is a list of material nodes.\n    An example of an inventory can be a grouping of materials that were extracted from literature\n    and curated into a group for machine learning, or it can be a subset of chemicals that are used for a\n    certain type of synthesis.\n\n    ## Attributes\n    | Attribute | Type                            | Example            | Description                                         |\n    |-----------|---------------------------------|--------------------|-----------------------------------------------------|\n    | material  | list[[Material](./material.md)] |                    | material that you like to group together            |\n    | notes     | str                             | \"my awesome notes\" | miscellaneous information, or custom data structure |\n\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my inventory name\",\n       \"node\":[\"Inventory\"],\n       \"uid\":\"_:90f45778-b7c9-4b77-8b83-a6ea9671a937\",\n       \"uuid\":\"90f45778-b7c9-4b77-8b83-a6ea9671a937\",\n       \"material\":[\n          {\n             \"node\":[\"Material\"],\n             \"name\":\"my material 1\",\n             \"uid\":\"_:9679ff12-f9b4-41f4-be95-080b78fa71fd\",\n             \"uuid\":\"9679ff12-f9b4-41f4-be95-080b78fa71fd\"\n             \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n          },\n          {\n             \"node\":[\"Material\"],\n             \"name\":\"my material 2\",\n             \"uid\":\"_:1ee41708-3531-43eb-8049-4bb91ad73df6\",\n             \"uuid\":\"1ee41708-3531-43eb-8049-4bb91ad73df6\"\n             \"bigsmiles\":\"654321\",\n          }\n       ]\n    }\n    ```\n\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Inventory attributes\n        \"\"\"\n\n        material: List[Union[Material, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, name: str, material: List[Union[Material, UIDProxy]], notes: str = \"\", **kwargs) -&gt; None:\n        \"\"\"\n        Instantiate an inventory node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; material_1 = cript.Material(\n        ...    name=\"material 1\",\n        ...    bigsmiles = \"material 1 bigsmiles\",\n        ... )\n        &gt;&gt;&gt; material_2 = cript.Material(\n        ...    name=\"material 2\",\n        ...    bigsmiles = \"material 2 bigsmiles\",\n        ... )\n        &gt;&gt;&gt; my_inventory = cript.Inventory(\n        ...    name=\"my inventory name\", material=[material_1, material_2]\n        ... )\n\n        Parameters\n        ----------\n        material: List[Material]\n            list of materials in this inventory\n\n        Returns\n        -------\n        None\n            instantiate an inventory node\n        \"\"\"\n\n        if material is None:\n            material = []\n\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        new_json_attrs = replace(self._json_attrs, material=material)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def material(self) -&gt; List[Union[Material, UIDProxy]]:\n        \"\"\"\n        List of [material](../material) in this inventory\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...    name=\"my material\",\n        ...    bigsmiles = \"my bigsmiles\",\n        ... )\n        &gt;&gt;&gt; my_inventory = cript.Inventory(name=\"my inventory\", material=[my_material])\n        &gt;&gt;&gt; new_material = cript.Material(\n        ...    name=\"new material\",\n        ...    bigsmiles = \"my bigsmiles\",\n        ... )\n        &gt;&gt;&gt; my_inventory.material = [new_material]\n\n        Returns\n        -------\n        List[Material]\n            list of material representing the inventory within the collection\n        \"\"\"\n        return self._json_attrs.material.copy()\n\n    @material.setter\n    @beartype\n    def material(self, new_material_list: List[Union[Material, UIDProxy]]):\n        \"\"\"\n        set the list of material for this inventory node\n\n        Parameters\n        ----------\n        new_material_list: List[Material]\n            new list of material to replace the current list of material nodes for this inventory node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, material=new_material_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory.material","title":"<code>material: List[Union[Material, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>List of material in this inventory</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(\n...    name=\"my material\",\n...    bigsmiles = \"my bigsmiles\",\n... )\n&gt;&gt;&gt; my_inventory = cript.Inventory(name=\"my inventory\", material=[my_material])\n&gt;&gt;&gt; new_material = cript.Material(\n...    name=\"new material\",\n...    bigsmiles = \"my bigsmiles\",\n... )\n&gt;&gt;&gt; my_inventory.material = [new_material]\n</code></pre> <p>Returns:</p> Type Description <code>List[Material]</code> <p>list of material representing the inventory within the collection</p>"},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Inventory attributes</p> Source code in <code>src/cript/nodes/primary_nodes/inventory.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Inventory attributes\n    \"\"\"\n\n    material: List[Union[Material, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/inventory/#cript.nodes.primary_nodes.inventory.Inventory.__init__","title":"<code>__init__(name, material, notes='', **kwargs)</code>","text":"<p>Instantiate an inventory node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; material_1 = cript.Material(\n...    name=\"material 1\",\n...    bigsmiles = \"material 1 bigsmiles\",\n... )\n&gt;&gt;&gt; material_2 = cript.Material(\n...    name=\"material 2\",\n...    bigsmiles = \"material 2 bigsmiles\",\n... )\n&gt;&gt;&gt; my_inventory = cript.Inventory(\n...    name=\"my inventory name\", material=[material_1, material_2]\n... )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>List[Union[Material, UIDProxy]]</code> <p>list of materials in this inventory</p> required <p>Returns:</p> Type Description <code>None</code> <p>instantiate an inventory node</p> Source code in <code>src/cript/nodes/primary_nodes/inventory.py</code> <pre><code>@beartype\ndef __init__(self, name: str, material: List[Union[Material, UIDProxy]], notes: str = \"\", **kwargs) -&gt; None:\n    \"\"\"\n    Instantiate an inventory node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; material_1 = cript.Material(\n    ...    name=\"material 1\",\n    ...    bigsmiles = \"material 1 bigsmiles\",\n    ... )\n    &gt;&gt;&gt; material_2 = cript.Material(\n    ...    name=\"material 2\",\n    ...    bigsmiles = \"material 2 bigsmiles\",\n    ... )\n    &gt;&gt;&gt; my_inventory = cript.Inventory(\n    ...    name=\"my inventory name\", material=[material_1, material_2]\n    ... )\n\n    Parameters\n    ----------\n    material: List[Material]\n        list of materials in this inventory\n\n    Returns\n    -------\n    None\n        instantiate an inventory node\n    \"\"\"\n\n    if material is None:\n        material = []\n\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    new_json_attrs = replace(self._json_attrs, material=material)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/material/","title":"Material","text":""},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material","title":"<code>Material</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material--definition","title":"Definition","text":"<p>A Material node is a collection of the properties of a chemical, mixture, or substance.</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material--attributes","title":"Attributes","text":"attribute type example description required vocab component list[Material] list of component that make up the mixture property list[Property] material properties process Process process node that made this material parent_material Material material node that this node was copied from computational_forcefield Computation  Forcefield computation forcefield Conditional keyword list[str] [thermoplastic, homopolymer, linear, polyolefins] words that classify the material True notes str \"my awesome notes\" miscellaneous information, or custom data structure True amino_acid str \"LeuProHis\" if the material is an amino acid sequence, list it. Conditional bigsmiles str \"CC{$CC$}\" BigSMILES string for polymer Conditional chem_formula str \"C22H33NO10\" Chemical formula of the material or monomer Conditional chem_repeat str \"C=Cc1ccccc1\" Chemical formula of the repeat unit Conditional chemical_id str \"126094\" Unique chemical ID Conditional inchi str \"InChI=1S/H2O/h1H2\" InChI string of the chemical Conditional inchi_key str \"XLYOFNOQVPJJNP-UHFFFAOYSA-N\" InChI key of the chemical Conditional lot_number str \"123\" Lot number of the chemical Conditional names list[str] [\"water\", \"Hydrogen oxide\"] Alternative names that are being used Conditional pubchem_cid int 962 PubChemID of the chemical Conditional smiles str \"O\" Smiles string of the chemical Conditional vendor str \"fisher scientific\" Vendor the chemical was purchased from Conditional"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material--navigating-to-material","title":"Navigating to Material","text":"<p>Materials can be easily found on the CRIPT home screen in the under the navigation within the Materials link</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material--available-sub-objects-for-material","title":"Available Sub-Objects for Material","text":"<ul> <li>Property</li> <li>Computational_forcefield</li> </ul> Example <p>water, brine (water + NaCl), polystyrene, polyethylene glycol hydrogels, vulcanized polyisoprene, mcherry (protein), and mica</p> Warnings <p>Material names</p> <p>Material names Must be unique within a Project</p> <pre><code>  {\n     \"node\":[\"Material\"],\n     \"name\":\"my unique material name\",\n     \"uid\":\"_:9679ff12-f9b4-41f4-be95-080b78fa71fd\",\n     \"uuid\":\"9679ff12-f9b4-41f4-be95-080b78fa71fd\"\n     \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n  }\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/material.py</code> <pre><code>class Material(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n    A [Material node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=10)\n    is a collection of the properties of a chemical, mixture, or substance.\n\n    ## Attributes\n    | attribute                 | type                                                                 | example                                           | description                                         | required    | vocab |\n    |---------------------------|----------------------------------------------------------------------|---------------------------------------------------|-----------------------------------------------------|-------------|-------|\n    | component                 | list[[Material](./)]                                                 |                                                   | list of component that make up the mixture          |             |       |\n    | property                  | list[[Property](../../subobjects/property)]                          |                                                   | material properties                                 |             |       |\n    | process                   | [Process](../process)                                                |                                                   | process node that made this material                |             |       |\n    | parent_material           | [Material](./)                                                       |                                                   | material node that this node was copied from        |             |       |\n    | computational_forcefield  | [Computation  Forcefield](../../subobjects/computational_forcefield) |                                                   | computation forcefield                              | Conditional |       |\n    | keyword                   | list[str]                                                            | [thermoplastic, homopolymer, linear, polyolefins] | words that classify the material                    |             | True  |\n    | notes                     | str                                                                  | \"my awesome notes\"                                | miscellaneous information, or custom data structure |             | True  |\n    | amino_acid                | str                                                                  | \"LeuProHis\"                                       | if the material is an amino acid sequence, list it. | Conditional |       |\n    | bigsmiles                 | str                                                                  | \"CC{[$][$]CC[$][]}\"                               | BigSMILES string for polymer                        | Conditional |       |\n    | chem_formula              | str                                                                  | \"C22H33NO10\"                                      | Chemical formula of the material or monomer        | Conditional |       |\n    | chem_repeat               | str                                                                  | \"C=Cc1ccccc1\"                                     | Chemical formula of the repeat unit                | Conditional |       |\n    | chemical_id               | str                                                                  | \"126094\"                                          | Unique chemical ID                                  | Conditional |       |\n    | inchi                     | str                                                                  | \"InChI=1S/H2O/h1H2\"                               | InChI string of the chemical                        | Conditional |       |\n    | inchi_key                 | str                                                                  | \"XLYOFNOQVPJJNP-UHFFFAOYSA-N\"                     | InChI key of the chemical                           | Conditional |       |\n    | lot_number                | str                                                                  | \"123\"                                             | Lot number of the chemical                          | Conditional |       |\n    | names                     | list[str]                                                            | [\"water\", \"Hydrogen oxide\"]                       | Alternative names that are being used               | Conditional |       |\n    | pubchem_cid               | int                                                                  | 962                                               | PubChemID of the chemical                           | Conditional |       |\n    | smiles                    | str                                                                  | \"O\"                                               | Smiles string of the chemical                       | Conditional |       |\n    | vendor                    | str                                                                  | \"fisher scientific\"                               | Vendor the chemical was purchased from              | Conditional |       |\n\n\n    ## Navigating to Material\n    Materials can be easily found on the [CRIPT](https://app.criptapp.org) home screen in the\n    under the navigation within the [Materials link](https://app.criptapp.org/material/)\n\n    ## Available Sub-Objects for Material\n    * [Property](../../subobjects/property)\n    * [Computational_forcefield](../../subobjects/computational_forcefield)\n\n    Example\n    -------\n     water, brine (water + NaCl), polystyrene, polyethylene glycol hydrogels, vulcanized polyisoprene, mcherry (protein), and mica\n\n\n    Warnings\n    -------\n    !!! warning \"Material names\"\n        Material names Must be unique within a [Project](../project)\n\n    ```json\n      {\n         \"node\":[\"Material\"],\n         \"name\":\"my unique material name\",\n         \"uid\":\"_:9679ff12-f9b4-41f4-be95-080b78fa71fd\",\n         \"uuid\":\"9679ff12-f9b4-41f4-be95-080b78fa71fd\"\n         \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n      }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Material attributes\n        \"\"\"\n\n        # TODO add proper typing in future, using Any for now to avoid circular import error\n        component: List[Union[\"Material\", UIDProxy]] = field(default_factory=list)\n        process: Optional[Union[Process, UIDProxy]] = None\n        property: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        parent_material: Optional[Union[\"Material\", UIDProxy]] = None\n        computational_forcefield: Optional[Union[Any, UIDProxy]] = None\n        keyword: List[str] = field(default_factory=list)\n        amino_acid: Optional[str] = None\n        bigsmiles: Optional[str] = None\n        chem_formula: Optional[str] = None\n        chem_repeat: List[str] = field(default_factory=list)\n        chemical_id: Optional[str] = None\n        inchi: Optional[str] = None\n        inchi_key: Optional[str] = None\n        lot_number: Optional[str] = None\n        names: List[str] = field(default_factory=list)\n        pubchem_cid: Optional[int] = None\n        smiles: Optional[str] = None\n        vendor: Optional[str] = None\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        name: str,\n        component: Optional[List[Union[\"Material\", UIDProxy]]] = None,\n        process: Optional[Union[Process, UIDProxy]] = None,\n        property: Optional[List[Union[Any, UIDProxy]]] = None,\n        parent_material: Optional[Union[\"Material\", UIDProxy]] = None,\n        computational_forcefield: Optional[Union[Any, UIDProxy]] = None,\n        keyword: Optional[List[str]] = None,\n        amino_acid: Optional[str] = None,\n        bigsmiles: Optional[str] = None,\n        chem_formula: Optional[str] = None,\n        chem_repeat: Optional[List[str]] = None,\n        chemical_id: Optional[str] = None,\n        inchi: Optional[str] = None,\n        inchi_key: Optional[str] = None,\n        lot_number: Optional[str] = None,\n        names: Optional[List[str]] = None,\n        pubchem_cid: Optional[int] = None,\n        smiles: Optional[str] = None,\n        vendor: Optional[str] = None,\n        notes: str = \"\",\n        **kwargs\n    ):\n        \"\"\"\n        create a material node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...     name=\"my component material 1\",\n        ...     amino_acid = \"component 1 alternative name\",\n        ... )\n\n        Parameters\n        ----------\n        name: str\n        component: List[\"Material\"], default=None\n        property: Optional[Process], default=None\n        process: List[Process], default=None\n        parent_material: \"Material\", default=None\n        computational_forcefield: ComputationalForcefield, default=None\n        keyword: List[str], default=None\n        amino_acid: Optional[str] = None,\n        bigsmiles: Optional[str] = None,\n        chem_formula: Optional[str] = None,\n        chem_repeat: Optional[List[str]] = None,\n        chemical_id: Optional[str] = None,\n        inchi: Optional[str] = None,\n        inchi_key: Optional[str] = None,\n        lot_number: Optional[str] = None,\n        names: Optional[List[str]] = None,\n        pubchem_cid: Optional[int] = None,\n        smiles: Optional[str] = None,\n        vendor: Optional[str] = None,\n\n        Returns\n        -------\n        None\n            Instantiate a material node\n        \"\"\"\n\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        if component is None:\n            component = []\n\n        if property is None:\n            property = []\n\n        if keyword is None:\n            keyword = []\n\n        if chem_repeat is None:\n            chem_repeat = []\n\n        if names is None:\n            names = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            name=name,\n            component=component,\n            process=process,\n            property=property,\n            parent_material=parent_material,\n            computational_forcefield=computational_forcefield,\n            keyword=keyword,\n            amino_acid=amino_acid,\n            bigsmiles=bigsmiles,\n            chem_formula=chem_formula,\n            chem_repeat=chem_repeat,\n            chemical_id=chemical_id,\n            inchi=inchi,\n            inchi_key=inchi_key,\n            lot_number=lot_number,\n            names=names,\n            pubchem_cid=pubchem_cid,\n            smiles=smiles,\n            vendor=vendor,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    def validate(self, api=None, is_patch: bool = False, force_validation: bool = False) -&gt; None:\n        super().validate(api=api, is_patch=is_patch, force_validation=force_validation)\n\n        if (\n            self.amino_acid is None\n            and self.bigsmiles is None\n            and self.chem_formula is None\n            and len(self.chem_repeat) == 0\n            and self.chemical_id is None\n            and self.inchi_key is None\n            and self.inchi is None\n            and self.lot_number is None\n            and len(self.names) == 0\n            and self.pubchem_cid is None\n            and self.smiles is None\n            and self.vendor is None\n        ):\n            warnings.warn(CRIPTMaterialIdentifierWarning(self))\n\n    @property\n    @beartype\n    def amino_acid(self) -&gt; Union[str, None]:\n        return self._json_attrs.amino_acid\n\n    @amino_acid.setter\n    @beartype\n    def amino_acid(self, new_amino_acid: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, amino_acid=new_amino_acid)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def bigsmiles(self) -&gt; Union[str, None]:\n        return self._json_attrs.bigsmiles\n\n    @bigsmiles.setter\n    @beartype\n    def bigsmiles(self, new_bigsmiles: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, bigsmiles=new_bigsmiles)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def chem_formula(self) -&gt; Union[str, None]:\n        return self._json_attrs.chem_formula\n\n    @chem_formula.setter\n    @beartype\n    def chem_formula(self, new_chem_formula: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, chem_formula=new_chem_formula)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def chemical_id(self) -&gt; Union[str, None]:\n        return self._json_attrs.chemical_id\n\n    @chemical_id.setter\n    @beartype\n    def chemical_id(self, new_chemical_id: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, chemical_id=new_chemical_id)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def inchi(self) -&gt; Union[str, None]:\n        return self._json_attrs.inchi\n\n    @inchi.setter\n    @beartype\n    def inchi(self, new_inchi: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, inchi=new_inchi)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def inchi_key(self) -&gt; Union[str, None]:\n        return self._json_attrs.inchi_key\n\n    @inchi_key.setter\n    @beartype\n    def inchi_key(self, new_inchi_key: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, inchi_key=new_inchi_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def lot_number(self) -&gt; Union[str, None]:\n        return self._json_attrs.lot_number\n\n    @lot_number.setter\n    @beartype\n    def lot_number(self, new_lot_number: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, lot_number=new_lot_number)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def smiles(self) -&gt; Union[str, None]:\n        return self._json_attrs.smiles\n\n    @smiles.setter\n    @beartype\n    def smiles(self, new_smiles: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, smiles=new_smiles)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def vendor(self) -&gt; Union[str, None]:\n        return self._json_attrs.vendor\n\n    @vendor.setter\n    @beartype\n    def vendor(self, new_vendor: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, vendor=new_vendor)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def chem_repeat(self) -&gt; List[str]:\n        return self._json_attrs.chem_repeat.copy()\n\n    @chem_repeat.setter\n    @beartype\n    def chem_repeat(self, new_chem_repeat: List[str]) -&gt; None:\n        new_attrs = replace(self._json_attrs, chem_repeat=new_chem_repeat)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def names(self) -&gt; List[str]:\n        return self._json_attrs.names.copy()\n\n    @names.setter\n    @beartype\n    def names(self, new_names: List[str]) -&gt; None:\n        new_attrs = replace(self._json_attrs, names=new_names)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def pubchem_cid(self) -&gt; Union[int, None]:\n        return self._json_attrs.pubchem_cid\n\n    @pubchem_cid.setter\n    @beartype\n    def pubchem_cid(self, new_pubchem_cid: int) -&gt; None:\n        new_attrs = replace(self._json_attrs, pubchem_cid=new_pubchem_cid)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def component(self) -&gt; List[Union[\"Material\", UIDProxy]]:\n        \"\"\"\n        list of components ([material nodes](./)) that make up this material\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_components = [\n        ...     cript.Material(\n        ...         name=\"my component material 1\",\n        ...         smiles=\"my material smiles\",\n        ...     ),\n        ...     cript.Material(\n        ...         name=\"my component material 2\",\n        ...         vendor= \"my material vendor\",\n        ...     ),\n        ... ]\n        &gt;&gt;&gt; my_mixed_material = cript.Material(\n        ...     name=\"my material\",\n        ...     component=my_components,\n        ...     bigsmiles = \"123456\",\n        ... )\n\n        Returns\n        -------\n        List[Material]\n            list of component that make up this material\n        \"\"\"\n        return self._json_attrs.component\n\n    @component.setter\n    @beartype\n    def component(self, new_component_list: List[Union[\"Material\", UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of component (material nodes) that make up this material\n\n        Parameters\n        ----------\n        new_component_list: List[\"Material\"]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, component=new_component_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def parent_material(self) -&gt; Optional[Union[\"Material\", UIDProxy]]:\n        \"\"\"\n        List of parent materials\n\n        Returns\n        -------\n        List[\"Material\"]\n            list of parent materials\n        \"\"\"\n        return self._json_attrs.parent_material\n\n    @parent_material.setter\n    @beartype\n    def parent_material(self, new_parent_material: Optional[Union[\"Material\", UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the [parent materials](./) for this material\n\n        Parameters\n        ----------\n        new_parent_material: \"Material\"\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        new_attrs = replace(self._json_attrs, parent_material=new_parent_material)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def computational_forcefield(self) -&gt; Any:\n        \"\"\"\n        list of [computational_forcefield](../../subobjects/computational_forcefield) for this material node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...     name=\"my component material 1\", smiles= \"my smiles\"\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_material.computational_forcefield = my_computational_forcefield\n\n        Returns\n        -------\n        List[ComputationForcefield]\n            list of computational_forcefield that created this material\n        \"\"\"\n        return self._json_attrs.computational_forcefield\n\n    @computational_forcefield.setter\n    @beartype\n    def computational_forcefield(self, new_computational_forcefield: Any) -&gt; None:\n        \"\"\"\n        sets the list of computational forcefields for this material\n\n        Parameters\n        ----------\n        new_computation_forcefield: ComputationalForcefield\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, computational_forcefield=new_computational_forcefield)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def keyword(self) -&gt; List[str]:\n        \"\"\"\n        List of keyword for this material\n\n        the material keyword must come from the\n        [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/material_keyword)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(\n        ... name=\"my material\", inchi = \"my material inchi\"\n        ... )\n        &gt;&gt;&gt; my_material.keyword = [\"acetylene\", \"acrylate\", \"alternating\"]\n\n        Returns\n        -------\n        List[str]\n            list of material keyword\n        \"\"\"\n        return self._json_attrs.keyword\n\n    @keyword.setter\n    @beartype\n    def keyword(self, new_keyword_list: List[str]) -&gt; None:\n        \"\"\"\n        set the keyword for this material\n\n        the material keyword must come from the CRIPT controlled vocabulary\n\n        Parameters\n        ----------\n        new_keyword_list\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, keyword=new_keyword_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def process(self) -&gt; Optional[Union[Process, UIDProxy]]:\n        return self._json_attrs.process  # type: ignore\n\n    @process.setter\n    def process(self, new_process: Union[Process, UIDProxy]) -&gt; None:\n        new_attrs = replace(self._json_attrs, process=new_process)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    def property(self) -&gt; List[Any]:\n        \"\"\"\n        list of material [property](../../subobjects/property)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(\n        ...     name=\"my component material 1\",\n        ...     smiles = \"component 1 smiles\",\n        ... )\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.23, unit=\"J\")\n        &gt;&gt;&gt; my_material.property = [my_property]\n\n        Returns\n        -------\n        List[Property]\n            list of property that define this material\n        \"\"\"\n        return self._json_attrs.property.copy()\n\n    @property.setter\n    @beartype\n    def property(self, new_property_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of properties for this material\n\n        Parameters\n        ----------\n        new_property_list: List[Property]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, property=new_property_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.component","title":"<code>component: List[Union[Material, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of components (material nodes) that make up this material</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_components = [\n...     cript.Material(\n...         name=\"my component material 1\",\n...         smiles=\"my material smiles\",\n...     ),\n...     cript.Material(\n...         name=\"my component material 2\",\n...         vendor= \"my material vendor\",\n...     ),\n... ]\n&gt;&gt;&gt; my_mixed_material = cript.Material(\n...     name=\"my material\",\n...     component=my_components,\n...     bigsmiles = \"123456\",\n... )\n</code></pre> <p>Returns:</p> Type Description <code>List[Material]</code> <p>list of component that make up this material</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.computational_forcefield","title":"<code>computational_forcefield: Any</code>  <code>property</code> <code>writable</code>","text":"<p>list of computational_forcefield for this material node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(\n...     name=\"my component material 1\", smiles= \"my smiles\"\n... )\n&gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n...     key=\"opls_aa\",\n...     building_block=\"atom\",\n... )\n&gt;&gt;&gt; my_material.computational_forcefield = my_computational_forcefield\n</code></pre> <p>Returns:</p> Type Description <code>List[ComputationForcefield]</code> <p>list of computational_forcefield that created this material</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.keyword","title":"<code>keyword: List[str]</code>  <code>property</code> <code>writable</code>","text":"<p>List of keyword for this material</p> <p>the material keyword must come from the CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(\n... name=\"my material\", inchi = \"my material inchi\"\n... )\n&gt;&gt;&gt; my_material.keyword = [\"acetylene\", \"acrylate\", \"alternating\"]\n</code></pre> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of material keyword</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.parent_material","title":"<code>parent_material: Optional[Union[Material, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>List of parent materials</p> <p>Returns:</p> Type Description <code>List[Material]</code> <p>list of parent materials</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.property","title":"<code>property: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>list of material property</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(\n...     name=\"my component material 1\",\n...     smiles = \"component 1 smiles\",\n... )\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.23, unit=\"J\")\n&gt;&gt;&gt; my_material.property = [my_property]\n</code></pre> <p>Returns:</p> Type Description <code>List[Property]</code> <p>list of property that define this material</p>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Material attributes</p> Source code in <code>src/cript/nodes/primary_nodes/material.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Material attributes\n    \"\"\"\n\n    # TODO add proper typing in future, using Any for now to avoid circular import error\n    component: List[Union[\"Material\", UIDProxy]] = field(default_factory=list)\n    process: Optional[Union[Process, UIDProxy]] = None\n    property: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    parent_material: Optional[Union[\"Material\", UIDProxy]] = None\n    computational_forcefield: Optional[Union[Any, UIDProxy]] = None\n    keyword: List[str] = field(default_factory=list)\n    amino_acid: Optional[str] = None\n    bigsmiles: Optional[str] = None\n    chem_formula: Optional[str] = None\n    chem_repeat: List[str] = field(default_factory=list)\n    chemical_id: Optional[str] = None\n    inchi: Optional[str] = None\n    inchi_key: Optional[str] = None\n    lot_number: Optional[str] = None\n    names: List[str] = field(default_factory=list)\n    pubchem_cid: Optional[int] = None\n    smiles: Optional[str] = None\n    vendor: Optional[str] = None\n</code></pre>"},{"location":"nodes/primary_nodes/material/#cript.nodes.primary_nodes.material.Material.__init__","title":"<code>__init__(name, component=None, process=None, property=None, parent_material=None, computational_forcefield=None, keyword=None, amino_acid=None, bigsmiles=None, chem_formula=None, chem_repeat=None, chemical_id=None, inchi=None, inchi_key=None, lot_number=None, names=None, pubchem_cid=None, smiles=None, vendor=None, notes='', **kwargs)</code>","text":"<p>create a material node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(\n...     name=\"my component material 1\",\n...     amino_acid = \"component 1 alternative name\",\n... )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>component</code> <code>Optional[List[Union[Material, UIDProxy]]]</code> <code>None</code> <code>property</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <code>None</code> <code>process</code> <code>Optional[Union[Process, UIDProxy]]</code> <code>None</code> <code>parent_material</code> <code>Optional[Union[Material, UIDProxy]]</code> <code>None</code> <code>computational_forcefield</code> <code>Optional[Union[Any, UIDProxy]]</code> <code>None</code> <code>keyword</code> <code>Optional[List[str]]</code> <code>None</code> <code>amino_acid</code> <code>Optional[str]</code> <code>None</code> <code>bigsmiles</code> <code>Optional[str]</code> <code>None</code> <code>chem_formula</code> <code>Optional[str]</code> <code>None</code> <code>chem_repeat</code> <code>Optional[List[str]]</code> <code>None</code> <code>chemical_id</code> <code>Optional[str]</code> <code>None</code> <code>inchi</code> <code>Optional[str]</code> <code>None</code> <code>inchi_key</code> <code>Optional[str]</code> <code>None</code> <code>lot_number</code> <code>Optional[str]</code> <code>None</code> <code>names</code> <code>Optional[List[str]]</code> <code>None</code> <code>pubchem_cid</code> <code>Optional[int]</code> <code>None</code> <code>smiles</code> <code>Optional[str]</code> <code>None</code> <code>vendor</code> <code>Optional[str]</code> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Instantiate a material node</p> Source code in <code>src/cript/nodes/primary_nodes/material.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    name: str,\n    component: Optional[List[Union[\"Material\", UIDProxy]]] = None,\n    process: Optional[Union[Process, UIDProxy]] = None,\n    property: Optional[List[Union[Any, UIDProxy]]] = None,\n    parent_material: Optional[Union[\"Material\", UIDProxy]] = None,\n    computational_forcefield: Optional[Union[Any, UIDProxy]] = None,\n    keyword: Optional[List[str]] = None,\n    amino_acid: Optional[str] = None,\n    bigsmiles: Optional[str] = None,\n    chem_formula: Optional[str] = None,\n    chem_repeat: Optional[List[str]] = None,\n    chemical_id: Optional[str] = None,\n    inchi: Optional[str] = None,\n    inchi_key: Optional[str] = None,\n    lot_number: Optional[str] = None,\n    names: Optional[List[str]] = None,\n    pubchem_cid: Optional[int] = None,\n    smiles: Optional[str] = None,\n    vendor: Optional[str] = None,\n    notes: str = \"\",\n    **kwargs\n):\n    \"\"\"\n    create a material node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_material = cript.Material(\n    ...     name=\"my component material 1\",\n    ...     amino_acid = \"component 1 alternative name\",\n    ... )\n\n    Parameters\n    ----------\n    name: str\n    component: List[\"Material\"], default=None\n    property: Optional[Process], default=None\n    process: List[Process], default=None\n    parent_material: \"Material\", default=None\n    computational_forcefield: ComputationalForcefield, default=None\n    keyword: List[str], default=None\n    amino_acid: Optional[str] = None,\n    bigsmiles: Optional[str] = None,\n    chem_formula: Optional[str] = None,\n    chem_repeat: Optional[List[str]] = None,\n    chemical_id: Optional[str] = None,\n    inchi: Optional[str] = None,\n    inchi_key: Optional[str] = None,\n    lot_number: Optional[str] = None,\n    names: Optional[List[str]] = None,\n    pubchem_cid: Optional[int] = None,\n    smiles: Optional[str] = None,\n    vendor: Optional[str] = None,\n\n    Returns\n    -------\n    None\n        Instantiate a material node\n    \"\"\"\n\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    if component is None:\n        component = []\n\n    if property is None:\n        property = []\n\n    if keyword is None:\n        keyword = []\n\n    if chem_repeat is None:\n        chem_repeat = []\n\n    if names is None:\n        names = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        name=name,\n        component=component,\n        process=process,\n        property=property,\n        parent_material=parent_material,\n        computational_forcefield=computational_forcefield,\n        keyword=keyword,\n        amino_acid=amino_acid,\n        bigsmiles=bigsmiles,\n        chem_formula=chem_formula,\n        chem_repeat=chem_repeat,\n        chemical_id=chemical_id,\n        inchi=inchi,\n        inchi_key=inchi_key,\n        lot_number=lot_number,\n        names=names,\n        pubchem_cid=pubchem_cid,\n        smiles=smiles,\n        vendor=vendor,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/primary_base_node/","title":"PrimaryBaseNode","text":""},{"location":"nodes/primary_nodes/primary_base_node/#cript.nodes.primary_nodes.primary_base_node.PrimaryBaseNode","title":"<code>PrimaryBaseNode</code>","text":"<p>             Bases: <code>UUIDBaseNode</code>, <code>ABC</code></p> <p>Abstract class that defines what it means to be a PrimaryNode, and other primary nodes can inherit from.</p> Source code in <code>src/cript/nodes/primary_nodes/primary_base_node.py</code> <pre><code>class PrimaryBaseNode(UUIDBaseNode, ABC):\n    \"\"\"\n    Abstract class that defines what it means to be a PrimaryNode,\n    and other primary nodes can inherit from.\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        \"\"\"\n        All shared attributes between all Primary nodes and set to their default values\n        \"\"\"\n\n        locked: bool = False\n        model_version: str = \"\"\n        public: bool = False\n        name: str = \"\"\n        notes: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, name: str, notes: str, **kwargs):\n        # initialize Base class with node\n        super().__init__(**kwargs)\n        # replace name and notes within PrimaryBase\n        self._json_attrs = replace(self._json_attrs, name=name, notes=notes)\n\n    @beartype\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of a primary node dataclass attributes.\n        Every node that inherits from this class should overwrite it to best fit\n        their use case, but this provides a nice default value just in case\n\n        Examples\n        --------\n        {\n        'locked': False,\n        'model_version': '',\n        'public': False,\n        'notes': ''\n        }\n\n\n        Returns\n        -------\n        str\n            A string representation of the primary node common attributes.\n        \"\"\"\n        return super().__str__()\n\n    @property\n    @beartype\n    def locked(self):\n        return self._json_attrs.locked\n\n    @property\n    @beartype\n    def model_version(self):\n        return self._json_attrs.model_version\n\n    @property\n    @beartype\n    def updated_by(self):\n        return self._json_attrs.updated_by\n\n    @property\n    @beartype\n    def created_by(self):\n        return self._json_attrs.created_by\n\n    @property\n    @beartype\n    def public(self):\n        return self._json_attrs.public\n\n    @property\n    @beartype\n    def name(self):\n        return self._json_attrs.name\n\n    @name.setter\n    @beartype\n    def name(self, new_name: str) -&gt; None:\n        \"\"\"\n        set the PrimaryBaseNode name\n\n        Parameters\n        ----------\n        new_name: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, name=new_name)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def notes(self):\n        return self._json_attrs.notes\n\n    @notes.setter\n    @beartype\n    def notes(self, new_notes: str) -&gt; None:\n        \"\"\"\n        allow every node that inherits base attributes to set its notes\n        \"\"\"\n        new_attrs = replace(self._json_attrs, notes=new_notes)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/primary_base_node/#cript.nodes.primary_nodes.primary_base_node.PrimaryBaseNode.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>All shared attributes between all Primary nodes and set to their default values</p> Source code in <code>src/cript/nodes/primary_nodes/primary_base_node.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(UUIDBaseNode.JsonAttributes):\n    \"\"\"\n    All shared attributes between all Primary nodes and set to their default values\n    \"\"\"\n\n    locked: bool = False\n    model_version: str = \"\"\n    public: bool = False\n    name: str = \"\"\n    notes: str = \"\"\n</code></pre>"},{"location":"nodes/primary_nodes/primary_base_node/#cript.nodes.primary_nodes.primary_base_node.PrimaryBaseNode.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of a primary node dataclass attributes. Every node that inherits from this class should overwrite it to best fit their use case, but this provides a nice default value just in case</p> <p>Examples:</p> <p>{ 'locked': False, 'model_version': '', 'public': False, 'notes': '' }</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the primary node common attributes.</p> Source code in <code>src/cript/nodes/primary_nodes/primary_base_node.py</code> <pre><code>@beartype\ndef __str__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of a primary node dataclass attributes.\n    Every node that inherits from this class should overwrite it to best fit\n    their use case, but this provides a nice default value just in case\n\n    Examples\n    --------\n    {\n    'locked': False,\n    'model_version': '',\n    'public': False,\n    'notes': ''\n    }\n\n\n    Returns\n    -------\n    str\n        A string representation of the primary node common attributes.\n    \"\"\"\n    return super().__str__()\n</code></pre>"},{"location":"nodes/primary_nodes/process/","title":"Process","text":""},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process","title":"<code>Process</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process--definition","title":"Definition","text":"<p>The process node contains a list of ingredients, quantities, and procedure information for an experimental material transformation (chemical and physical).</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process--attributes","title":"Attributes","text":"attribute type example description required vocab type str mix type of process True True ingredient list[Ingredient] ingredients description str To oven-dried 20 mL glass vial, 5 mL of styrene and 10 ml of toluene was added. explanation of the process equipment list[Equipment] equipment used in the process product list[Material] desired material produced from the process waste list[Material] material sent to waste prerequisite_ processes list[Process] processes that must be completed prior to the start of this process condition list[Condition] global process condition property list[Property] process properties keyword list[str] words that classify the process True citation list[Citation] reference to a book, paper, or scholarly work notes str miscellaneous information, or custom data structure"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process--can-be-added-to","title":"Can be added to","text":"<ul> <li>Experiment</li> </ul>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process--available-subobjects","title":"Available Subobjects","text":"<ul> <li>Ingredient</li> <li>Equipment</li> <li>Property</li> <li>Condition</li> <li>Citation</li> </ul>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my minimal process name\",\n   \"node\":[\"Process\"],\n   \"type\":\"affinity_pure\",\n   \"keyword\":[],\n   \"uid\":\"_:f8ef33f3-677a-40f3-b24e-65ab2c99d796\",\n   \"uuid\":\"f8ef33f3-677a-40f3-b24e-65ab2c99d796\"\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/process.py</code> <pre><code>class Process(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n    The process node contains a list of [ingredients](../../subobjects/ingredient),\n    [quantities](../../subobjects/quantity), and procedure information for an experimental\n    [material](../material) transformation (chemical and physical).\n\n    ## Attributes\n\n    | attribute               | type             | example                                                                         | description                                                         | required | vocab |\n    |-------------------------|------------------|---------------------------------------------------------------------------------|---------------------------------------------------------------------|----------|-------|\n    | type                    | str              | mix                                                                             | type of process                                                     | True     | True  |\n    | ingredient              | list[Ingredient] |                                                                                 | ingredients                                                         |          |       |\n    | description             | str              | To oven-dried 20 mL glass vial, 5 mL of styrene and 10 ml of toluene was added. | explanation of the process                                          |          |       |\n    | equipment               | list[Equipment]  |                                                                                 | equipment used in the process                                       |          |       |\n    | product                 | list[Material]   |                                                                                 | desired material produced from the process                          |          |       |\n    | waste                   | list[Material]   |                                                                                 | material sent to waste                                              |          |       |\n    | prerequisite_ processes | list[Process]    |                                                                                 | processes that must be completed prior to the start of this process |          |       |\n    | condition               | list[Condition]  |                                                                                 | global process condition                                            |          |       |\n    | property                | list[Property]   |                                                                                 | process properties                                                  |          |       |\n    | keyword                 | list[str]        |                                                                                 | words that classify the process                                     |          | True  |\n    | citation                | list[Citation]   |                                                                                 | reference to a book, paper, or scholarly work                       |          |       |\n    | notes                   | str              |                                                                                 | miscellaneous information, or custom data structure                 |          |       |\n\n    ## Can be added to\n    * [Experiment](../experiment)\n\n    ## Available Subobjects\n    * [Ingredient](../../subobjects/ingredient)\n    * [Equipment](../../subobjects/equipment)\n    * [Property](../../subobjects/property)\n    * [Condition](../../subobjects/condition)\n    * [Citation](../../subobjects/citation)\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my minimal process name\",\n       \"node\":[\"Process\"],\n       \"type\":\"affinity_pure\",\n       \"keyword\":[],\n       \"uid\":\"_:f8ef33f3-677a-40f3-b24e-65ab2c99d796\",\n       \"uuid\":\"f8ef33f3-677a-40f3-b24e-65ab2c99d796\"\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Process attributes\n        \"\"\"\n\n        type: str = \"\"\n        # TODO add proper typing in future, using Any for now to avoid circular import error\n        ingredient: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        description: str = \"\"\n        equipment: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        product: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        waste: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        prerequisite_process: List[Union[\"Process\", UIDProxy]] = field(default_factory=list)\n        condition: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        property: List[Union[Any, UIDProxy]] = field(default_factory=list)\n        keyword: List[str] = field(default_factory=list)\n        citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        name: str,\n        type: str,\n        ingredient: Optional[List[Union[Any, UIDProxy]]] = None,\n        description: str = \"\",\n        equipment: Optional[List[Union[Any, UIDProxy]]] = None,\n        product: Optional[List[Union[Any, UIDProxy]]] = None,\n        waste: Optional[List[Union[Any, UIDProxy]]] = None,\n        prerequisite_process: Optional[List[Union[\"Process\", UIDProxy]]] = None,\n        condition: Optional[List[Union[Any, UIDProxy]]] = None,\n        property: Optional[List[Union[Any, UIDProxy]]] = None,\n        keyword: Optional[List[str]] = None,\n        citation: Optional[List[Union[Any, UIDProxy]]] = None,\n        notes: str = \"\",\n        **kwargs\n    ) -&gt; None:\n        \"\"\"\n        create a process node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n\n        Parameters\n        ----------\n        ingredient: List[Ingredient]\n            [ingredient](../../subobjects/ingredient) used in this process\n        type: str = \"\"\n            Process type must come from\n            [CRIPT Controlled vocabulary process type](https://app.criptapp.org/vocab/process_type/)\n        description: str = \"\"\n            description of this process\n        equipment: List[Equipment] = None\n            list of [equipment](../../subobjects/equipment) used in this process\n        product: List[Material] = None\n            product that this process created\n        waste: List[Material] = None\n            waste that this process created\n        condition: List[Condition] = None\n            list of [condition](../../subobjects/condition) that this process was created under\n        property: List[Property] = None\n            list of [properties](../../subobjects/property) for this process\n        keyword: List[str] = None\n            list of keywords for this process must come from\n            [CRIPT process keyword controlled keyword](https://app.criptapp.org/vocab/process_keyword/)\n        citation: List[Citation] = None\n            list of [citation](../../subobjects/citation)\n\n        Returns\n        -------\n        None\n            instantiate a process node\n        \"\"\"\n\n        if ingredient is None:\n            ingredient = []\n\n        if equipment is None:\n            equipment = []\n\n        if product is None:\n            product = []\n\n        if waste is None:\n            waste = []\n\n        if prerequisite_process is None:\n            prerequisite_process = []\n\n        if condition is None:\n            condition = []\n\n        if property is None:\n            property = []\n\n        if keyword is None:\n            keyword = []\n\n        if citation is None:\n            citation = []\n\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        new_attrs = replace(\n            self._json_attrs,\n            ingredient=ingredient,\n            type=type,\n            description=description,\n            equipment=equipment,\n            product=product,\n            waste=waste,\n            condition=condition,\n            prerequisite_process=prerequisite_process,\n            property=property,\n            keyword=keyword,\n            citation=citation,\n        )\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        [Process type](https://app.criptapp.org/vocab/process_type) must come from the CRIPT controlled vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_process.type = \"affinity_pure\"\n\n        Returns\n        -------\n        str\n            Select a [Process type](https://app.criptapp.org/vocab/process_type/) from CRIPT controlled vocabulary\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_process_type: str) -&gt; None:\n        \"\"\"\n        set process type from CRIPT controlled vocabulary\n\n        Parameters\n        ----------\n        new_process_type: str\n            new process type from CRIPT controlled vocabulary\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_process_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def ingredient(self) -&gt; List[Any]:\n        \"\"\"\n        List of [ingredient](../../subobjects/ingredient) for this process\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"material bigsmiles\")\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n        ... )\n        &gt;&gt;&gt; my_process.ingredient = [my_ingredient]\n\n        Returns\n        -------\n        List[Ingredient]\n            list of ingredients for this process\n        \"\"\"\n        return self._json_attrs.ingredient.copy()\n\n    @ingredient.setter\n    @beartype\n    def ingredient(self, new_ingredient_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of the ingredients for this process\n\n        Parameters\n        ----------\n        new_ingredient_list\n            list of ingredients to replace the current list\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, ingredient=new_ingredient_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def description(self) -&gt; str:\n        \"\"\"\n        description of this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_process.description = \"To oven-dried 20 mL glass vial, 5 mL of styrene and 10 ml of toluene was added\"\n\n        Returns\n        -------\n        str\n            description of this process\n        \"\"\"\n        return self._json_attrs.description\n\n    @description.setter\n    @beartype\n    def description(self, new_description: str) -&gt; None:\n        \"\"\"\n        set the description of this process\n\n        Parameters\n        ----------\n        new_description: str\n            new process description to replace the current one\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, description=new_description)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def equipment(self) -&gt; List[Any]:\n        \"\"\"\n        List of [equipment](../../subobjects/equipment) used for this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n        &gt;&gt;&gt; my_process.equipment = [my_equipment]\n\n        Returns\n        -------\n        List[Equipment]\n            list of equipment used for this process\n        \"\"\"\n        return self._json_attrs.equipment.copy()\n\n    @equipment.setter\n    @beartype\n    def equipment(self, new_equipment_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of equipment used for this process\n\n        Parameters\n        ----------\n        new_equipment_list\n            new equipment list to replace the current equipment list for this process\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, equipment=new_equipment_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def product(self) -&gt; List[Any]:\n        \"\"\"\n        List of product (material nodes) for this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_product_material = cript.Material(\n        ...     name=\"my product material\",\n        ...     amino_acid = \"my material product amino_acid\",\n        ... )\n        &gt;&gt;&gt; my_process.product = [my_product_material]\n\n        Returns\n        -------\n        List[Material]\n            List of process product (Material nodes)\n        \"\"\"\n        return self._json_attrs.product.copy()\n\n    @product.setter\n    @beartype\n    def product(self, new_product_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the product list for this process\n\n        Parameters\n        ----------\n        new_product_list: List[Material]\n            replace the current list of process product\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, product=new_product_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def waste(self) -&gt; List[Any]:\n        \"\"\"\n        List of waste that resulted from this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_waste_material = cript.Material(\n        ...     name=\"my waste material\",\n        ...     bigsmiles = \"123456\",\n        ... )\n        &gt;&gt;&gt; my_process.waste = [my_waste_material]\n\n        Returns\n        -------\n        List[Material]\n            list of waste materials that resulted from this product\n        \"\"\"\n        return self._json_attrs.waste.copy()\n\n    @waste.setter\n    @beartype\n    def waste(self, new_waste_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of waste (Material node) for that resulted from this process\n\n        Parameters\n        ----------\n        new_waste_list: List[Material]\n            replace the list waste that resulted from this process\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, waste=new_waste_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def prerequisite_process(self) -&gt; List[Union[\"Process\", UIDProxy]]:\n        \"\"\"\n        list of prerequisite process nodes\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_prerequisite_process = [\n        ...     cript.Process(name=\"prerequisite processes 1\", type=\"blow_molding\"),\n        ...     cript.Process(name=\"prerequisite processes 2\", type=\"centrifugation\"),\n        ... ]\n        &gt;&gt;&gt; my_process.prerequisite_process = my_prerequisite_process\n\n        Returns\n        -------\n        List[Process]\n            list of process that had to happen before this process\n        \"\"\"\n        return self._json_attrs.prerequisite_process.copy()\n\n    @prerequisite_process.setter\n    @beartype\n    def prerequisite_process(self, new_prerequisite_process_list: List[Union[\"Process\", UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the prerequisite_process for the process node\n\n        Parameters\n        ----------\n        new_prerequisite_process_list: List[\"Process\"]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, prerequisite_process=new_prerequisite_process_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def condition(self) -&gt; List[Any]:\n        \"\"\"\n        List of condition present for this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"min\", value=1)\n        &gt;&gt;&gt; my_process.condition = [my_condition]\n\n        Returns\n        -------\n        List[Condition]\n            list of condition for this process node\n        \"\"\"\n        return self._json_attrs.condition.copy()\n\n    @condition.setter\n    @beartype\n    def condition(self, new_condition_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of condition for this process\n\n        Parameters\n        ----------\n        new_condition_list: List[Condition]\n            replace the condition list\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, condition=new_condition_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def keyword(self) -&gt; List[str]:\n        \"\"\"\n        List of keyword for this process\n        [Process keyword](https://app.criptapp.org/vocab/process_keyword/) must come from CRIPT controlled vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_process.keyword = [\"self_assembly\"]\n\n        Returns\n        -------\n        List[str]\n            list of keywords for this process nod\n        \"\"\"\n        return self._json_attrs.keyword.copy()  # type: ignore\n\n    @keyword.setter\n    @beartype\n    def keyword(self, new_keyword_list: List[str]) -&gt; None:\n        \"\"\"\n        set the list of keyword for this process from CRIPT controlled vocabulary\n\n        Parameters\n        ----------\n        new_keyword_list: List[str]\n            replace the current list of keyword\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # TODO validate with CRIPT controlled vocabulary\n        new_attrs = replace(self._json_attrs, keyword=new_keyword_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Any]:\n        \"\"\"\n        List of [citation](../subobjects/citation.md) for this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n        &gt;&gt;&gt; my_process.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of citation for this process node\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of citation for this process\n\n        Parameters\n        ----------\n        new_citation_list: List[Citation]\n            replace the current list of citation\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def property(self) -&gt; List[Any]:\n        \"\"\"\n        List of [Property nodes](../../subobjects/property) for this process\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.23, unit=\"J\")\n        &gt;&gt;&gt; my_process.property = [my_property]\n\n        Returns\n        -------\n        List[Property]\n            list of properties for this process\n        \"\"\"\n        return self._json_attrs.property.copy()\n\n    @property.setter\n    @beartype\n    def property(self, new_property_list: List[Any]) -&gt; None:\n        \"\"\"\n        set the list of Property nodes for this process\n\n        Parameters\n        ----------\n        new_property_list: List[Property]\n            replace the current list of properties\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, property=new_property_list)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.citation","title":"<code>citation: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of citation for this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"derived_from\", reference=my_reference)\n&gt;&gt;&gt; my_process.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of citation for this process node</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.condition","title":"<code>condition: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of condition present for this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"min\", value=1)\n&gt;&gt;&gt; my_process.condition = [my_condition]\n</code></pre> <p>Returns:</p> Type Description <code>List[Condition]</code> <p>list of condition for this process node</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.description","title":"<code>description: str</code>  <code>property</code> <code>writable</code>","text":"<p>description of this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_process.description = \"To oven-dried 20 mL glass vial, 5 mL of styrene and 10 ml of toluene was added\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>description of this process</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.equipment","title":"<code>equipment: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of equipment used for this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n&gt;&gt;&gt; my_process.equipment = [my_equipment]\n</code></pre> <p>Returns:</p> Type Description <code>List[Equipment]</code> <p>list of equipment used for this process</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.ingredient","title":"<code>ingredient: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of ingredient for this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"material bigsmiles\")\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient = cript.Ingredient(\n...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n... )\n&gt;&gt;&gt; my_process.ingredient = [my_ingredient]\n</code></pre> <p>Returns:</p> Type Description <code>List[Ingredient]</code> <p>list of ingredients for this process</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.keyword","title":"<code>keyword: List[str]</code>  <code>property</code> <code>writable</code>","text":"<p>List of keyword for this process Process keyword must come from CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_process.keyword = [\"self_assembly\"]\n</code></pre> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of keywords for this process nod</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.prerequisite_process","title":"<code>prerequisite_process: List[Union[Process, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of prerequisite process nodes</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_prerequisite_process = [\n...     cript.Process(name=\"prerequisite processes 1\", type=\"blow_molding\"),\n...     cript.Process(name=\"prerequisite processes 2\", type=\"centrifugation\"),\n... ]\n&gt;&gt;&gt; my_process.prerequisite_process = my_prerequisite_process\n</code></pre> <p>Returns:</p> Type Description <code>List[Process]</code> <p>list of process that had to happen before this process</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.product","title":"<code>product: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of product (material nodes) for this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_product_material = cript.Material(\n...     name=\"my product material\",\n...     amino_acid = \"my material product amino_acid\",\n... )\n&gt;&gt;&gt; my_process.product = [my_product_material]\n</code></pre> <p>Returns:</p> Type Description <code>List[Material]</code> <p>List of process product (Material nodes)</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.property","title":"<code>property: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of Property nodes for this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.23, unit=\"J\")\n&gt;&gt;&gt; my_process.property = [my_property]\n</code></pre> <p>Returns:</p> Type Description <code>List[Property]</code> <p>list of properties for this process</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>Process type must come from the CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_process.type = \"affinity_pure\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Select a Process type from CRIPT controlled vocabulary</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.waste","title":"<code>waste: List[Any]</code>  <code>property</code> <code>writable</code>","text":"<p>List of waste that resulted from this process</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_waste_material = cript.Material(\n...     name=\"my waste material\",\n...     bigsmiles = \"123456\",\n... )\n&gt;&gt;&gt; my_process.waste = [my_waste_material]\n</code></pre> <p>Returns:</p> Type Description <code>List[Material]</code> <p>list of waste materials that resulted from this product</p>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Process attributes</p> Source code in <code>src/cript/nodes/primary_nodes/process.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Process attributes\n    \"\"\"\n\n    type: str = \"\"\n    # TODO add proper typing in future, using Any for now to avoid circular import error\n    ingredient: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    description: str = \"\"\n    equipment: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    product: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    waste: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    prerequisite_process: List[Union[\"Process\", UIDProxy]] = field(default_factory=list)\n    condition: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    property: List[Union[Any, UIDProxy]] = field(default_factory=list)\n    keyword: List[str] = field(default_factory=list)\n    citation: List[Union[Any, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/process/#cript.nodes.primary_nodes.process.Process.__init__","title":"<code>__init__(name, type, ingredient=None, description='', equipment=None, product=None, waste=None, prerequisite_process=None, condition=None, property=None, keyword=None, citation=None, notes='', **kwargs)</code>","text":"<p>create a process node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ingredient</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>ingredient used in this process</p> <code>None</code> <code>type</code> <code>str</code> <p>Process type must come from CRIPT Controlled vocabulary process type</p> required <code>description</code> <code>str</code> <p>description of this process</p> <code>''</code> <code>equipment</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of equipment used in this process</p> <code>None</code> <code>product</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>product that this process created</p> <code>None</code> <code>waste</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>waste that this process created</p> <code>None</code> <code>condition</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of condition that this process was created under</p> <code>None</code> <code>property</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of properties for this process</p> <code>None</code> <code>keyword</code> <code>Optional[List[str]]</code> <p>list of keywords for this process must come from CRIPT process keyword controlled keyword</p> <code>None</code> <code>citation</code> <code>Optional[List[Union[Any, UIDProxy]]]</code> <p>list of citation</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>instantiate a process node</p> Source code in <code>src/cript/nodes/primary_nodes/process.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    name: str,\n    type: str,\n    ingredient: Optional[List[Union[Any, UIDProxy]]] = None,\n    description: str = \"\",\n    equipment: Optional[List[Union[Any, UIDProxy]]] = None,\n    product: Optional[List[Union[Any, UIDProxy]]] = None,\n    waste: Optional[List[Union[Any, UIDProxy]]] = None,\n    prerequisite_process: Optional[List[Union[\"Process\", UIDProxy]]] = None,\n    condition: Optional[List[Union[Any, UIDProxy]]] = None,\n    property: Optional[List[Union[Any, UIDProxy]]] = None,\n    keyword: Optional[List[str]] = None,\n    citation: Optional[List[Union[Any, UIDProxy]]] = None,\n    notes: str = \"\",\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    create a process node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n\n    Parameters\n    ----------\n    ingredient: List[Ingredient]\n        [ingredient](../../subobjects/ingredient) used in this process\n    type: str = \"\"\n        Process type must come from\n        [CRIPT Controlled vocabulary process type](https://app.criptapp.org/vocab/process_type/)\n    description: str = \"\"\n        description of this process\n    equipment: List[Equipment] = None\n        list of [equipment](../../subobjects/equipment) used in this process\n    product: List[Material] = None\n        product that this process created\n    waste: List[Material] = None\n        waste that this process created\n    condition: List[Condition] = None\n        list of [condition](../../subobjects/condition) that this process was created under\n    property: List[Property] = None\n        list of [properties](../../subobjects/property) for this process\n    keyword: List[str] = None\n        list of keywords for this process must come from\n        [CRIPT process keyword controlled keyword](https://app.criptapp.org/vocab/process_keyword/)\n    citation: List[Citation] = None\n        list of [citation](../../subobjects/citation)\n\n    Returns\n    -------\n    None\n        instantiate a process node\n    \"\"\"\n\n    if ingredient is None:\n        ingredient = []\n\n    if equipment is None:\n        equipment = []\n\n    if product is None:\n        product = []\n\n    if waste is None:\n        waste = []\n\n    if prerequisite_process is None:\n        prerequisite_process = []\n\n    if condition is None:\n        condition = []\n\n    if property is None:\n        property = []\n\n    if keyword is None:\n        keyword = []\n\n    if citation is None:\n        citation = []\n\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    new_attrs = replace(\n        self._json_attrs,\n        ingredient=ingredient,\n        type=type,\n        description=description,\n        equipment=equipment,\n        product=product,\n        waste=waste,\n        condition=condition,\n        prerequisite_process=prerequisite_process,\n        property=property,\n        keyword=keyword,\n        citation=citation,\n    )\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/project/","title":"Project","text":""},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project","title":"<code>Project</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project--definition","title":"Definition","text":"<p>A Project is the highest level node that is Not nested inside any other node. A Project can be thought of as a folder that can contain Collections and Materials.</p> attribute type description collection List[Collection] collections that relate to the project materials List[Materials] materials owned by the project notes str miscellaneous information, or custom data structure"},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"my project name\",\n   \"node\":[\"Project\"],\n   \"uid\":\"_:270168b7-fc29-4c37-aa93-334212e1d962\",\n   \"uuid\":\"270168b7-fc29-4c37-aa93-334212e1d962\",\n   \"collection\":[\n      {\n        \"name\":\"my collection name\",\n         \"node\":[\"Collection\"],\n         \"uid\":\"_:c60955a5-4de0-4da5-b2c8-77952b1d9bfa\",\n         \"uuid\":\"c60955a5-4de0-4da5-b2c8-77952b1d9bfa\",\n         \"experiment\":[\n            {\n               \"name\":\"my experiment name\",\n               \"node\":[\"Experiment\"],\n               \"uid\":\"_:a8cbc083-506e-45ce-bb8f-5e50917ab361\",\n               \"uuid\":\"a8cbc083-506e-45ce-bb8f-5e50917ab361\"\n            }\n         ],\n         \"inventory\":[],\n         \"citation\":[]\n      }\n   ]\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/project.py</code> <pre><code>class Project(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n    A [Project](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=7)\n    is the highest level node that is Not nested inside any other node.\n    A Project can be thought of as a folder that can contain [Collections](../collection) and\n    [Materials](../material).\n\n\n    | attribute  | type             | description                                         |\n    |------------|------------------|-----------------------------------------------------|\n    | collection | List[Collection] | collections that relate to the project              |\n    | materials  | List[Materials]  | materials owned by the project                      |\n    | notes      | str              | miscellaneous information, or custom data structure |\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"my project name\",\n       \"node\":[\"Project\"],\n       \"uid\":\"_:270168b7-fc29-4c37-aa93-334212e1d962\",\n       \"uuid\":\"270168b7-fc29-4c37-aa93-334212e1d962\",\n       \"collection\":[\n          {\n            \"name\":\"my collection name\",\n             \"node\":[\"Collection\"],\n             \"uid\":\"_:c60955a5-4de0-4da5-b2c8-77952b1d9bfa\",\n             \"uuid\":\"c60955a5-4de0-4da5-b2c8-77952b1d9bfa\",\n             \"experiment\":[\n                {\n                   \"name\":\"my experiment name\",\n                   \"node\":[\"Experiment\"],\n                   \"uid\":\"_:a8cbc083-506e-45ce-bb8f-5e50917ab361\",\n                   \"uuid\":\"a8cbc083-506e-45ce-bb8f-5e50917ab361\"\n                }\n             ],\n             \"inventory\":[],\n             \"citation\":[]\n          }\n       ]\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all Project attributes\n        \"\"\"\n\n        member: List[Union[User, UIDProxy]] = field(default_factory=list)\n        admin: List[Union[User, UIDProxy]] = field(default_factory=list)\n        collection: List[Union[Collection, UIDProxy]] = field(default_factory=list)\n        material: List[Union[Material, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, name: str, collection: Optional[List[Union[Collection, UIDProxy]]] = None, material: Optional[List[Union[Material, UIDProxy]]] = None, notes: str = \"\", **kwargs):\n        \"\"\"\n        Create a Project node with Project name\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n\n\n        Parameters\n        ----------\n        name: str\n            project name\n        collection: List[Collection]\n            list of Collections that belongs to this Project\n         material: List[Material]\n            list of materials that belongs to this project\n        notes: str\n            notes for this project\n\n        Returns\n        -------\n        None\n            instantiate a Project node\n        \"\"\"\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        if collection is None:\n            collection = []\n\n        if material is None:\n            material = []\n\n        new_json_attrs = replace(self._json_attrs, name=name, collection=collection, material=material)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    def validate(self, api=None, is_patch=False, force_validation: bool = False):\n        from cript.nodes.exceptions import CRIPTOrphanedMaterialWarning\n        from cript.nodes.util.core import get_orphaned_experiment_exception\n\n        # First validate like other nodes\n        super().validate(api=api, is_patch=is_patch, force_validation=force_validation)\n\n        # Check graph for orphaned nodes, that should be listed in project\n        # Project.materials should contain all material nodes\n        project_graph_materials = self.find_children({\"node\": [\"Material\"]})\n        # Combine all materials listed in the project inventories\n        project_inventory_materials = []\n        for inventory in self.find_children({\"node\": [\"Inventory\"]}):\n            for material in inventory.material:\n                project_inventory_materials.append(material)\n        for material in project_graph_materials:\n            if material not in self.material and material not in project_inventory_materials:\n                warnings.warn(CRIPTOrphanedMaterialWarning(material))\n\n        # Check graph for orphaned nodes, that should be listed in the experiments\n        project_experiments = self.find_children({\"node\": [\"Experiment\"]})\n        # There are 4 different types of nodes Experiments are collecting.\n        node_types = (\"Process\", \"Computation\", \"ComputationProcess\", \"Data\")\n        # We loop over them with the same logic\n        for node_type in node_types:\n            # All in the graph has to be in at least one experiment\n            project_graph_nodes = self.find_children({\"node\": [node_type]})\n            node_type_attr = node_type.lower()\n            # Non-consistent naming makes this necessary for Computation Process\n            if node_type == \"ComputationProcess\":\n                node_type_attr = \"computation_process\"\n\n            # Concatenation of all experiment attributes (process, computation, etc.)\n            # Every node of the graph must be present somewhere in this concatenated list.\n            experiment_nodes = []\n            for experiment in project_experiments:\n                for ex_node in getattr(experiment, node_type_attr):\n                    experiment_nodes.append(ex_node)\n            for node in project_graph_nodes:\n                if node not in experiment_nodes:\n                    warnings.warn(get_orphaned_experiment_exception(node))\n\n    @property\n    @beartype\n    def member(self) -&gt; List[Union[User, UIDProxy]]:\n        return self._json_attrs.member.copy()\n\n    @property\n    @beartype\n    def admin(self) -&gt; List[Union[User, UIDProxy]]:\n        return self._json_attrs.admin\n\n    @property\n    @beartype\n    def collection(self) -&gt; List[Union[Collection, UIDProxy]]:\n        \"\"\"\n        Collection is a Project node's property that can be set during creation in the constructor\n        or later by setting the project's property\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n        &gt;&gt;&gt; my_new_collection = cript.Collection(name=\"my collection name\")\n        &gt;&gt;&gt; my_project.collection = [my_new_collection]\n\n        Returns\n        -------\n        Collection: List[Collection]\n            the list of collections within this project\n        \"\"\"\n        return self._json_attrs.collection\n\n    @collection.setter\n    @beartype\n    def collection(self, new_collection: List[Union[Collection, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set list of collections for the project node\n\n        Parameters\n        ----------\n        new_collection: List[Collection]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, collection=new_collection)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def material(self) -&gt; List[Union[Material, UIDProxy]]:\n        \"\"\"\n        List of Materials that belong to this Project.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles=\"my bigsmiles\")\n        &gt;&gt;&gt; my_project.material = [my_material]\n\n        Returns\n        -------\n        Material: List[Material]\n            List of materials that belongs to this project\n        \"\"\"\n        return self._json_attrs.material\n\n    @material.setter\n    @beartype\n    def material(self, new_materials: List[Union[Material, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of materials for this project\n\n        Parameters\n        ----------\n        new_materials: List[Material]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, material=new_materials)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project.collection","title":"<code>collection: List[Union[Collection, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>Collection is a Project node's property that can be set during creation in the constructor or later by setting the project's property</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n&gt;&gt;&gt; my_new_collection = cript.Collection(name=\"my collection name\")\n&gt;&gt;&gt; my_project.collection = [my_new_collection]\n</code></pre> <p>Returns:</p> Name Type Description <code>Collection</code> <code>List[Collection]</code> <p>the list of collections within this project</p>"},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project.material","title":"<code>material: List[Union[Material, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>List of Materials that belong to this Project.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles=\"my bigsmiles\")\n&gt;&gt;&gt; my_project.material = [my_material]\n</code></pre> <p>Returns:</p> Name Type Description <code>Material</code> <code>List[Material]</code> <p>List of materials that belongs to this project</p>"},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all Project attributes</p> Source code in <code>src/cript/nodes/primary_nodes/project.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all Project attributes\n    \"\"\"\n\n    member: List[Union[User, UIDProxy]] = field(default_factory=list)\n    admin: List[Union[User, UIDProxy]] = field(default_factory=list)\n    collection: List[Union[Collection, UIDProxy]] = field(default_factory=list)\n    material: List[Union[Material, UIDProxy]] = field(default_factory=list)\n</code></pre>"},{"location":"nodes/primary_nodes/project/#cript.nodes.primary_nodes.project.Project.__init__","title":"<code>__init__(name, collection=None, material=None, notes='', **kwargs)</code>","text":"<p>Create a Project node with Project name</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>project name</p> required <code>collection</code> <code>Optional[List[Union[Collection, UIDProxy]]]</code> <p>list of Collections that belongs to this Project material: List[Material] list of materials that belongs to this project</p> <code>None</code> <code>notes</code> <code>str</code> <p>notes for this project</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>instantiate a Project node</p> Source code in <code>src/cript/nodes/primary_nodes/project.py</code> <pre><code>@beartype\ndef __init__(self, name: str, collection: Optional[List[Union[Collection, UIDProxy]]] = None, material: Optional[List[Union[Material, UIDProxy]]] = None, notes: str = \"\", **kwargs):\n    \"\"\"\n    Create a Project node with Project name\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_project = cript.Project(name=\"my Project name\")\n\n\n    Parameters\n    ----------\n    name: str\n        project name\n    collection: List[Collection]\n        list of Collections that belongs to this Project\n     material: List[Material]\n        list of materials that belongs to this project\n    notes: str\n        notes for this project\n\n    Returns\n    -------\n    None\n        instantiate a Project node\n    \"\"\"\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    if collection is None:\n        collection = []\n\n    if material is None:\n        material = []\n\n    new_json_attrs = replace(self._json_attrs, name=name, collection=collection, material=material)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/reference/","title":"Reference","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference--definition","title":"Definition","text":"<p>The Reference node contains the metadata for a literature publication, book, or anything external to CRIPT. The reference node does NOT contain the base attributes.</p> <p>The reference node is always used inside the citation sub-object to enable users to specify the context of the reference.</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference--attributes","title":"Attributes","text":"attribute type example description required vocab type str journal_article type of literature True True title str 'Living' Polymers title of publication True author list[str] Michael Szwarc list of authors journal str Nature journal of the publication publisher str Springer publisher of publication year int 1956 year of publication volume int 178 volume of publication issue int 0 issue of publication pages list[int] [1168, 1169] page range of publication doi str 10.1038/1781168a0 DOI: digital object identifier Conditionally issn str 1476-4687 ISSN: international standard serial number Conditionally arxiv_id str 1501 arXiv identifier pmid int ######## PMID: PubMed ID website str https://www.nature.com/artic les/1781168a0 website where the publication can be accessed"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference--can-be-added-to","title":"Can be added to","text":"<ul> <li>Citation</li> </ul>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference--available-subobjects","title":"Available Subobjects","text":"<ul> <li>None</li> </ul> <p>Reference will always be public</p> <p>Reference node is meant to always be public and static to allow globally link data to the reference</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"node\":[\"Reference\"],\n   \"uid\":\"_:c681a947-0554-4acd-a01c-06ad76e34b87\",\n   \"uuid\":\"c681a947-0554-4acd-a01c-06ad76e34b87\",\n   \"author\":[\"Ludwig Schneider\",\"Marcus M\u00fcller\"],\n   \"doi\":\"10.1016/j.cpc.2018.08.011\",\n   \"issn\":\"0010-4655\",\n   \"journal\":\"Computer Physics Communications\",\n   \"pages\":[463,476],\n   \"publisher\":\"Elsevier\",\n   \"title\":\"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n   \"type\":\"journal_article\",\n   \"website\":\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n   \"year\":2019\n}\n</code></pre> Source code in <code>src/cript/nodes/primary_nodes/reference.py</code> <pre><code>class Reference(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n\n    The\n    [Reference node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=15)\n    contains the metadata for a literature publication, book, or anything external to CRIPT.\n    The reference node does NOT contain the base attributes.\n\n    The reference node is always used inside the citation\n    sub-object to enable users to specify the context of the reference.\n\n    ## Attributes\n    | attribute | type      | example                                    | description                                   | required      | vocab |\n    |-----------|-----------|--------------------------------------------|-----------------------------------------------|---------------|-------|\n    | type      | str       | journal_article                            | type of literature                            | True          | True  |\n    | title     | str       | 'Living' Polymers                          | title of publication                          | True          |       |\n    | author    | list[str] | Michael Szwarc                             | list of authors                               |               |       |\n    | journal   | str       | Nature                                     | journal of the publication                    |               |       |\n    | publisher | str       | Springer                                   | publisher of publication                      |               |       |\n    | year      | int       | 1956                                       | year of publication                           |               |       |\n    | volume    | int       | 178                                        | volume of publication                         |               |       |\n    | issue     | int       | 0                                          | issue of publication                          |               |       |\n    | pages     | list[int] | [1168, 1169]                               | page range of publication                     |               |       |\n    | doi       | str       | 10.1038/1781168a0                          | DOI: digital object identifier                | Conditionally |       |\n    | issn      | str       | 1476-4687                                  | ISSN: international standard serial number    | Conditionally |       |\n    | arxiv_id  | str       | 1501                                       | arXiv identifier                              |               |       |\n    | pmid      | int       | ########                                   | PMID: PubMed ID                               |               |       |\n    | website   | str       | https://www.nature.com/artic les/1781168a0 | website where the publication can be accessed |               |       |\n\n\n    ## Can be added to\n    * [Citation](../../subobjects/citation)\n\n    ## Available Subobjects\n    * None\n\n    !!! warning \"Reference will always be public\"\n        Reference node is meant to always be public and static to allow globally link data to the reference\n\n    ## JSON Representation\n    ```json\n    {\n       \"node\":[\"Reference\"],\n       \"uid\":\"_:c681a947-0554-4acd-a01c-06ad76e34b87\",\n       \"uuid\":\"c681a947-0554-4acd-a01c-06ad76e34b87\",\n       \"author\":[\"Ludwig Schneider\",\"Marcus M\u00fcller\"],\n       \"doi\":\"10.1016/j.cpc.2018.08.011\",\n       \"issn\":\"0010-4655\",\n       \"journal\":\"Computer Physics Communications\",\n       \"pages\":[463,476],\n       \"publisher\":\"Elsevier\",\n       \"title\":\"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n       \"type\":\"journal_article\",\n       \"website\":\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n       \"year\":2019\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        \"\"\"\n        all reference nodes attributes\n\n        all int types are also None type in case they are not present it should be properly shown as None\n        instead of a placeholder number such as 0 or -1\n        \"\"\"\n\n        type: str = \"\"\n        title: str = \"\"\n        author: List[str] = field(default_factory=list)\n        journal: str = \"\"\n        publisher: str = \"\"\n        year: Optional[int] = None\n        volume: Optional[int] = None\n        issue: Optional[int] = None\n        pages: List[int] = field(default_factory=list)\n        doi: str = \"\"\n        issn: str = \"\"\n        arxiv_id: str = \"\"\n        pmid: Optional[int] = None\n        website: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        type: str,\n        title: str,\n        author: Optional[List[str]] = None,\n        journal: str = \"\",\n        publisher: str = \"\",\n        year: Optional[int] = None,\n        volume: Optional[int] = None,\n        issue: Optional[int] = None,\n        pages: Optional[List[int]] = None,\n        doi: str = \"\",\n        issn: str = \"\",\n        arxiv_id: str = \"\",\n        pmid: Optional[int] = None,\n        website: str = \"\",\n        **kwargs,\n    ):\n        \"\"\"\n        create a reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n\n        Parameters\n        ----------\n        type: str\n            type of literature.\n            The [reference type](https://app.criptapp.org/vocab/reference_type/)\n            must come from CRIPT controlled vocabulary\n        title: str\n            title of publication\n        author: List[str] default=\"\"\n            list of authors\n        journal: str default=\"\"\n            journal of publication\n        publisher: str default=\"\"\n            publisher of publication\n        year: int default=None\n            year of publication\n        volume: int default=None\n            volume of publication\n        issue: int default=None\n            issue of publication\n        pages: List[int] default=None\n            page range of publication\n        doi: str default=\"\"\n            DOI: digital object identifier\n        issn: str default=\"\"\n            ISSN: international standard serial number\n        arxiv_id: str default=\"\"\n            arXiv identifier\n        pmid: int default=None\n            PMID: PubMed ID\n        website: str default=\"\"\n            website where the publication can be accessed\n\n        Returns\n        -------\n        None\n            Instantiate a reference node\n        \"\"\"\n        if author is None:\n            author = []\n\n        if pages is None:\n            pages = []\n\n        super().__init__(**kwargs)\n\n        new_attrs = replace(self._json_attrs, type=type, title=title, author=author, journal=journal, publisher=publisher, year=year, volume=volume, issue=issue, pages=pages, doi=doi, issn=issn, arxiv_id=arxiv_id, pmid=pmid, website=website)\n\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        Type of reference.\n\n        The [reference type](https://app.criptapp.org/vocab/reference_type)\n        must come from the CRIPT controlled vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.type = \"web_site\"\n\n        Returns\n        -------\n        str\n            reference type\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_reference_type: str) -&gt; None:\n        \"\"\"\n        set the reference type attribute\n\n        reference type must come from the CRIPT controlled vocabulary\n\n        Parameters\n        ----------\n        new_reference_type: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # TODO validate the reference type with CRIPT controlled vocabulary\n        new_attrs = replace(self._json_attrs, type=new_reference_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def title(self) -&gt; str:\n        \"\"\"\n        title of publication\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.title = \"my new title\"\n\n        Returns\n        -------\n        str\n            title of publication\n        \"\"\"\n        return self._json_attrs.title\n\n    @title.setter\n    @beartype\n    def title(self, new_title: str) -&gt; None:\n        \"\"\"\n        set the title for the reference node\n\n        Parameters\n        ----------\n        new_title: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, title=new_title)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def author(self) -&gt; List[str]:\n        \"\"\"\n        List of authors for this reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.author += [\"Navid Hariri\"]\n\n        Returns\n        -------\n        List[str]\n            list of authors\n        \"\"\"\n        return self._json_attrs.author.copy()\n\n    @author.setter\n    @beartype\n    def author(self, new_author: List[str]) -&gt; None:\n        \"\"\"\n        set the list of authors for the reference node\n\n        Parameters\n        ----------\n        new_author: List[str]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, author=new_author)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def journal(self) -&gt; str:\n        \"\"\"\n        journal of publication\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.journal = \"my new journal\"\n\n        Returns\n        -------\n        str\n            journal of publication\n        \"\"\"\n        return self._json_attrs.journal\n\n    @journal.setter\n    @beartype\n    def journal(self, new_journal: str) -&gt; None:\n        \"\"\"\n        set the journal attribute for this reference node\n\n        Parameters\n        ----------\n        new_journal: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, journal=new_journal)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def publisher(self) -&gt; str:\n        \"\"\"\n        publisher for this reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.publisher = \"my new publisher\"\n\n        Returns\n        -------\n        str\n            publisher of this publication\n        \"\"\"\n        return self._json_attrs.publisher\n\n    @publisher.setter\n    @beartype\n    def publisher(self, new_publisher: str) -&gt; None:\n        \"\"\"\n        set the publisher for this reference node\n\n        Parameters\n        ----------\n        new_publisher: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, publisher=new_publisher)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def year(self) -&gt; Union[int, None]:\n        \"\"\"\n        year for the scholarly work\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.year = 2023\n\n        Returns\n        -------\n        int\n        \"\"\"\n        return self._json_attrs.year\n\n    @year.setter\n    @beartype\n    def year(self, new_year: Union[int, None]) -&gt; None:\n        \"\"\"\n        set the year for the scholarly work within the reference node\n\n        Parameters\n        ----------\n        new_year: int\n\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, year=new_year)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def volume(self) -&gt; Union[int, None]:\n        \"\"\"\n        Volume of the scholarly work from the reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.volume = 1\n\n        Returns\n        -------\n        int\n            volume number of the publishing\n        \"\"\"\n        return self._json_attrs.volume\n\n    @volume.setter\n    @beartype\n    def volume(self, new_volume: Union[int, None]) -&gt; None:\n        \"\"\"\n        set the volume of the scholarly work for this reference node\n\n        Parameters\n        ----------\n        new_volume: int\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, volume=new_volume)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def issue(self) -&gt; Union[int, None]:\n        \"\"\"\n        issue of the scholarly work for the reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.issue = 2\n\n        Returns\n        -------\n        None\n        \"\"\"\n        return self._json_attrs.issue\n\n    @issue.setter\n    @beartype\n    def issue(self, new_issue: Union[int, None]) -&gt; None:\n        \"\"\"\n        set the issue of the scholarly work\n\n        Parameters\n        ----------\n        new_issue: int\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, issue=new_issue)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def pages(self) -&gt; List[int]:\n        \"\"\"\n        pages of the scholarly work used in the reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.pages = [123, 456]\n\n        Returns\n        -------\n        int\n        \"\"\"\n        return self._json_attrs.pages.copy()\n\n    @pages.setter\n    @beartype\n    def pages(self, new_pages_list: List[int]) -&gt; None:\n        \"\"\"\n        set the list of pages of the scholarly work for this reference node\n\n        Parameters\n        ----------\n        new_pages_list: List[int]\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, pages=new_pages_list)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def doi(self) -&gt; str:\n        \"\"\"\n        get the digital object identifier (DOI) for this reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.doi = \"100.1038/1781168a0\"\n\n        Returns\n        -------\n        str\n            digital object identifier (DOI) for this reference node\n        \"\"\"\n        return self._json_attrs.doi\n\n    @doi.setter\n    @beartype\n    def doi(self, new_doi: str) -&gt; None:\n        \"\"\"\n        set the digital object identifier (DOI) for the scholarly work for this reference node\n\n        Parameters\n        ----------\n        new_doi: str\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.doi = \"100.1038/1781168a0\"\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, doi=new_doi)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def issn(self) -&gt; str:\n        \"\"\"\n        The international standard serial number (ISSN) for this reference node\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.issn = \"1456-4687\"\n\n        Returns\n        -------\n        str\n            ISSN for this reference node\n        \"\"\"\n        return self._json_attrs.issn\n\n    @issn.setter\n    @beartype\n    def issn(self, new_issn: str) -&gt; None:\n        \"\"\"\n        set the international standard serial number (ISSN) for the scholarly work for this reference node\n\n        Parameters\n        ----------\n        new_issn: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, issn=new_issn)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def arxiv_id(self) -&gt; str:\n        \"\"\"\n        The arXiv identifier for the scholarly work for this reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.arxiv_id = \"1501\"\n\n        Returns\n        -------\n        str\n            arXiv identifier for the scholarly work for this publishing\n        \"\"\"\n        return self._json_attrs.arxiv_id\n\n    @arxiv_id.setter\n    @beartype\n    def arxiv_id(self, new_arxiv_id: str) -&gt; None:\n        \"\"\"\n        set the arXiv identifier for the scholarly work for this reference node\n\n        Parameters\n        ----------\n        new_arxiv_id: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, arxiv_id=new_arxiv_id)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def pmid(self) -&gt; Union[int, None]:\n        \"\"\"\n        The PubMed ID (PMID) for this reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.pmid = 12345678\n\n        Returns\n        -------\n        int\n            the PubMedID of this publishing\n        \"\"\"\n        return self._json_attrs.pmid\n\n    @pmid.setter\n    @beartype\n    def pmid(self, new_pmid: Union[int, None]) -&gt; None:\n        \"\"\"\n\n        Parameters\n        ----------\n        new_pmid\n\n        Returns\n        -------\n\n        \"\"\"\n        # TODO can possibly add validations, possibly in forms of length checking\n        #  to be sure its the correct length\n        new_attrs = replace(self._json_attrs, pmid=new_pmid)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def website(self) -&gt; str:\n        \"\"\"\n        The website URL for the scholarly work\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n        &gt;&gt;&gt; my_reference.website = \"https://criptapp.org\"\n\n        Returns\n        -------\n        str\n            the website URL of this publishing\n        \"\"\"\n        return self._json_attrs.website\n\n    @website.setter\n    @beartype\n    def website(self, new_website: str) -&gt; None:\n        \"\"\"\n        set the website URL for the scholarly work\n\n        Parameters\n        ----------\n        new_website: str\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, website=new_website)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.arxiv_id","title":"<code>arxiv_id: str</code>  <code>property</code> <code>writable</code>","text":"<p>The arXiv identifier for the scholarly work for this reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.arxiv_id = \"1501\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>arXiv identifier for the scholarly work for this publishing</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.author","title":"<code>author: List[str]</code>  <code>property</code> <code>writable</code>","text":"<p>List of authors for this reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.author += [\"Navid Hariri\"]\n</code></pre> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of authors</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.doi","title":"<code>doi: str</code>  <code>property</code> <code>writable</code>","text":"<p>get the digital object identifier (DOI) for this reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.doi = \"100.1038/1781168a0\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>digital object identifier (DOI) for this reference node</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.issn","title":"<code>issn: str</code>  <code>property</code> <code>writable</code>","text":"<p>The international standard serial number (ISSN) for this reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.issn = \"1456-4687\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>ISSN for this reference node</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.issue","title":"<code>issue: Union[int, None]</code>  <code>property</code> <code>writable</code>","text":"<p>issue of the scholarly work for the reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.issue = 2\n</code></pre> <p>Returns:</p> Type Description <code>None</code>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.journal","title":"<code>journal: str</code>  <code>property</code> <code>writable</code>","text":"<p>journal of publication</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.journal = \"my new journal\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>journal of publication</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.pages","title":"<code>pages: List[int]</code>  <code>property</code> <code>writable</code>","text":"<p>pages of the scholarly work used in the reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.pages = [123, 456]\n</code></pre> <p>Returns:</p> Type Description <code>int</code>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.pmid","title":"<code>pmid: Union[int, None]</code>  <code>property</code> <code>writable</code>","text":"<p>The PubMed ID (PMID) for this reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.pmid = 12345678\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>the PubMedID of this publishing</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.publisher","title":"<code>publisher: str</code>  <code>property</code> <code>writable</code>","text":"<p>publisher for this reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.publisher = \"my new publisher\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>publisher of this publication</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.title","title":"<code>title: str</code>  <code>property</code> <code>writable</code>","text":"<p>title of publication</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.title = \"my new title\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>title of publication</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>Type of reference.</p> <p>The reference type must come from the CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.type = \"web_site\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>reference type</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.volume","title":"<code>volume: Union[int, None]</code>  <code>property</code> <code>writable</code>","text":"<p>Volume of the scholarly work from the reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.volume = 1\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>volume number of the publishing</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.website","title":"<code>website: str</code>  <code>property</code> <code>writable</code>","text":"<p>The website URL for the scholarly work</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.website = \"https://criptapp.org\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>the website URL of this publishing</p>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.year","title":"<code>year: Union[int, None]</code>  <code>property</code> <code>writable</code>","text":"<p>year for the scholarly work</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n&gt;&gt;&gt; my_reference.year = 2023\n</code></pre> <p>Returns:</p> Type Description <code>int</code>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all reference nodes attributes</p> <p>all int types are also None type in case they are not present it should be properly shown as None instead of a placeholder number such as 0 or -1</p> Source code in <code>src/cript/nodes/primary_nodes/reference.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(UUIDBaseNode.JsonAttributes):\n    \"\"\"\n    all reference nodes attributes\n\n    all int types are also None type in case they are not present it should be properly shown as None\n    instead of a placeholder number such as 0 or -1\n    \"\"\"\n\n    type: str = \"\"\n    title: str = \"\"\n    author: List[str] = field(default_factory=list)\n    journal: str = \"\"\n    publisher: str = \"\"\n    year: Optional[int] = None\n    volume: Optional[int] = None\n    issue: Optional[int] = None\n    pages: List[int] = field(default_factory=list)\n    doi: str = \"\"\n    issn: str = \"\"\n    arxiv_id: str = \"\"\n    pmid: Optional[int] = None\n    website: str = \"\"\n</code></pre>"},{"location":"nodes/primary_nodes/reference/#cript.nodes.primary_nodes.Reference.__init__","title":"<code>__init__(type, title, author=None, journal='', publisher='', year=None, volume=None, issue=None, pages=None, doi='', issn='', arxiv_id='', pmid=None, website='', **kwargs)</code>","text":"<p>create a reference node</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>type of literature. The reference type must come from CRIPT controlled vocabulary</p> required <code>title</code> <code>str</code> <p>title of publication</p> required <code>author</code> <code>Optional[List[str]]</code> <p>list of authors</p> <code>None</code> <code>journal</code> <code>str</code> <p>journal of publication</p> <code>''</code> <code>publisher</code> <code>str</code> <p>publisher of publication</p> <code>''</code> <code>year</code> <code>Optional[int]</code> <p>year of publication</p> <code>None</code> <code>volume</code> <code>Optional[int]</code> <p>volume of publication</p> <code>None</code> <code>issue</code> <code>Optional[int]</code> <p>issue of publication</p> <code>None</code> <code>pages</code> <code>Optional[List[int]]</code> <p>page range of publication</p> <code>None</code> <code>doi</code> <code>str</code> <p>DOI: digital object identifier</p> <code>''</code> <code>issn</code> <code>str</code> <p>ISSN: international standard serial number</p> <code>''</code> <code>arxiv_id</code> <code>str</code> <p>arXiv identifier</p> <code>''</code> <code>pmid</code> <code>Optional[int]</code> <p>PMID: PubMed ID</p> <code>None</code> <code>website</code> <code>str</code> <p>website where the publication can be accessed</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>Instantiate a reference node</p> Source code in <code>src/cript/nodes/primary_nodes/reference.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    type: str,\n    title: str,\n    author: Optional[List[str]] = None,\n    journal: str = \"\",\n    publisher: str = \"\",\n    year: Optional[int] = None,\n    volume: Optional[int] = None,\n    issue: Optional[int] = None,\n    pages: Optional[List[int]] = None,\n    doi: str = \"\",\n    issn: str = \"\",\n    arxiv_id: str = \"\",\n    pmid: Optional[int] = None,\n    website: str = \"\",\n    **kwargs,\n):\n    \"\"\"\n    create a reference node\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_reference = cript.Reference(type=\"journal_article\", title=\"'Living' Polymers\")\n\n    Parameters\n    ----------\n    type: str\n        type of literature.\n        The [reference type](https://app.criptapp.org/vocab/reference_type/)\n        must come from CRIPT controlled vocabulary\n    title: str\n        title of publication\n    author: List[str] default=\"\"\n        list of authors\n    journal: str default=\"\"\n        journal of publication\n    publisher: str default=\"\"\n        publisher of publication\n    year: int default=None\n        year of publication\n    volume: int default=None\n        volume of publication\n    issue: int default=None\n        issue of publication\n    pages: List[int] default=None\n        page range of publication\n    doi: str default=\"\"\n        DOI: digital object identifier\n    issn: str default=\"\"\n        ISSN: international standard serial number\n    arxiv_id: str default=\"\"\n        arXiv identifier\n    pmid: int default=None\n        PMID: PubMed ID\n    website: str default=\"\"\n        website where the publication can be accessed\n\n    Returns\n    -------\n    None\n        Instantiate a reference node\n    \"\"\"\n    if author is None:\n        author = []\n\n    if pages is None:\n        pages = []\n\n    super().__init__(**kwargs)\n\n    new_attrs = replace(self._json_attrs, type=type, title=title, author=author, journal=journal, publisher=publisher, year=year, volume=volume, issue=issue, pages=pages, doi=doi, issn=issn, arxiv_id=arxiv_id, pmid=pmid, website=website)\n\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/software/","title":"Software","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/primary_nodes/software/#cript.Software--definition","title":"Definition","text":"<p>The Software node contains metadata for a computation tool, code, programming language, or software package.</p> <p>Similar to the reference node, the software node does not contain the base attributes and is meant to always be public and static.</p>"},{"location":"nodes/primary_nodes/software/#cript.Software--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>Software_Configuration</li> </ul>"},{"location":"nodes/primary_nodes/software/#cript.Software--available-sub-objects","title":"Available sub-objects","text":"<ul> <li>None</li> </ul>"},{"location":"nodes/primary_nodes/software/#cript.Software--attributes","title":"Attributes","text":"attribute type example description required vocab name str LAMMPS type of literature True version str 23Jun22 software version True source str lammps.org source of software"},{"location":"nodes/primary_nodes/software/#cript.Software--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"name\":\"SOMA\",\n   \"node\":[\"Software\"],\n   \"version\":\"0.7.0\"\n   \"source\":\"https://gitlab.com/InnocentBug/SOMA\",\n   \"uid\":\"_:f2ec4bf2-96aa-48a3-bfbc-d1d3f090583b\",\n   \"uuid\":\"f2ec4bf2-96aa-48a3-bfbc-d1d3f090583b\",\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/software.py</code> <pre><code>class Software(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n\n    The [Software](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=16)\n    node contains metadata for a computation tool, code, programming language, or software package.\n\n    Similar to the [reference](../../primary_nodes/reference) node, the software node does not contain the base\n    attributes and is meant to always be public and static.\n\n    ---\n\n    ## Can Be Added To:\n    * [Software_Configuration](../../subobjects/software_configuration)\n\n    ## Available sub-objects\n    * None\n\n    ---\n\n    ## Attributes\n\n    | attribute | type | example    | description                   | required | vocab |\n    |-----------|------|------------|-------------------------------|----------|-------|\n    | name      | str  | LAMMPS     | type of literature            | True     |       |\n    | version   | str  | 23Jun22    | software version              | True     |       |\n    | source    | str  | lammps.org | source of software            |          |       |\n\n    ## JSON Representation\n    ```json\n    {\n       \"name\":\"SOMA\",\n       \"node\":[\"Software\"],\n       \"version\":\"0.7.0\"\n       \"source\":\"https://gitlab.com/InnocentBug/SOMA\",\n       \"uid\":\"_:f2ec4bf2-96aa-48a3-bfbc-d1d3f090583b\",\n       \"uuid\":\"f2ec4bf2-96aa-48a3-bfbc-d1d3f090583b\",\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        name: str = \"\"\n        version: str = \"\"\n        source: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, name: str, version: str, source: str = \"\", **kwargs):\n        \"\"\"\n        create Software node\n\n        Parameters\n        ----------\n        name : str\n            Software name\n        version : str\n            Software version\n        source : str, optional\n            Software source, by default \"\"\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(\n        ...     name=\"my software name\", version=\"v1.0.0\", source=\"https://myurl.com\"\n        ... )\n\n        Returns\n        -------\n        None\n            create Software node\n        \"\"\"\n        super().__init__(**kwargs)\n\n        new_json_attrs = replace(self._json_attrs, name=name, version=version, source=source)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def name(self) -&gt; str:\n        \"\"\"\n        Software name\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(\n        ...     name=\"my software name\", version=\"v1.0.0\", source=\"https://myurl.com\"\n        ... )\n        &gt;&gt;&gt; my_software.name = \"my software name\"\n\n        Returns\n        -------\n        str\n            Software name\n        \"\"\"\n        return self._json_attrs.name\n\n    @name.setter\n    @beartype\n    def name(self, new_name: str) -&gt; None:\n        \"\"\"\n        set the name of the Software node\n\n        Parameters\n        ----------\n        new_name : str\n            new Software name\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attr = replace(self._json_attrs, name=new_name)\n        self._update_json_attrs_if_valid(new_attr)\n\n    @property\n    @beartype\n    def version(self) -&gt; str:\n        \"\"\"\n        Software version\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(\n        ...     name=\"my software name\", version=\"v1.0.0\", source=\"https://myurl.com\"\n        ... )\n        &gt;&gt;&gt; my_software.version = \"1.2.3\"\n\n        Returns\n        -------\n        str\n            Software version\n        \"\"\"\n        return self._json_attrs.version\n\n    @version.setter\n    @beartype\n    def version(self, new_version: str) -&gt; None:\n        \"\"\"\n        set the Software version\n\n        Parameters\n        ----------\n        new_version : str\n            new Software version\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attr = replace(self._json_attrs, version=new_version)\n        self._update_json_attrs_if_valid(new_attr)\n\n    @property\n    @beartype\n    def source(self) -&gt; str:\n        \"\"\"\n        Software source\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(\n        ...     name=\"my software name\", version=\"v1.0.0\", source=\"https://myurl.com\"\n        ... )\n        &gt;&gt;&gt; my_software.source = \"https://myNewWebsite.com\"\n\n        Returns\n        -------\n        str\n            Software source\n        \"\"\"\n        return self._json_attrs.source\n\n    @source.setter\n    @beartype\n    def source(self, new_source: str) -&gt; None:\n        \"\"\"\n        set the Software source\n\n        Parameters\n        ----------\n        new_source : str\n            new Software source\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attr = replace(self._json_attrs, source=new_source)\n        self._update_json_attrs_if_valid(new_attr)\n</code></pre>"},{"location":"nodes/primary_nodes/software/#cript.Software.__init__","title":"<code>__init__(name, version, source='', **kwargs)</code>","text":"<p>create Software node</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Software name</p> required <code>version</code> <code>str</code> <p>Software version</p> required <code>source</code> <code>str</code> <p>Software source, by default \"\"</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_software = cript.Software(\n...     name=\"my software name\", version=\"v1.0.0\", source=\"https://myurl.com\"\n... )\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>create Software node</p> Source code in <code>src/cript/nodes/subobjects/software.py</code> <pre><code>@beartype\ndef __init__(self, name: str, version: str, source: str = \"\", **kwargs):\n    \"\"\"\n    create Software node\n\n    Parameters\n    ----------\n    name : str\n        Software name\n    version : str\n        Software version\n    source : str, optional\n        Software source, by default \"\"\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_software = cript.Software(\n    ...     name=\"my software name\", version=\"v1.0.0\", source=\"https://myurl.com\"\n    ... )\n\n    Returns\n    -------\n    None\n        create Software node\n    \"\"\"\n    super().__init__(**kwargs)\n\n    new_json_attrs = replace(self._json_attrs, name=name, version=version, source=source)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/primary_nodes/software/#cript.Software.name","title":"<code>name(new_name)</code>","text":"<p>set the name of the Software node</p> <p>Parameters:</p> Name Type Description Default <code>new_name</code> <code>str</code> <p>new Software name</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/software.py</code> <pre><code>@name.setter\n@beartype\ndef name(self, new_name: str) -&gt; None:\n    \"\"\"\n    set the name of the Software node\n\n    Parameters\n    ----------\n    new_name : str\n        new Software name\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attr = replace(self._json_attrs, name=new_name)\n    self._update_json_attrs_if_valid(new_attr)\n</code></pre>"},{"location":"nodes/primary_nodes/software/#cript.Software.source","title":"<code>source(new_source)</code>","text":"<p>set the Software source</p> <p>Parameters:</p> Name Type Description Default <code>new_source</code> <code>str</code> <p>new Software source</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/software.py</code> <pre><code>@source.setter\n@beartype\ndef source(self, new_source: str) -&gt; None:\n    \"\"\"\n    set the Software source\n\n    Parameters\n    ----------\n    new_source : str\n        new Software source\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attr = replace(self._json_attrs, source=new_source)\n    self._update_json_attrs_if_valid(new_attr)\n</code></pre>"},{"location":"nodes/primary_nodes/software/#cript.Software.version","title":"<code>version(new_version)</code>","text":"<p>set the Software version</p> <p>Parameters:</p> Name Type Description Default <code>new_version</code> <code>str</code> <p>new Software version</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/software.py</code> <pre><code>@version.setter\n@beartype\ndef version(self, new_version: str) -&gt; None:\n    \"\"\"\n    set the Software version\n\n    Parameters\n    ----------\n    new_version : str\n        new Software version\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attr = replace(self._json_attrs, version=new_version)\n    self._update_json_attrs_if_valid(new_attr)\n</code></pre>"},{"location":"nodes/subobjects/algorithm/","title":"Algorithm","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm--definition","title":"Definition","text":"<p>An algorithm sub-object is a set of instructions that define a computational process. An algorithm consists of parameters that are used in the computation and the computational process itself.</p>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm--attributes","title":"Attributes","text":"Keys Type Example Description Required Vocab key str ensemble, thermo-barostat system configuration, algorithms used in a computation True True type str NPT for ensemble, Nose-Hoover for thermostat specific type of configuration, algorithm True parameter list[Parameter] setup associated parameters citation Citation reference to a book, paper, or scholarly work"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm--can-be-added-to","title":"Can be Added To","text":"<ul> <li>SoftwareConfiguration</li> </ul>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm--available-sub-objects","title":"Available sub-objects","text":"<ul> <li>Parameter</li> <li>Citation</li> </ul>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm--json-representation","title":"JSON Representation","text":"<pre><code>{\n    \"node\": [\"Algorithm\"],\n    \"key\": \"mc_barostat\",\n    \"type\": \"barostat\",\n    \"parameter\": {\n        \"node\": [\"Parameter\"],\n        \"key\": \"update_frequency\",\n        \"value\": 1000.0,\n        \"unit\": \"1/second\"\n    },\n    \"citation\": {\n        \"node\": [\"Citation\"],\n        \"type\": \"reference\"\n        \"reference\": {\n                \"node\": [\"Reference\"],\n                \"type\": \"journal_article\",\n                \"title\": \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n                \"author\": [\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n                \"journal\": \"Computer Physics Communications\",\n                \"publisher\": \"Elsevier\",\n                \"year\": 2019,\n                \"pages\": [463, 476],\n                \"doi\": \"10.1016/j.cpc.2018.08.011\",\n                \"issn\": \"0010-4655\",\n                \"website\": \"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        },\n    },\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/algorithm.py</code> <pre><code>class Algorithm(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n\n    An [algorithm sub-object](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=25)\n    is a set of instructions that define a computational process.\n    An algorithm consists of parameters that are used in the computation and the computational process itself.\n\n\n    ## Attributes\n\n    | Keys      | Type            | Example                                      | Description                                            | Required | Vocab |\n    |-----------|-----------------|----------------------------------------------|--------------------------------------------------------|----------|-------|\n    | key       | str             | ensemble, thermo-barostat                    | system configuration, algorithms used in a computation | True     | True  |\n    | type      | str             | NPT for ensemble, Nose-Hoover for thermostat | specific type of configuration, algorithm              | True     |       |\n    | parameter | list[Parameter] |                                              | setup associated parameters                            |          |       |\n    | citation  | Citation        |                                              | reference to a book, paper, or scholarly work          |          |       |\n\n    ## Can be Added To\n    * [SoftwareConfiguration](../software_configuration)\n\n    ## Available sub-objects\n    * [Parameter](../parameter)\n    * [Citation](../citation)\n\n    ## JSON Representation\n    ```json\n    {\n        \"node\": [\"Algorithm\"],\n        \"key\": \"mc_barostat\",\n        \"type\": \"barostat\",\n        \"parameter\": {\n            \"node\": [\"Parameter\"],\n            \"key\": \"update_frequency\",\n            \"value\": 1000.0,\n            \"unit\": \"1/second\"\n        },\n        \"citation\": {\n            \"node\": [\"Citation\"],\n            \"type\": \"reference\"\n            \"reference\": {\n                    \"node\": [\"Reference\"],\n                    \"type\": \"journal_article\",\n                    \"title\": \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n                    \"author\": [\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n                    \"journal\": \"Computer Physics Communications\",\n                    \"publisher\": \"Elsevier\",\n                    \"year\": 2019,\n                    \"pages\": [463, 476],\n                    \"doi\": \"10.1016/j.cpc.2018.08.011\",\n                    \"issn\": \"0010-4655\",\n                    \"website\": \"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n            },\n        },\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        type: str = \"\"\n\n        parameter: List[Union[Parameter, UIDProxy]] = field(default_factory=list)\n        citation: List[Union[Citation, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    def __init__(self, key: str, type: str, parameter: Optional[List[Union[Parameter, UIDProxy]]] = None, citation: Optional[List[Union[Citation, UIDProxy]]] = None, **kwargs):  # ignored\n        \"\"\"\n        Create algorithm sub-object\n\n        Parameters\n        ----------\n        key : str\n            algorithm key must come from\n            [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/algorithm_key)\n        type : str\n            algorithm type must come from\n            [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/algorithm_type)\n        parameter : List[Parameter], optional\n            parameter sub-object, by default None\n        citation : List[Citation], optional\n            citation sub-object, by default None\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n\n        Returns\n        -------\n        None\n            instantiate an algorithm node\n        \"\"\"\n        if parameter is None:\n            parameter = []\n        if citation is None:\n            citation = []\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, key=key, type=type, parameter=parameter)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"\n        Algorithm key\n\n        Algorithm key must come from [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/algorithm_key)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n        &gt;&gt;&gt; my_algorithm.key = \"amorphous_cell_module\"\n\n        Returns\n        -------\n        str\n            algorithm key\n        \"\"\"\n        return self._json_attrs.key\n\n    @key.setter\n    def key(self, new_key: str) -&gt; None:\n        \"\"\"\n        set the algorithm key\n\n        &gt; Algorithm key must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/algorithm_key)\n\n        Parameters\n        ----------\n        new_key : str\n            algorithm key\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    def type(self) -&gt; str:\n        \"\"\"\n        Algorithm type\n\n        &gt; Algorithm type must come from\n        [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/algorithm_type)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n        &gt;&gt;&gt; my_algorithm.type = \"integration\"\n\n        Returns\n        -------\n        str\n            algorithm type\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    def type(self, new_type: str) -&gt; None:\n        new_attrs = replace(self._json_attrs, type=new_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    def parameter(self) -&gt; List[Union[Parameter, UIDProxy]]:\n        \"\"\"\n        list of [Parameter](../parameter) sub-objects for the algorithm sub-object\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n        &gt;&gt;&gt; my_parameters = [\n        ...     cript.Parameter(\"update_frequency\", 1000.0, \"1/second\"),\n        ...     cript.Parameter(\"damping_time\", 1.0, \"second\"),\n        ... ]\n        &gt;&gt;&gt; my_algorithm.parameter = my_parameters\n\n        Returns\n        -------\n        List[Parameter]\n            list of parameters for the algorithm sub-object\n        \"\"\"\n        return self._json_attrs.parameter.copy()\n\n    @parameter.setter\n    def parameter(self, new_parameter: List[Union[Parameter, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set a list of cript.Parameter sub-objects\n\n        Parameters\n        ----------\n        new_parameter : List[Parameter]\n            list of Parameter sub-objects for the algorithm sub-object\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, parameter=new_parameter)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    def citation(self) -&gt; List[Union[Citation, UIDProxy]]:\n        \"\"\"\n        [citation](../citation) subobject for algorithm subobject\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n        &gt;&gt;&gt; my_algorithm.citation = [my_citation]\n\n\n        Returns\n        -------\n        citation node: Citation\n            get the algorithm citation node\n        \"\"\"\n        return self._json_attrs.citation.copy()  # type: ignore\n\n    @citation.setter\n    def citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the algorithm citation subobject\n\n        Parameters\n        ----------\n        new_citation : Citation\n            new citation subobject to replace the current\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm.__init__","title":"<code>__init__(key, type, parameter=None, citation=None, **kwargs)</code>","text":"<p>Create algorithm sub-object</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>algorithm key must come from CRIPT controlled vocabulary</p> required <code>type</code> <code>str</code> <p>algorithm type must come from CRIPT controlled vocabulary</p> required <code>parameter</code> <code>List[Parameter]</code> <p>parameter sub-object, by default None</p> <code>None</code> <code>citation</code> <code>List[Citation]</code> <p>citation sub-object, by default None</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>instantiate an algorithm node</p> Source code in <code>src/cript/nodes/subobjects/algorithm.py</code> <pre><code>def __init__(self, key: str, type: str, parameter: Optional[List[Union[Parameter, UIDProxy]]] = None, citation: Optional[List[Union[Citation, UIDProxy]]] = None, **kwargs):  # ignored\n    \"\"\"\n    Create algorithm sub-object\n\n    Parameters\n    ----------\n    key : str\n        algorithm key must come from\n        [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/algorithm_key)\n    type : str\n        algorithm type must come from\n        [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/algorithm_type)\n    parameter : List[Parameter], optional\n        parameter sub-object, by default None\n    citation : List[Citation], optional\n        citation sub-object, by default None\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n\n    Returns\n    -------\n    None\n        instantiate an algorithm node\n    \"\"\"\n    if parameter is None:\n        parameter = []\n    if citation is None:\n        citation = []\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, key=key, type=type, parameter=parameter)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm.citation","title":"<code>citation(new_citation)</code>","text":"<p>set the algorithm citation subobject</p> <p>Parameters:</p> Name Type Description Default <code>new_citation</code> <code>Citation</code> <p>new citation subobject to replace the current</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/algorithm.py</code> <pre><code>@citation.setter\ndef citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n    \"\"\"\n    set the algorithm citation subobject\n\n    Parameters\n    ----------\n    new_citation : Citation\n        new citation subobject to replace the current\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, citation=new_citation)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm.key","title":"<code>key(new_key)</code>","text":"<p>set the algorithm key</p> <p>Algorithm key must come from CRIPT Controlled Vocabulary</p> <p>Parameters:</p> Name Type Description Default <code>new_key</code> <code>str</code> <p>algorithm key</p> required Source code in <code>src/cript/nodes/subobjects/algorithm.py</code> <pre><code>@key.setter\ndef key(self, new_key: str) -&gt; None:\n    \"\"\"\n    set the algorithm key\n\n    &gt; Algorithm key must come from\n    [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/algorithm_key)\n\n    Parameters\n    ----------\n    new_key : str\n        algorithm key\n    \"\"\"\n    new_attrs = replace(self._json_attrs, key=new_key)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/algorithm/#cript.nodes.subobjects.Algorithm.parameter","title":"<code>parameter(new_parameter)</code>","text":"<p>set a list of cript.Parameter sub-objects</p> <p>Parameters:</p> Name Type Description Default <code>new_parameter</code> <code>List[Parameter]</code> <p>list of Parameter sub-objects for the algorithm sub-object</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/algorithm.py</code> <pre><code>@parameter.setter\ndef parameter(self, new_parameter: List[Union[Parameter, UIDProxy]]) -&gt; None:\n    \"\"\"\n    set a list of cript.Parameter sub-objects\n\n    Parameters\n    ----------\n    new_parameter : List[Parameter]\n        list of Parameter sub-objects for the algorithm sub-object\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, parameter=new_parameter)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/citation/","title":"Citation","text":""},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation","title":"<code>Citation</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation--definition","title":"Definition","text":"<p>The Citation sub-object essentially houses Reference nodes. The citation subobject can then be added to CRIPT Primary nodes.</p>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation--attributes","title":"Attributes","text":"attribute type example description required vocab type str derived_from key for identifier True True reference Reference reference to a book, paper, or scholarly work True"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation--can-be-added-to","title":"Can Be Added To","text":"<ul> <li>Collection node</li> <li>Computation node</li> <li>Computation Process Node</li> <li> <p>Data node</p> </li> <li> <p>Computational Forcefield subobjects</p> </li> <li>Property subobject</li> <li>Algorithm subobject</li> <li>Equipment subobject</li> </ul>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation--available-subobjects","title":"Available Subobjects","text":"<ul> <li><code>None</code></li> </ul>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation--json-representation","title":"JSON Representation","text":"<pre><code>\"citation\": {\n        \"node\": [\"Citation\"],\n        \"type\": \"reference\",\n        \"reference\": {\n                \"node\": [\"Reference\"],\n                \"type\": \"journal_article\",\n                \"title\": \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n                \"author\": [\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n                \"journal\": \"Computer Physics Communications\",\n                \"publisher\": \"Elsevier\",\n                \"year\": 2019,\n                \"pages\": [463, 476],\n                \"doi\": \"10.1016/j.cpc.2018.08.011\",\n                \"issn\": \"0010-4655\",\n                \"website\": \"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        },\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/citation.py</code> <pre><code>class Citation(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n    The [Citation sub-object](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=26)\n    essentially houses [Reference nodes](../../primary_nodes/reference). The citation subobject can then be added to CRIPT Primary nodes.\n\n    ## Attributes\n    | attribute | type      | example      | description                                   | required | vocab |\n    |-----------|-----------|--------------|-----------------------------------------------|----------|-------|\n    | type      | str       | derived_from | key for identifier                            | True     | True  |\n    | reference | Reference |              | reference to a book, paper, or scholarly work | True     |       |\n\n    ## Can Be Added To\n    * [Collection node](../../primary_nodes/collection)\n    * [Computation node](../../primary_nodes/computation)\n    * [Computation Process Node](../../primary_nodes/computation_process)\n    * [Data node](../../primary_nodes/data)\n\n    * [Computational Forcefield subobjects](../computational_forcefield)\n    * [Property subobject](../property)\n    * [Algorithm subobject](../algorithm)\n    * [Equipment subobject](../equipment)\n\n    ---\n\n    ## Available Subobjects\n    * `None`\n\n    ## JSON Representation\n    ```json\n    \"citation\": {\n            \"node\": [\"Citation\"],\n            \"type\": \"reference\",\n            \"reference\": {\n                    \"node\": [\"Reference\"],\n                    \"type\": \"journal_article\",\n                    \"title\": \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n                    \"author\": [\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n                    \"journal\": \"Computer Physics Communications\",\n                    \"publisher\": \"Elsevier\",\n                    \"year\": 2019,\n                    \"pages\": [463, 476],\n                    \"doi\": \"10.1016/j.cpc.2018.08.011\",\n                    \"issn\": \"0010-4655\",\n                    \"website\": \"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n            },\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        type: str = \"\"\n        reference: Optional[Union[Reference, UIDProxy]] = None\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, type: str, reference: Union[Reference, UIDProxy], **kwargs):\n        \"\"\"\n        create a Citation subobject\n\n        Parameters\n        ----------\n        type : citation type\n            citation type must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/citation_type)\n        reference : Reference\n            Reference node\n\n        Examples\n        -------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     \"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n\n\n        Returns\n        -------\n        None\n            Instantiate citation subobject\n        \"\"\"\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, type=type, reference=reference)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        Citation type subobject\n\n        Citation type must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/citation_type)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     \"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n        &gt;&gt;&gt; my_citation.type = \"extracted_by_algorithm\"\n\n        Returns\n        -------\n        str\n            Citation type\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_type: str) -&gt; None:\n        \"\"\"\n        set the citation sub-object type\n\n        Parameters\n        ----------\n        new_type : str\n            citation type\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def reference(self) -&gt; Union[Reference, None, UIDProxy]:\n        \"\"\"\n        citation reference node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     \"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n        &gt;&gt;&gt; my_new_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=\"'Living' Polymers\",\n        ...     author=[\"Dylan J. Walsh\", \"Bradley D. Olsen\"],\n        ...     journal=\"Nature\",\n        ...     publisher=\"Springer\",\n        ...     year=2019,\n        ...     volume=3,\n        ...     issue=5,\n        ...     pages=[123, 456, 789],\n        ...     doi=\"10.1038/1781168a0\",\n        ...     issn=\"1476-4687\",\n        ...     arxiv_id=\"1501\",\n        ...     pmid=12345678,\n        ...     website=\"https://criptapp.org\",\n        ... )\n        &gt;&gt;&gt; my_citation.reference = my_new_reference\n\n        Returns\n        -------\n        Reference\n            Reference node\n        \"\"\"\n        return self._json_attrs.reference\n\n    @reference.setter\n    @beartype\n    def reference(self, new_reference: Reference) -&gt; None:\n        \"\"\"\n        replace the current Reference node for the citation subobject\n\n        Parameters\n        ----------\n        new_reference : Reference\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, reference=new_reference)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation.__init__","title":"<code>__init__(type, reference, **kwargs)</code>","text":"<p>create a Citation subobject</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>citation type</code> <p>citation type must come from CRIPT Controlled Vocabulary</p> required <code>reference</code> <code>Reference</code> <p>Reference node</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; title = (\n...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n... )\n&gt;&gt;&gt; my_reference = cript.Reference(\n...     \"journal_article\",\n...     title=title,\n...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n...     journal=\"Computer Physics Communications\",\n...     publisher=\"Elsevier\",\n...     year=2019,\n...     pages=[463, 476],\n...     doi=\"10.1016/j.cpc.2018.08.011\",\n...     issn=\"0010-4655\",\n...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n... )\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>Instantiate citation subobject</p> Source code in <code>src/cript/nodes/subobjects/citation.py</code> <pre><code>@beartype\ndef __init__(self, type: str, reference: Union[Reference, UIDProxy], **kwargs):\n    \"\"\"\n    create a Citation subobject\n\n    Parameters\n    ----------\n    type : citation type\n        citation type must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/citation_type)\n    reference : Reference\n        Reference node\n\n    Examples\n    -------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; title = (\n    ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n    ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n    ... )\n    &gt;&gt;&gt; my_reference = cript.Reference(\n    ...     \"journal_article\",\n    ...     title=title,\n    ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n    ...     journal=\"Computer Physics Communications\",\n    ...     publisher=\"Elsevier\",\n    ...     year=2019,\n    ...     pages=[463, 476],\n    ...     doi=\"10.1016/j.cpc.2018.08.011\",\n    ...     issn=\"0010-4655\",\n    ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n    ... )\n    &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n\n\n    Returns\n    -------\n    None\n        Instantiate citation subobject\n    \"\"\"\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, type=type, reference=reference)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation.reference","title":"<code>reference(new_reference)</code>","text":"<p>replace the current Reference node for the citation subobject</p> <p>Parameters:</p> Name Type Description Default <code>new_reference</code> <code>Reference</code> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/citation.py</code> <pre><code>@reference.setter\n@beartype\ndef reference(self, new_reference: Reference) -&gt; None:\n    \"\"\"\n    replace the current Reference node for the citation subobject\n\n    Parameters\n    ----------\n    new_reference : Reference\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, reference=new_reference)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/citation/#cript.nodes.subobjects.citation.Citation.type","title":"<code>type(new_type)</code>","text":"<p>set the citation sub-object type</p> <p>Parameters:</p> Name Type Description Default <code>new_type</code> <code>str</code> <p>citation type</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/citation.py</code> <pre><code>@type.setter\n@beartype\ndef type(self, new_type: str) -&gt; None:\n    \"\"\"\n    set the citation sub-object type\n\n    Parameters\n    ----------\n    new_type : str\n        citation type\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, type=new_type)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/","title":"Computational Forcefield","text":""},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield","title":"<code>ComputationalForcefield</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield--definition","title":"Definition","text":"<p>A Computational Forcefield Subobject is a mathematical model that describes the forces between atoms and molecules. It is used in computational chemistry and molecular dynamics simulations to predict the behavior of materials. Forcefields are typically based on experimental data or quantum mechanical calculations, and they are often used to study the properties of materials such as their structure, dynamics, and reactivity.</p>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield--attributes","title":"Attributes","text":"attribute type example description required vocab key str CHARMM27 type of forcefield True True building_block str atom type of building block True True coarse_grained_mapping str SC3 beads in MARTINI forcefield atom to beads mapping implicit_solvent str water Name of implicit solvent source str package in GROMACS source of forcefield description str OPLS forcefield with partial charges calculated via the LBCC algorithm description of the forcefield and any modifications that have been added data Data details of mapping schema and forcefield parameters citation list[Citation] reference to a book, paper, or scholarly work"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield--can-be-added-to-primary-node","title":"Can be Added To Primary Node:","text":"<ul> <li>Material node</li> </ul>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield--json-representation","title":"JSON Representation","text":"<pre><code>{\n    \"node\": [\"ComputationalForcefield\"],\n    \"key\": \"opls_aa\",\n    \"building_block\": \"atom\",\n    \"coarse_grained_mapping\": \"atom -&gt; atom\",\n    \"implicit_solvent\": \"no implicit solvent\",\n    \"source\": \"local LigParGen installation\",\n    \"description\": \"this is a test forcefield\",\n    \"data\": {\n        \"node\":[\"Data\"],\n        \"name\":\"my data name\",\n        \"type\":\"afm_amp\",\n        \"file\":[\n            {\n                \"node\":[\"File\"],\n                \"type\":\"calibration\",\n                \"source\":\"https://criptapp.org\",\n                \"extension\":\".csv\",\n                \"data_dictionary\":\"my file's data dictionary\"\n            }\n        ]\n    },\n    \"citation\": {\n        \"node\": [\"Citation\"],\n        \"type\": \"reference\"\n        \"reference\": {\n            \"node\": [\"Reference\"],\n            \"type\": \"journal_article\",\n            \"title\": \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n            \"author\": [\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n            \"journal\": \"Computer Physics Communications\",\n            \"publisher\": \"Elsevier\",\n            \"year\": 2019,\n            \"pages\": [463, 476],\n            \"doi\": \"10.1016/j.cpc.2018.08.011\",\n            \"issn\": \"0010-4655\",\n            \"website\": \"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        }\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>class ComputationalForcefield(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n    A [Computational Forcefield Subobject](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=23)\n    is a mathematical model that describes the forces between atoms and molecules.\n    It is used in computational chemistry and molecular dynamics simulations to predict the behavior of materials.\n    Forcefields are typically based on experimental data or quantum mechanical calculations,\n    and they are often used to study the properties of materials such as their structure, dynamics, and reactivity.\n\n    ## Attributes\n    | attribute              | type           | example                                                                | description                                                              | required | vocab |\n    |------------------------|----------------|------------------------------------------------------------------------|--------------------------------------------------------------------------|----------|-------|\n    | key                    | str            | CHARMM27                                                               | type of forcefield                                                       | True     | True  |\n    | building_block         | str            | atom                                                                   | type of building block                                                   | True     | True  |\n    | coarse_grained_mapping | str            | SC3 beads in MARTINI forcefield                                        | atom to beads mapping                                                    |          |       |\n    | implicit_solvent       | str            | water                                                                  | Name of implicit solvent                                                 |          |       |\n    | source                 | str            | package in GROMACS                                                     | source of forcefield                                                     |          |       |\n    | description            | str            | OPLS forcefield with partial charges calculated via the LBCC algorithm | description of the forcefield and any modifications that have been added |          |       |\n    | data                   | Data           |                                                                        | details of mapping schema and forcefield parameters                      |          |       |\n    | citation               | list[Citation] |                                                                        | reference to a book, paper, or scholarly work                            |          |       |\n\n\n    ## Can be Added To Primary Node:\n    * Material node\n\n    ## JSON Representation\n    ```json\n    {\n        \"node\": [\"ComputationalForcefield\"],\n        \"key\": \"opls_aa\",\n        \"building_block\": \"atom\",\n        \"coarse_grained_mapping\": \"atom -&gt; atom\",\n        \"implicit_solvent\": \"no implicit solvent\",\n        \"source\": \"local LigParGen installation\",\n        \"description\": \"this is a test forcefield\",\n        \"data\": {\n            \"node\":[\"Data\"],\n            \"name\":\"my data name\",\n            \"type\":\"afm_amp\",\n            \"file\":[\n                {\n                    \"node\":[\"File\"],\n                    \"type\":\"calibration\",\n                    \"source\":\"https://criptapp.org\",\n                    \"extension\":\".csv\",\n                    \"data_dictionary\":\"my file's data dictionary\"\n                }\n            ]\n        },\n        \"citation\": {\n            \"node\": [\"Citation\"],\n            \"type\": \"reference\"\n            \"reference\": {\n                \"node\": [\"Reference\"],\n                \"type\": \"journal_article\",\n                \"title\": \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: SOft coarse grained Monte-Carlo Acceleration (SOMA)\",\n                \"author\": [\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n                \"journal\": \"Computer Physics Communications\",\n                \"publisher\": \"Elsevier\",\n                \"year\": 2019,\n                \"pages\": [463, 476],\n                \"doi\": \"10.1016/j.cpc.2018.08.011\",\n                \"issn\": \"0010-4655\",\n                \"website\": \"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n            }\n    }\n\n\n    ```\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        building_block: str = \"\"\n        coarse_grained_mapping: str = \"\"\n        implicit_solvent: str = \"\"\n        source: str = \"\"\n        description: str = \"\"\n        data: List[Union[Data, UIDProxy]] = field(default_factory=list)\n        citation: List[Union[Citation, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        key: str,\n        building_block: str,\n        coarse_grained_mapping: str = \"\",\n        implicit_solvent: str = \"\",\n        source: str = \"\",\n        description: str = \"\",\n        data: Optional[List[Union[Data, UIDProxy]]] = None,\n        citation: Optional[List[Union[Citation, UIDProxy]]] = None,\n        **kwargs\n    ):\n        \"\"\"\n        instantiate a computational_forcefield subobject\n\n        Parameters\n        ----------\n        key : str\n            type of forcefield key must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/computational_forcefield_key)\n        building_block : str\n            type of computational_forcefield building_block must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/building_block)\n        coarse_grained_mapping : str, optional\n            atom to beads mapping, by default \"\"\n        implicit_solvent : str, optional\n            Name of implicit solvent, by default \"\"\n        source : str, optional\n            source of forcefield, by default \"\"\n        description : str, optional\n            description of the forcefield and any modifications that have been added, by default \"\"\n        data : List[Data], optional\n            details of mapping schema and forcefield parameters, by default None\n        citation : Union[List[Citation], None], optional\n            reference to a book, paper, or scholarly work, by default None\n\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n\n        Returns\n        -------\n        None\n            Instantiate a computational_forcefield subobject\n        \"\"\"\n        if citation is None:\n            citation = []\n        super().__init__(**kwargs)\n\n        if data is None:\n            data = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            key=key,\n            building_block=building_block,\n            coarse_grained_mapping=coarse_grained_mapping,\n            implicit_solvent=implicit_solvent,\n            source=source,\n            description=description,\n            data=data,\n            citation=citation,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def key(self) -&gt; str:\n        \"\"\"\n        type of forcefield\n\n        Computational_Forcefield key must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/computational_forcefield_key)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.key = \"amber\"\n\n        Returns\n        -------\n        str\n            type of forcefield\n        \"\"\"\n        return self._json_attrs.key\n\n    @key.setter\n    @beartype\n    def key(self, new_key: str) -&gt; None:\n        \"\"\"\n        set key for this computational_forcefield\n\n        Parameters\n        ----------\n        new_key : str\n            computational_forcefield key\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def building_block(self) -&gt; str:\n        \"\"\"\n        type of building block\n\n        Computational_Forcefield building_block must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/building_block)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.building_block = \"non_atomistic\"\n\n        Returns\n        -------\n        str\n            type of building block\n        \"\"\"\n        return self._json_attrs.building_block\n\n    @building_block.setter\n    @beartype\n    def building_block(self, new_building_block: str) -&gt; None:\n        \"\"\"\n        type of building block\n\n        Parameters\n        ----------\n        new_building_block : str\n            new type of building block\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, building_block=new_building_block)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def coarse_grained_mapping(self) -&gt; str:\n        \"\"\"\n        atom to beads mapping\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.coarse_grained_mapping = \"SC3 beads in MARTINI forcefield\"\n\n        Returns\n        -------\n        str\n            coarse_grained_mapping\n        \"\"\"\n        return self._json_attrs.coarse_grained_mapping\n\n    @coarse_grained_mapping.setter\n    @beartype\n    def coarse_grained_mapping(self, new_coarse_grained_mapping: str) -&gt; None:\n        \"\"\"\n        atom to beads mapping\n\n        Parameters\n        ----------\n        new_coarse_grained_mapping : str\n            new coarse_grained_mapping\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, coarse_grained_mapping=new_coarse_grained_mapping)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def implicit_solvent(self) -&gt; str:\n        \"\"\"\n        Name of implicit solvent\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.implicit_solvent = \"water\"\n\n        Returns\n        -------\n        str\n            _description_\n        \"\"\"\n        return self._json_attrs.implicit_solvent\n\n    @implicit_solvent.setter\n    @beartype\n    def implicit_solvent(self, new_implicit_solvent: str) -&gt; None:\n        \"\"\"\n        set the implicit_solvent\n\n        Parameters\n        ----------\n        new_implicit_solvent : str\n            new implicit_solvent\n        \"\"\"\n        new_attrs = replace(self._json_attrs, implicit_solvent=new_implicit_solvent)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def source(self) -&gt; str:\n        \"\"\"\n        source of forcefield\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.source = \"package in GROMACS\"\n\n        Returns\n        -------\n        str\n            source of forcefield\n        \"\"\"\n        return self._json_attrs.source\n\n    @source.setter\n    @beartype\n    def source(self, new_source: str) -&gt; None:\n        \"\"\"\n        set the computational_forcefield\n\n        Parameters\n        ----------\n        new_source : str\n            new source of forcefield\n        \"\"\"\n        new_attrs = replace(self._json_attrs, source=new_source)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def description(self) -&gt; str:\n        \"\"\"\n        description of the forcefield and any modifications that have been added\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.description = \"OPLS forcefield with partial charges calculated via the LBCC algorithm\"\n\n        Returns\n        -------\n        str\n            description of the forcefield and any modifications that have been added\n        \"\"\"\n        return self._json_attrs.description\n\n    @description.setter\n    @beartype\n    def description(self, new_description: str) -&gt; None:\n        \"\"\"\n        set this computational_forcefields description\n\n        Parameters\n        ----------\n        new_description : str\n            new computational_forcefields description\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, description=new_description)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def data(self) -&gt; List[Union[Data, UIDProxy]]:\n        \"\"\"\n        details of mapping schema and forcefield parameters\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n        ...     type=\"calibration\",\n        ...     extension=\".pdf\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(\n        ...     name=\"my data node name\",\n        ...     type=\"afm_amp\",\n        ...     file=[my_file],\n        ... )\n        &gt;&gt;&gt; my_computational_forcefield.data = [my_data]\n\n        Returns\n        -------\n        List[Data]\n            list of data nodes for this computational_forcefield subobject\n        \"\"\"\n        return self._json_attrs.data.copy()\n\n    @data.setter\n    @beartype\n    def data(self, new_data: List[Union[Data, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the data attribute of this computational_forcefield node\n\n        Parameters\n        ----------\n        new_data : List[Data]\n            new list of data nodes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, data=new_data)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Union[Citation, UIDProxy]]:\n        \"\"\"\n        reference to a book, paper, or scholarly work\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n        ...     key=\"opls_aa\",\n        ...     building_block=\"atom\",\n        ... )\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"SOft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     \"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n        &gt;&gt;&gt; my_computational_forcefield.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            computational_forcefield list of citations\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the citation subobject of the computational_forcefield subobject\n\n        Parameters\n        ----------\n        new_citation : List[Citation]\n            new citation subobject\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.__init__","title":"<code>__init__(key, building_block, coarse_grained_mapping='', implicit_solvent='', source='', description='', data=None, citation=None, **kwargs)</code>","text":"<p>instantiate a computational_forcefield subobject</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>type of forcefield key must come from CRIPT Controlled Vocabulary</p> required <code>building_block</code> <code>str</code> <p>type of computational_forcefield building_block must come from CRIPT Controlled Vocabulary</p> required <code>coarse_grained_mapping</code> <code>str</code> <p>atom to beads mapping, by default \"\"</p> <code>''</code> <code>implicit_solvent</code> <code>str</code> <p>Name of implicit solvent, by default \"\"</p> <code>''</code> <code>source</code> <code>str</code> <p>source of forcefield, by default \"\"</p> <code>''</code> <code>description</code> <code>str</code> <p>description of the forcefield and any modifications that have been added, by default \"\"</p> <code>''</code> <code>data</code> <code>List[Data]</code> <p>details of mapping schema and forcefield parameters, by default None</p> <code>None</code> <code>citation</code> <code>Union[List[Citation], None]</code> <p>reference to a book, paper, or scholarly work, by default None</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n...     key=\"opls_aa\",\n...     building_block=\"atom\",\n... )\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>Instantiate a computational_forcefield subobject</p> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    key: str,\n    building_block: str,\n    coarse_grained_mapping: str = \"\",\n    implicit_solvent: str = \"\",\n    source: str = \"\",\n    description: str = \"\",\n    data: Optional[List[Union[Data, UIDProxy]]] = None,\n    citation: Optional[List[Union[Citation, UIDProxy]]] = None,\n    **kwargs\n):\n    \"\"\"\n    instantiate a computational_forcefield subobject\n\n    Parameters\n    ----------\n    key : str\n        type of forcefield key must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/computational_forcefield_key)\n    building_block : str\n        type of computational_forcefield building_block must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/building_block)\n    coarse_grained_mapping : str, optional\n        atom to beads mapping, by default \"\"\n    implicit_solvent : str, optional\n        Name of implicit solvent, by default \"\"\n    source : str, optional\n        source of forcefield, by default \"\"\n    description : str, optional\n        description of the forcefield and any modifications that have been added, by default \"\"\n    data : List[Data], optional\n        details of mapping schema and forcefield parameters, by default None\n    citation : Union[List[Citation], None], optional\n        reference to a book, paper, or scholarly work, by default None\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_computational_forcefield = cript.ComputationalForcefield(\n    ...     key=\"opls_aa\",\n    ...     building_block=\"atom\",\n    ... )\n\n    Returns\n    -------\n    None\n        Instantiate a computational_forcefield subobject\n    \"\"\"\n    if citation is None:\n        citation = []\n    super().__init__(**kwargs)\n\n    if data is None:\n        data = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        key=key,\n        building_block=building_block,\n        coarse_grained_mapping=coarse_grained_mapping,\n        implicit_solvent=implicit_solvent,\n        source=source,\n        description=description,\n        data=data,\n        citation=citation,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.building_block","title":"<code>building_block(new_building_block)</code>","text":"<p>type of building block</p> <p>Parameters:</p> Name Type Description Default <code>new_building_block</code> <code>str</code> <p>new type of building block</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@building_block.setter\n@beartype\ndef building_block(self, new_building_block: str) -&gt; None:\n    \"\"\"\n    type of building block\n\n    Parameters\n    ----------\n    new_building_block : str\n        new type of building block\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, building_block=new_building_block)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.citation","title":"<code>citation(new_citation)</code>","text":"<p>set the citation subobject of the computational_forcefield subobject</p> <p>Parameters:</p> Name Type Description Default <code>new_citation</code> <code>List[Citation]</code> <p>new citation subobject</p> required Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@citation.setter\n@beartype\ndef citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n    \"\"\"\n    set the citation subobject of the computational_forcefield subobject\n\n    Parameters\n    ----------\n    new_citation : List[Citation]\n        new citation subobject\n    \"\"\"\n    new_attrs = replace(self._json_attrs, citation=new_citation)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.coarse_grained_mapping","title":"<code>coarse_grained_mapping(new_coarse_grained_mapping)</code>","text":"<p>atom to beads mapping</p> <p>Parameters:</p> Name Type Description Default <code>new_coarse_grained_mapping</code> <code>str</code> <p>new coarse_grained_mapping</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@coarse_grained_mapping.setter\n@beartype\ndef coarse_grained_mapping(self, new_coarse_grained_mapping: str) -&gt; None:\n    \"\"\"\n    atom to beads mapping\n\n    Parameters\n    ----------\n    new_coarse_grained_mapping : str\n        new coarse_grained_mapping\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, coarse_grained_mapping=new_coarse_grained_mapping)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.data","title":"<code>data(new_data)</code>","text":"<p>set the data attribute of this computational_forcefield node</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>List[Data]</code> <p>new list of data nodes</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@data.setter\n@beartype\ndef data(self, new_data: List[Union[Data, UIDProxy]]) -&gt; None:\n    \"\"\"\n    set the data attribute of this computational_forcefield node\n\n    Parameters\n    ----------\n    new_data : List[Data]\n        new list of data nodes\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, data=new_data)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.description","title":"<code>description(new_description)</code>","text":"<p>set this computational_forcefields description</p> <p>Parameters:</p> Name Type Description Default <code>new_description</code> <code>str</code> <p>new computational_forcefields description</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@description.setter\n@beartype\ndef description(self, new_description: str) -&gt; None:\n    \"\"\"\n    set this computational_forcefields description\n\n    Parameters\n    ----------\n    new_description : str\n        new computational_forcefields description\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, description=new_description)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.implicit_solvent","title":"<code>implicit_solvent(new_implicit_solvent)</code>","text":"<p>set the implicit_solvent</p> <p>Parameters:</p> Name Type Description Default <code>new_implicit_solvent</code> <code>str</code> <p>new implicit_solvent</p> required Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@implicit_solvent.setter\n@beartype\ndef implicit_solvent(self, new_implicit_solvent: str) -&gt; None:\n    \"\"\"\n    set the implicit_solvent\n\n    Parameters\n    ----------\n    new_implicit_solvent : str\n        new implicit_solvent\n    \"\"\"\n    new_attrs = replace(self._json_attrs, implicit_solvent=new_implicit_solvent)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.key","title":"<code>key(new_key)</code>","text":"<p>set key for this computational_forcefield</p> <p>Parameters:</p> Name Type Description Default <code>new_key</code> <code>str</code> <p>computational_forcefield key</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@key.setter\n@beartype\ndef key(self, new_key: str) -&gt; None:\n    \"\"\"\n    set key for this computational_forcefield\n\n    Parameters\n    ----------\n    new_key : str\n        computational_forcefield key\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, key=new_key)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/computational_forcefield/#cript.nodes.subobjects.computational_forcefield.ComputationalForcefield.source","title":"<code>source(new_source)</code>","text":"<p>set the computational_forcefield</p> <p>Parameters:</p> Name Type Description Default <code>new_source</code> <code>str</code> <p>new source of forcefield</p> required Source code in <code>src/cript/nodes/subobjects/computational_forcefield.py</code> <pre><code>@source.setter\n@beartype\ndef source(self, new_source: str) -&gt; None:\n    \"\"\"\n    set the computational_forcefield\n\n    Parameters\n    ----------\n    new_source : str\n        new source of forcefield\n    \"\"\"\n    new_attrs = replace(self._json_attrs, source=new_source)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/","title":"Condition","text":""},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition","title":"<code>Condition</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition--definition","title":"Definition","text":"<p>A Condition sub-object is the conditions under which the experiment was conducted. Some examples include temperature, mixing_rate, stirring, time_duration.</p>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition--can-be-added-to","title":"Can Be Added To:","text":""},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition--primary-nodes","title":"Primary Nodes","text":"<ul> <li>Process</li> <li>Computation_Process</li> </ul>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition--subobjects","title":"Subobjects","text":"<ul> <li>Property</li> <li>Equipment</li> </ul>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition--attributes","title":"Attributes","text":"attribute type example description required vocab key str temp type of condition True True type str min type of value stored, 'value' is just the number, 'min', 'max', 'avg', etc. for series True True descriptor str upper temperature probe freeform description for condition value Number 1.23 value or quantity True unit str gram unit for value uncertainty Number 0.1 uncertainty of value uncertainty_type str std type of uncertainty True set_id int 0 ID of set (used to link measurements in as series) measurement _id int 0 ID for a single measurement (used to link multiple condition at a single instance) data List[Data] detailed data associated with the condition"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition--json-representation","title":"JSON Representation","text":"<pre><code>{\n    \"node\": [\"Condition\"],\n    \"key\": \"temperature\",\n    \"type\": \"value\",\n    \"descriptor\": \"room temperature of lab\",\n    \"value\": 22,\n    \"unit\": \"C\",\n    \"uncertainty\": 5,\n    \"uncertainty_type\": \"stdev\",\n    \"set_id\": 0,\n    \"measurement_id\": 2,\n    \"data\": [{\n        \"node\":[\"Data\"],\n        \"name\":\"my data name\",\n        \"type\":\"afm_amp\",\n        \"file\":[\n            {\n                \"node\":[\"File\"],\n                \"type\":\"calibration\",\n                \"source\":\"https://criptapp.org\",\n                \"extension\":\".csv\",\n                \"data_dictionary\":\"my file's data dictionary\"\n            }\n        ]\n    }],\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>class Condition(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n\n    A [Condition](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=21) sub-object\n    is the conditions under which the experiment was conducted.\n    Some examples include temperature, mixing_rate, stirring, time_duration.\n\n    ----\n\n    ## Can Be Added To:\n    ### Primary Nodes\n    * [Process](../../primary_nodes/process)\n    * [Computation_Process](../../primary_nodes/computation_process)\n\n    ### Subobjects\n    * [Property](../property)\n    * [Equipment](../equipment)\n\n    ---\n\n    ## Attributes\n\n    | attribute        | type   | example                 | description                                                                            | required | vocab |\n    |------------------|--------|-------------------------|----------------------------------------------------------------------------------------|----------|-------|\n    | key              | str    | temp                    | type of condition                                                                      | True     | True  |\n    | type             | str    | min                     | type of value stored, 'value' is just the number, 'min', 'max', 'avg', etc. for series | True     | True  |\n    | descriptor       | str    | upper temperature probe | freeform description for condition                                                     |          |       |\n    | value            | Number | 1.23                    | value or quantity                                                                      | True     |       |\n    | unit             | str    | gram                    | unit for value                                                                         |          |       |\n    | uncertainty      | Number | 0.1                     | uncertainty of value                                                                   |          |       |\n    | uncertainty_type | str    | std                     | type of uncertainty                                                                    |          | True  |\n    | set_id           | int    | 0                       | ID of set (used to link measurements in as series)                                     |          |       |\n    | measurement _id  | int    | 0                       | ID for a single measurement (used to link multiple condition at a single instance)     |          |       |\n    | data             | List[Data] |                         | detailed data associated with the condition                                            |          |       |\n\n    ## JSON Representation\n    ```json\n    {\n        \"node\": [\"Condition\"],\n        \"key\": \"temperature\",\n        \"type\": \"value\",\n        \"descriptor\": \"room temperature of lab\",\n        \"value\": 22,\n        \"unit\": \"C\",\n        \"uncertainty\": 5,\n        \"uncertainty_type\": \"stdev\",\n        \"set_id\": 0,\n        \"measurement_id\": 2,\n        \"data\": [{\n            \"node\":[\"Data\"],\n            \"name\":\"my data name\",\n            \"type\":\"afm_amp\",\n            \"file\":[\n                {\n                    \"node\":[\"File\"],\n                    \"type\":\"calibration\",\n                    \"source\":\"https://criptapp.org\",\n                    \"extension\":\".csv\",\n                    \"data_dictionary\":\"my file's data dictionary\"\n                }\n            ]\n        }],\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        type: str = \"\"\n        descriptor: str = \"\"\n        value: Optional[Union[Number, str]] = None\n        unit: str = \"\"\n        uncertainty: Optional[Union[Number, str]] = None\n        uncertainty_type: str = \"\"\n        set_id: Optional[int] = None\n        measurement_id: Optional[int] = None\n        data: List[Union[Data, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        key: str,\n        type: str,\n        value: Union[Number, str],\n        unit: str = \"\",\n        descriptor: str = \"\",\n        uncertainty: Optional[Union[Number, str]] = None,\n        uncertainty_type: str = \"\",\n        set_id: Optional[int] = None,\n        measurement_id: Optional[int] = None,\n        data: Optional[List[Union[Data, UIDProxy]]] = None,\n        **kwargs\n    ):\n        \"\"\"\n        create Condition sub-object\n\n        Parameters\n        ----------\n        key : str\n            type of condition\n        type : str\n            type of value stored\n        value : Number\n            value or quantity\n        unit : str, optional\n            unit for value, by default \"\"\n        descriptor : str, optional\n            freeform description for condition, by default \"\"\n        uncertainty : Union[Number, None], optional\n           uncertainty of value, by default None\n        uncertainty_type : str, optional\n            type of uncertainty, by default \"\"\n        set_id : Union[int, None], optional\n            ID of set (used to link measurements in as series), by default None\n        measurement_id : Union[int, None], optional\n            ID for a single measurement (used to link multiple condition at a single instance), by default None\n        data : List[Data], optional\n            detailed data associated with the condition, by default None\n\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().__init__(**kwargs)\n\n        if data is None:\n            data = []\n\n        new_json_attrs = replace(\n            self._json_attrs,\n            key=key,\n            type=type,\n            value=value,\n            descriptor=descriptor,\n            unit=unit,\n            uncertainty=uncertainty,\n            uncertainty_type=uncertainty_type,\n            set_id=set_id,\n            measurement_id=measurement_id,\n            data=data,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def key(self) -&gt; str:\n        \"\"\"\n        type of condition\n\n        &gt; Condition key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/condition_key)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.key = \"energy_threshold\"\n\n        Returns\n        -------\n        condition key: str\n            type of condition\n        \"\"\"\n        return self._json_attrs.key\n\n    @key.setter\n    @beartype\n    def key(self, new_key: str) -&gt; None:\n        \"\"\"\n        set this Condition sub-object key\n\n        Parameters\n        ----------\n        new_key : str\n            type of condition\n\n        Returns\n        --------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        description for the value stored for this Condition node\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.type = \"min\"\n\n        Returns\n        -------\n        condition type: str\n            description for the value\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_type: str) -&gt; None:\n        \"\"\"\n        set the type attribute for this Condition node\n\n        Parameters\n        ----------\n        new_type : str\n            new description of the Condition value\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def descriptor(self) -&gt; str:\n        \"\"\"\n        freeform description for Condition\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.descriptor = \"my condition description\"\n\n        Returns\n        -------\n        description: str\n            description of this Condition sub-object\n        \"\"\"\n        return self._json_attrs.descriptor\n\n    @descriptor.setter\n    @beartype\n    def descriptor(self, new_descriptor: str) -&gt; None:\n        \"\"\"\n        set the description of this Condition sub-object\n\n        Parameters\n        ----------\n        new_descriptor : str\n            new description describing the Condition subobject\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, descriptor=new_descriptor)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def value(self) -&gt; Optional[Union[Number, str]]:\n        \"\"\"\n        value or quantity\n\n        Returns\n        -------\n        Union[Number, None]\n            new value or quantity\n        \"\"\"\n        return self._json_attrs.value\n\n    def set_value(self, new_value: Union[Number, str], new_unit: str) -&gt; None:\n        \"\"\"\n        set the value for this Condition subobject\n\n        Parameters\n        ----------\n        new_value : Number\n            new value\n        new_unit : str\n            units for the new value\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.set_value(new_value=1, new_unit=\"gram\")\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, value=new_value, unit=new_unit)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def unit(self) -&gt; str:\n        \"\"\"\n        set units for this Condition subobject\n\n        Returns\n        -------\n        unit: str\n            units\n        \"\"\"\n        return self._json_attrs.unit\n\n    @property\n    @beartype\n    def uncertainty(self) -&gt; Optional[Union[Number, str]]:\n        \"\"\"\n        set uncertainty value for this Condition subobject\n\n        Returns\n        -------\n        uncertainty: Union[Number, None]\n            uncertainty\n        \"\"\"\n        return self._json_attrs.uncertainty\n\n    @beartype\n    def set_uncertainty(self, new_uncertainty: Union[Number, str, None], new_uncertainty_type: str) -&gt; None:\n        \"\"\"\n        set uncertainty and uncertainty type\n\n        Parameters\n        ----------\n        new_uncertainty : Number\n            new uncertainty value\n        new_uncertainty_type : str\n            new uncertainty type\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.set_uncertainty(new_uncertainty=0.2, new_uncertainty_type=\"stdev\")\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, uncertainty=new_uncertainty, uncertainty_type=new_uncertainty_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def uncertainty_type(self) -&gt; str:\n        \"\"\"\n        Uncertainty type for the uncertainty value\n\n        [Uncertainty type](https://app.criptapp.org/vocab/uncertainty_type) must come from CRIPT controlled vocabulary\n\n        Returns\n        -------\n        uncertainty_type: str\n            uncertainty type\n        \"\"\"\n        return self._json_attrs.uncertainty_type\n\n    @property\n    @beartype\n    def set_id(self) -&gt; Union[int, None]:\n        \"\"\"\n        ID of set (used to link measurements in as series)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.set_id = 0\n\n        Returns\n        -------\n        set_id: Union[int, None]\n            ID of set\n        \"\"\"\n        return self._json_attrs.set_id\n\n    @set_id.setter\n    @beartype\n    def set_id(self, new_set_id: Union[int, None]) -&gt; None:\n        \"\"\"\n         set this Condition subobjects set_id\n\n        Parameters\n        ----------\n        new_set_id : Union[int, None]\n            ID of set\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, set_id=new_set_id)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def measurement_id(self) -&gt; Union[int, None]:\n        \"\"\"\n        ID for a single measurement (used to link multiple condition at a single instance)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.measurement_id = 0\n\n        Returns\n        -------\n        measurement_id: Union[int, None]\n            ID for a single measurement\n        \"\"\"\n        return self._json_attrs.measurement_id\n\n    @measurement_id.setter\n    @beartype\n    def measurement_id(self, new_measurement_id: Union[int, None]) -&gt; None:\n        \"\"\"\n        set the set_id for this Condition subobject\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_condition.measurement_id = 1\n\n        Parameters\n        ----------\n        new_measurement_id : Union[int, None]\n            ID for a single measurement\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, measurement_id=new_measurement_id)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def data(self) -&gt; List[Union[Data, UIDProxy]]:\n        \"\"\"\n        detailed data associated with the condition\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n        ...     type=\"calibration\",\n        ...     extension=\".pdf\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(\n        ...     name=\"my data node name\",\n        ...     type=\"afm_amp\",\n        ...     file=[my_file],\n        ... )\n        &gt;&gt;&gt; my_condition.data = [my_data]\n\n        Returns\n        -------\n        Condition: Union[Data, None]\n            detailed data associated with the condition\n        \"\"\"\n        return self._json_attrs.data.copy()\n\n    @data.setter\n    @beartype\n    def data(self, new_data: List[Union[Data, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the data node for this Condition Subobject\n\n        Parameters\n        ----------\n        new_data : List[Data]\n            new Data node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, data=new_data)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.__init__","title":"<code>__init__(key, type, value, unit='', descriptor='', uncertainty=None, uncertainty_type='', set_id=None, measurement_id=None, data=None, **kwargs)</code>","text":"<p>create Condition sub-object</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>type of condition</p> required <code>type</code> <code>str</code> <p>type of value stored</p> required <code>value</code> <code>Number</code> <p>value or quantity</p> required <code>unit</code> <code>str</code> <p>unit for value, by default \"\"</p> <code>''</code> <code>descriptor</code> <code>str</code> <p>freeform description for condition, by default \"\"</p> <code>''</code> <code>uncertainty</code> <code>Union[Number, None]</code> <p>uncertainty of value, by default None</p> <code>None</code> <code>uncertainty_type</code> <code>str</code> <p>type of uncertainty, by default \"\"</p> <code>''</code> <code>set_id</code> <code>Union[int, None]</code> <p>ID of set (used to link measurements in as series), by default None</p> <code>None</code> <code>measurement_id</code> <code>Union[int, None]</code> <p>ID for a single measurement (used to link multiple condition at a single instance), by default None</p> <code>None</code> <code>data</code> <code>List[Data]</code> <p>detailed data associated with the condition, by default None</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_condition = cript.Condition(\n...     key=\"temperature\",\n...     type=\"value\",\n...     value=22,\n...     unit=\"C\",\n... )\n</code></pre> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    key: str,\n    type: str,\n    value: Union[Number, str],\n    unit: str = \"\",\n    descriptor: str = \"\",\n    uncertainty: Optional[Union[Number, str]] = None,\n    uncertainty_type: str = \"\",\n    set_id: Optional[int] = None,\n    measurement_id: Optional[int] = None,\n    data: Optional[List[Union[Data, UIDProxy]]] = None,\n    **kwargs\n):\n    \"\"\"\n    create Condition sub-object\n\n    Parameters\n    ----------\n    key : str\n        type of condition\n    type : str\n        type of value stored\n    value : Number\n        value or quantity\n    unit : str, optional\n        unit for value, by default \"\"\n    descriptor : str, optional\n        freeform description for condition, by default \"\"\n    uncertainty : Union[Number, None], optional\n       uncertainty of value, by default None\n    uncertainty_type : str, optional\n        type of uncertainty, by default \"\"\n    set_id : Union[int, None], optional\n        ID of set (used to link measurements in as series), by default None\n    measurement_id : Union[int, None], optional\n        ID for a single measurement (used to link multiple condition at a single instance), by default None\n    data : List[Data], optional\n        detailed data associated with the condition, by default None\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_condition = cript.Condition(\n    ...     key=\"temperature\",\n    ...     type=\"value\",\n    ...     value=22,\n    ...     unit=\"C\",\n    ... )\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__(**kwargs)\n\n    if data is None:\n        data = []\n\n    new_json_attrs = replace(\n        self._json_attrs,\n        key=key,\n        type=type,\n        value=value,\n        descriptor=descriptor,\n        unit=unit,\n        uncertainty=uncertainty,\n        uncertainty_type=uncertainty_type,\n        set_id=set_id,\n        measurement_id=measurement_id,\n        data=data,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.data","title":"<code>data(new_data)</code>","text":"<p>set the data node for this Condition Subobject</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>List[Data]</code> <p>new Data node</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@data.setter\n@beartype\ndef data(self, new_data: List[Union[Data, UIDProxy]]) -&gt; None:\n    \"\"\"\n    set the data node for this Condition Subobject\n\n    Parameters\n    ----------\n    new_data : List[Data]\n        new Data node\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, data=new_data)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.descriptor","title":"<code>descriptor(new_descriptor)</code>","text":"<p>set the description of this Condition sub-object</p> <p>Parameters:</p> Name Type Description Default <code>new_descriptor</code> <code>str</code> <p>new description describing the Condition subobject</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@descriptor.setter\n@beartype\ndef descriptor(self, new_descriptor: str) -&gt; None:\n    \"\"\"\n    set the description of this Condition sub-object\n\n    Parameters\n    ----------\n    new_descriptor : str\n        new description describing the Condition subobject\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, descriptor=new_descriptor)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.key","title":"<code>key(new_key)</code>","text":"<p>set this Condition sub-object key</p> <p>Parameters:</p> Name Type Description Default <code>new_key</code> <code>str</code> <p>type of condition</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@key.setter\n@beartype\ndef key(self, new_key: str) -&gt; None:\n    \"\"\"\n    set this Condition sub-object key\n\n    Parameters\n    ----------\n    new_key : str\n        type of condition\n\n    Returns\n    --------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, key=new_key)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.measurement_id","title":"<code>measurement_id(new_measurement_id)</code>","text":"<p>set the set_id for this Condition subobject</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_condition = cript.Condition(\n...     key=\"temperature\",\n...     type=\"value\",\n...     value=22,\n...     unit=\"C\",\n... )\n&gt;&gt;&gt; my_condition.measurement_id = 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>new_measurement_id</code> <code>Union[int, None]</code> <p>ID for a single measurement</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@measurement_id.setter\n@beartype\ndef measurement_id(self, new_measurement_id: Union[int, None]) -&gt; None:\n    \"\"\"\n    set the set_id for this Condition subobject\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_condition = cript.Condition(\n    ...     key=\"temperature\",\n    ...     type=\"value\",\n    ...     value=22,\n    ...     unit=\"C\",\n    ... )\n    &gt;&gt;&gt; my_condition.measurement_id = 1\n\n    Parameters\n    ----------\n    new_measurement_id : Union[int, None]\n        ID for a single measurement\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, measurement_id=new_measurement_id)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.set_id","title":"<code>set_id(new_set_id)</code>","text":"<p>set this Condition subobjects set_id</p> <p>Parameters:</p> Name Type Description Default <code>new_set_id</code> <code>Union[int, None]</code> <p>ID of set</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@set_id.setter\n@beartype\ndef set_id(self, new_set_id: Union[int, None]) -&gt; None:\n    \"\"\"\n     set this Condition subobjects set_id\n\n    Parameters\n    ----------\n    new_set_id : Union[int, None]\n        ID of set\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, set_id=new_set_id)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.set_uncertainty","title":"<code>set_uncertainty(new_uncertainty, new_uncertainty_type)</code>","text":"<p>set uncertainty and uncertainty type</p> <p>Parameters:</p> Name Type Description Default <code>new_uncertainty</code> <code>Number</code> <p>new uncertainty value</p> required <code>new_uncertainty_type</code> <code>str</code> <p>new uncertainty type</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_condition = cript.Condition(\n...     key=\"temperature\",\n...     type=\"value\",\n...     value=22,\n...     unit=\"C\",\n... )\n&gt;&gt;&gt; my_condition.set_uncertainty(new_uncertainty=0.2, new_uncertainty_type=\"stdev\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@beartype\ndef set_uncertainty(self, new_uncertainty: Union[Number, str, None], new_uncertainty_type: str) -&gt; None:\n    \"\"\"\n    set uncertainty and uncertainty type\n\n    Parameters\n    ----------\n    new_uncertainty : Number\n        new uncertainty value\n    new_uncertainty_type : str\n        new uncertainty type\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_condition = cript.Condition(\n    ...     key=\"temperature\",\n    ...     type=\"value\",\n    ...     value=22,\n    ...     unit=\"C\",\n    ... )\n    &gt;&gt;&gt; my_condition.set_uncertainty(new_uncertainty=0.2, new_uncertainty_type=\"stdev\")\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, uncertainty=new_uncertainty, uncertainty_type=new_uncertainty_type)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.set_value","title":"<code>set_value(new_value, new_unit)</code>","text":"<p>set the value for this Condition subobject</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>Number</code> <p>new value</p> required <code>new_unit</code> <code>str</code> <p>units for the new value</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_condition = cript.Condition(\n...     key=\"temperature\",\n...     type=\"value\",\n...     value=22,\n...     unit=\"C\",\n... )\n&gt;&gt;&gt; my_condition.set_value(new_value=1, new_unit=\"gram\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>def set_value(self, new_value: Union[Number, str], new_unit: str) -&gt; None:\n    \"\"\"\n    set the value for this Condition subobject\n\n    Parameters\n    ----------\n    new_value : Number\n        new value\n    new_unit : str\n        units for the new value\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_condition = cript.Condition(\n    ...     key=\"temperature\",\n    ...     type=\"value\",\n    ...     value=22,\n    ...     unit=\"C\",\n    ... )\n    &gt;&gt;&gt; my_condition.set_value(new_value=1, new_unit=\"gram\")\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, value=new_value, unit=new_unit)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.type","title":"<code>type(new_type)</code>","text":"<p>set the type attribute for this Condition node</p> <p>Parameters:</p> Name Type Description Default <code>new_type</code> <code>str</code> <p>new description of the Condition value</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@type.setter\n@beartype\ndef type(self, new_type: str) -&gt; None:\n    \"\"\"\n    set the type attribute for this Condition node\n\n    Parameters\n    ----------\n    new_type : str\n        new description of the Condition value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, type=new_type)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.uncertainty","title":"<code>uncertainty()</code>","text":"<p>set uncertainty value for this Condition subobject</p> <p>Returns:</p> Name Type Description <code>uncertainty</code> <code>Union[Number, None]</code> <p>uncertainty</p> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@property\n@beartype\ndef uncertainty(self) -&gt; Optional[Union[Number, str]]:\n    \"\"\"\n    set uncertainty value for this Condition subobject\n\n    Returns\n    -------\n    uncertainty: Union[Number, None]\n        uncertainty\n    \"\"\"\n    return self._json_attrs.uncertainty\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.uncertainty_type","title":"<code>uncertainty_type()</code>","text":"<p>Uncertainty type for the uncertainty value</p> <p>Uncertainty type must come from CRIPT controlled vocabulary</p> <p>Returns:</p> Name Type Description <code>uncertainty_type</code> <code>str</code> <p>uncertainty type</p> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@property\n@beartype\ndef uncertainty_type(self) -&gt; str:\n    \"\"\"\n    Uncertainty type for the uncertainty value\n\n    [Uncertainty type](https://app.criptapp.org/vocab/uncertainty_type) must come from CRIPT controlled vocabulary\n\n    Returns\n    -------\n    uncertainty_type: str\n        uncertainty type\n    \"\"\"\n    return self._json_attrs.uncertainty_type\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.unit","title":"<code>unit()</code>","text":"<p>set units for this Condition subobject</p> <p>Returns:</p> Name Type Description <code>unit</code> <code>str</code> <p>units</p> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@property\n@beartype\ndef unit(self) -&gt; str:\n    \"\"\"\n    set units for this Condition subobject\n\n    Returns\n    -------\n    unit: str\n        units\n    \"\"\"\n    return self._json_attrs.unit\n</code></pre>"},{"location":"nodes/subobjects/condition/#cript.nodes.subobjects.condition.Condition.value","title":"<code>value()</code>","text":"<p>value or quantity</p> <p>Returns:</p> Type Description <code>Union[Number, None]</code> <p>new value or quantity</p> Source code in <code>src/cript/nodes/subobjects/condition.py</code> <pre><code>@property\n@beartype\ndef value(self) -&gt; Optional[Union[Number, str]]:\n    \"\"\"\n    value or quantity\n\n    Returns\n    -------\n    Union[Number, None]\n        new value or quantity\n    \"\"\"\n    return self._json_attrs.value\n</code></pre>"},{"location":"nodes/subobjects/equipment/","title":"Equipment","text":""},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment","title":"<code>Equipment</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment--definition","title":"Definition","text":"<p>An Equipment sub-object specifies the physical instruments, tools, glassware, etc. used in a process.</p>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>Process node</li> </ul>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment--available-sub-objects","title":"Available sub-objects:","text":"<ul> <li>Condition</li> <li>Citation</li> </ul>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment--attributes","title":"Attributes","text":"attribute type example description required vocab key str hot plate material True True description str Hot plate with silicon oil bath with stir bar additional details about the equipment condition list[Condition] conditions under which the property was measured files list[File] list of file nodes to link to calibration or equipment specification documents citation list[Citation] reference to a book, paper, or scholarly work"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"node\":[\"Equipment\"],\n   \"description\": \"my equipment description\",\n   \"key\":\"burner\",\n   \"uid\":\"_:19708284-1bd7-42e4-b8b2-da7ea0bc2ac9\",\n   \"uuid\":\"19708284-1bd7-42e4-b8b2-da7ea0bc2ac9\"\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/equipment.py</code> <pre><code>class Equipment(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n    An [Equipment](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=23)\n    sub-object specifies the physical instruments, tools, glassware, etc. used in a process.\n\n    ---\n\n    ## Can Be Added To:\n    * [Process node](../../primary_nodes/process)\n\n    ## Available sub-objects:\n    * [Condition](../condition)\n    * [Citation](../citation)\n\n    ---\n\n    ## Attributes\n\n    | attribute   | type            | example                                       | description                                                                    | required | vocab |\n    |-------------|-----------------|-----------------------------------------------|--------------------------------------------------------------------------------|----------|-------|\n    | key         | str             | hot plate                                     | material                                                                       | True     | True  |\n    | description | str             | Hot plate with silicon oil bath with stir bar | additional details about the equipment                                         |          |       |\n    | condition   | list[Condition] |                                               | conditions under which the property was measured                               |          |       |\n    | files       | list[File]      |                                               | list of file nodes to link to calibration or equipment specification documents |          |       |\n    | citation    | list[Citation]  |                                               | reference to a book, paper, or scholarly work                                  |          |       |\n\n    ## JSON Representation\n    ```json\n    {\n       \"node\":[\"Equipment\"],\n       \"description\": \"my equipment description\",\n       \"key\":\"burner\",\n       \"uid\":\"_:19708284-1bd7-42e4-b8b2-da7ea0bc2ac9\",\n       \"uuid\":\"19708284-1bd7-42e4-b8b2-da7ea0bc2ac9\"\n    }\n    ```\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        description: str = \"\"\n        condition: List[Union[Condition, UIDProxy]] = field(default_factory=list)\n        file: List[Union[File, UIDProxy]] = field(default_factory=list)\n        citation: List[Union[Citation, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, key: str, description: str = \"\", condition: Optional[List[Union[Condition, UIDProxy]]] = None, file: Optional[List[Union[File, UIDProxy]]] = None, citation: Optional[List[Union[Citation, UIDProxy]]] = None, **kwargs) -&gt; None:\n        \"\"\"\n        create equipment sub-object\n\n        Parameters\n        ----------\n        key : str\n            Equipment key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/equipment_key)\n        description : str, optional\n            additional details about the equipment, by default \"\"\n        condition : Union[List[Condition], None], optional\n            Conditions under which the property was measured, by default None\n        file : Union[List[File], None], optional\n            list of file nodes to link to calibration or equipment specification documents, by default None\n        citation : Union[List[Citation], None], optional\n            reference to a scholarly work, by default None\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n\n        Returns\n        -------\n        None\n            instantiate equipment sub-object\n        \"\"\"\n        if condition is None:\n            condition = []\n        if file is None:\n            file = []\n        if citation is None:\n            citation = []\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, key=key, description=description, condition=condition, file=file, citation=citation)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def key(self) -&gt; str:\n        \"\"\"\n        scientific instrument\n\n        Equipment key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/equipment_key)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n        &gt;&gt;&gt; my_equipment.key = \"hot_plate\"\n\n        Returns\n        -------\n        Equipment: str\n        \"\"\"\n        return self._json_attrs.key\n\n    @key.setter\n    @beartype\n    def key(self, new_key: str) -&gt; None:\n        \"\"\"\n        set the equipment key\n\n        Parameters\n        ----------\n        new_key : str\n            equipment sub-object key\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def description(self) -&gt; str:\n        \"\"\"\n        description of the equipment\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n        &gt;&gt;&gt; my_equipment.description = \"additional details about the equipment\"\n\n        Returns\n        -------\n        str\n            additional description of the equipment\n        \"\"\"\n        return self._json_attrs.description\n\n    @description.setter\n    @beartype\n    def description(self, new_description: str) -&gt; None:\n        \"\"\"\n        set this equipments description\n\n        Parameters\n        ----------\n        new_description : str\n            equipment description\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, description=new_description)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def condition(self) -&gt; List[Union[Condition, UIDProxy]]:\n        \"\"\"\n        conditions under which the property was measured\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n        &gt;&gt;&gt; my_condition = cript.Condition(\n        ...     key=\"temperature\",\n        ...     type=\"value\",\n        ...     value=22,\n        ...     unit=\"C\",\n        ... )\n        &gt;&gt;&gt; my_equipment.condition = [my_condition]\n\n        Returns\n        -------\n        List[Condition]\n            list of Condition sub-objects\n        \"\"\"\n        return self._json_attrs.condition.copy()\n\n    @condition.setter\n    @beartype\n    def condition(self, new_condition: List[Union[Condition, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set a list of Conditions for the equipment sub-object\n\n        Parameters\n        ----------\n        new_condition : List[Condition]\n            list of Condition sub-objects\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, condition=new_condition)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def file(self) -&gt; List[Union[File, UIDProxy]]:\n        \"\"\"\n        list of file nodes to link to calibration or equipment specification documents\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n        ...     type=\"calibration\",\n        ...     extension=\".pdf\",\n        ... )\n        &gt;&gt;&gt; my_equipment.file = [my_file]\n\n        Returns\n        -------\n        List[File]\n            list of file nodes\n        \"\"\"\n        return self._json_attrs.file.copy()\n\n    @file.setter\n    @beartype\n    def file(self, new_file: List[Union[File, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the file node for the equipment subobject\n\n        Parameters\n        ----------\n        new_file : List[File]\n            list of File nodes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, file=new_file)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Union[Citation, UIDProxy]]:\n        \"\"\"\n        reference to a book, paper, or scholarly work\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n        &gt;&gt;&gt; my_equipment.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of Citation subobjects\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the citation subobject for this equipment subobject\n\n        Parameters\n        ----------\n        new_citation : List[Citation]\n            list of Citation subobjects\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment.citation","title":"<code>citation: List[Union[Citation, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>reference to a book, paper, or scholarly work</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n&gt;&gt;&gt; title = (\n...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n... )\n&gt;&gt;&gt; my_reference = cript.Reference(\n...     type=\"journal_article\",\n...     title=title,\n...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n...     journal=\"Computer Physics Communications\",\n...     publisher=\"Elsevier\",\n...     year=2019,\n...     pages=[463, 476],\n...     doi=\"10.1016/j.cpc.2018.08.011\",\n...     issn=\"0010-4655\",\n...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n... )\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n&gt;&gt;&gt; my_equipment.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of Citation subobjects</p>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment.condition","title":"<code>condition: List[Union[Condition, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>conditions under which the property was measured</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n&gt;&gt;&gt; my_condition = cript.Condition(\n...     key=\"temperature\",\n...     type=\"value\",\n...     value=22,\n...     unit=\"C\",\n... )\n&gt;&gt;&gt; my_equipment.condition = [my_condition]\n</code></pre> <p>Returns:</p> Type Description <code>List[Condition]</code> <p>list of Condition sub-objects</p>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment.description","title":"<code>description: str</code>  <code>property</code> <code>writable</code>","text":"<p>description of the equipment</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n&gt;&gt;&gt; my_equipment.description = \"additional details about the equipment\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>additional description of the equipment</p>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment.file","title":"<code>file: List[Union[File, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of file nodes to link to calibration or equipment specification documents</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n...     type=\"calibration\",\n...     extension=\".pdf\",\n... )\n&gt;&gt;&gt; my_equipment.file = [my_file]\n</code></pre> <p>Returns:</p> Type Description <code>List[File]</code> <p>list of file nodes</p>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment.key","title":"<code>key: str</code>  <code>property</code> <code>writable</code>","text":"<p>scientific instrument</p> <p>Equipment key must come from CRIPT Controlled Vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n&gt;&gt;&gt; my_equipment.key = \"hot_plate\"\n</code></pre> <p>Returns:</p> Name Type Description <code>Equipment</code> <code>str</code>"},{"location":"nodes/subobjects/equipment/#cript.nodes.subobjects.equipment.Equipment.__init__","title":"<code>__init__(key, description='', condition=None, file=None, citation=None, **kwargs)</code>","text":"<p>create equipment sub-object</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Equipment key must come from CRIPT Controlled Vocabulary</p> required <code>description</code> <code>str</code> <p>additional details about the equipment, by default \"\"</p> <code>''</code> <code>condition</code> <code>Union[List[Condition], None]</code> <p>Conditions under which the property was measured, by default None</p> <code>None</code> <code>file</code> <code>Union[List[File], None]</code> <p>list of file nodes to link to calibration or equipment specification documents, by default None</p> <code>None</code> <code>citation</code> <code>Union[List[Citation], None]</code> <p>reference to a scholarly work, by default None</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>instantiate equipment sub-object</p> Source code in <code>src/cript/nodes/subobjects/equipment.py</code> <pre><code>@beartype\ndef __init__(self, key: str, description: str = \"\", condition: Optional[List[Union[Condition, UIDProxy]]] = None, file: Optional[List[Union[File, UIDProxy]]] = None, citation: Optional[List[Union[Citation, UIDProxy]]] = None, **kwargs) -&gt; None:\n    \"\"\"\n    create equipment sub-object\n\n    Parameters\n    ----------\n    key : str\n        Equipment key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/equipment_key)\n    description : str, optional\n        additional details about the equipment, by default \"\"\n    condition : Union[List[Condition], None], optional\n        Conditions under which the property was measured, by default None\n    file : Union[List[File], None], optional\n        list of file nodes to link to calibration or equipment specification documents, by default None\n    citation : Union[List[Citation], None], optional\n        reference to a scholarly work, by default None\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_equipment = cript.Equipment(key=\"burner\")\n\n    Returns\n    -------\n    None\n        instantiate equipment sub-object\n    \"\"\"\n    if condition is None:\n        condition = []\n    if file is None:\n        file = []\n    if citation is None:\n        citation = []\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, key=key, description=description, condition=condition, file=file, citation=citation)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/identifier/","title":"Identifier","text":""},{"location":"nodes/subobjects/identifier/#identifier-subobject","title":"Identifier Subobject","text":""},{"location":"nodes/subobjects/ingredient/","title":"Ingredient","text":""},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient","title":"<code>Ingredient</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient--definition","title":"Definition","text":"<p>An Ingredient sub-objects are links to material nodes with the associated quantities.</p>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>process</li> <li>computation_process</li> </ul>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient--available-sub-objects","title":"Available sub-objects:","text":"<ul> <li>Quantity</li> </ul>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient--attributes","title":"Attributes","text":"attribute type example description required vocab material Material material True quantity list[Quantity] quantities True keyword list(str) catalyst keyword for ingredient True"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient--json-representation","title":"JSON Representation","text":"<pre><code>{\n    \"node\":[\"Ingredient\"],\n    \"keyword\":[\"catalyst\"],\n    \"uid\":\"_:32f173ab-a98a-449b-a528-1b656f652dd3\",\n    \"uuid\":\"32f173ab-a98a-449b-a528-1b656f652dd3\"\n   \"material\":{\n      \"name\":\"my material 1\",\n      \"node\":[\"Material\"],\n      \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n      \"uid\":\"_:029367a8-aee7-493a-bc08-991e0f6939ae\",\n      \"uuid\":\"029367a8-aee7-493a-bc08-991e0f6939ae\"\n   },\n   \"quantity\":[\n      {\n         \"node\":[\"Quantity\"],\n         \"key\":\"mass\",\n         \"value\":11.2\n         \"uncertainty\":0.2,\n         \"uncertainty_type\":\"stdev\",\n         \"unit\":\"kg\",\n         \"uid\":\"_:c95ee781-923b-4699-ba3b-923ce186ac5d\",\n         \"uuid\":\"c95ee781-923b-4699-ba3b-923ce186ac5d\",\n      }\n   ]\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/ingredient.py</code> <pre><code>class Ingredient(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n    An [Ingredient](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=22)\n    sub-objects are links to material nodes with the associated quantities.\n\n    ---\n\n    ## Can Be Added To:\n    * [process](../../primary_nodes/process)\n    * [computation_process](../../primary_nodes/computation_process)\n\n    ## Available sub-objects:\n    * [Quantity](../quantity)\n\n    ---\n\n    ## Attributes\n\n    | attribute  | type           | example  | description            | required | vocab |\n    |------------|----------------|----------|------------------------|----------|-------|\n    | material   | Material       |          | material               | True     |       |\n    | quantity   | list[Quantity] |          | quantities             | True     |       |\n    | keyword    | list(str)      | catalyst | keyword for ingredient |          | True  |\n\n    ## JSON Representation\n    ```json\n    {\n        \"node\":[\"Ingredient\"],\n        \"keyword\":[\"catalyst\"],\n        \"uid\":\"_:32f173ab-a98a-449b-a528-1b656f652dd3\",\n        \"uuid\":\"32f173ab-a98a-449b-a528-1b656f652dd3\"\n       \"material\":{\n          \"name\":\"my material 1\",\n          \"node\":[\"Material\"],\n          \"bigsmiles\":\"[H]{[&gt;][&lt;]C(C[&gt;])c1ccccc1[]}\",\n          \"uid\":\"_:029367a8-aee7-493a-bc08-991e0f6939ae\",\n          \"uuid\":\"029367a8-aee7-493a-bc08-991e0f6939ae\"\n       },\n       \"quantity\":[\n          {\n             \"node\":[\"Quantity\"],\n             \"key\":\"mass\",\n             \"value\":11.2\n             \"uncertainty\":0.2,\n             \"uncertainty_type\":\"stdev\",\n             \"unit\":\"kg\",\n             \"uid\":\"_:c95ee781-923b-4699-ba3b-923ce186ac5d\",\n             \"uuid\":\"c95ee781-923b-4699-ba3b-923ce186ac5d\",\n          }\n       ]\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        material: Optional[Union[Material, UIDProxy]] = None\n        quantity: List[Union[Quantity, UIDProxy]] = field(default_factory=list)\n        keyword: List[str] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, material: Union[Material, UIDProxy], quantity: List[Union[Quantity, UIDProxy]], keyword: Optional[List[str]] = None, **kwargs):\n        \"\"\"\n        create an ingredient sub-object\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles=\"my bigsmiles\")\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n        ... )\n\n        Parameters\n        ----------\n        material : Material\n            material node\n        quantity : List[Quantity]\n            list of quantity sub-objects\n        keyword : List[str], optional\n            ingredient keyword must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/ingredient_keyword), by default \"\"\n\n        Returns\n        -------\n        None\n            Create new Ingredient sub-object\n        \"\"\"\n        super().__init__(**kwargs)\n        if keyword is None:\n            keyword = []\n        new_json_attrs = replace(self._json_attrs, material=material, quantity=quantity, keyword=keyword)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @classmethod\n    def _from_json(cls, json_dict: dict):\n        # TODO: remove this temporary fix, once back end is working correctly\n        if isinstance(json_dict[\"material\"], list):\n            json_dict[\"material\"] = json_dict[\"material\"][0]\n        return super(Ingredient, cls)._from_json(json_dict)\n\n    @property\n    @beartype\n    def material(self) -&gt; Union[Material, None, UIDProxy]:\n        \"\"\"\n        current material in this ingredient sub-object\n\n        Returns\n        -------\n        Material\n            Material node within the ingredient sub-object\n        \"\"\"\n        return self._json_attrs.material\n\n    @property\n    @beartype\n    def quantity(self) -&gt; List[Union[Quantity, UIDProxy]]:\n        \"\"\"\n        quantity for the ingredient sub-object\n\n        Returns\n        -------\n        List[Quantity]\n            list of quantities for the ingredient sub-object\n        \"\"\"\n        return self._json_attrs.quantity.copy()\n\n    @beartype\n    def set_material(self, new_material: Union[Material, UIDProxy], new_quantity: List[Union[Quantity, UIDProxy]]) -&gt; None:\n        \"\"\"\n        update ingredient sub-object with new material and new list of quantities\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"123456\")\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n        ... )\n        &gt;&gt;&gt; my_new_material = cript.Material(\n        ...     name=\"my material\", bigsmiles = \"78910\"\n        ... )\n        &gt;&gt;&gt; my_new_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient.set_material(new_material=my_new_material, new_quantity=[my_new_quantity])\n\n        Parameters\n        ----------\n        new_material : Material\n            new material node to replace the current\n        new_quantity : List[Quantity]\n            new list of quantity sub-objects to replace the current quantity subobject on this node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, material=new_material, quantity=new_quantity)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def keyword(self) -&gt; List[str]:\n        \"\"\"\n        ingredient keyword must come from the\n        [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/ingredient_keyword)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"123456\")\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n        ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n        ... )\n        &gt;&gt;&gt; my_ingredient.keyword = [\"computation\"]\n\n        Returns\n        -------\n        str\n            get the current ingredient keyword\n        \"\"\"\n        return self._json_attrs.keyword.copy()\n\n    @keyword.setter\n    @beartype\n    def keyword(self, new_keyword: List[str]) -&gt; None:\n        \"\"\"\n        set new ingredient keyword to replace the current\n\n        Parameters\n        ----------\n        new_keyword : str\n            new ingredient keyword\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, keyword=new_keyword)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient.__init__","title":"<code>__init__(material, quantity, keyword=None, **kwargs)</code>","text":"<p>create an ingredient sub-object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles=\"my bigsmiles\")\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient = cript.Ingredient(\n...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n... )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>Material</code> <p>material node</p> required <code>quantity</code> <code>List[Quantity]</code> <p>list of quantity sub-objects</p> required <code>keyword</code> <code>List[str]</code> <p>ingredient keyword must come from CRIPT Controlled Vocabulary, by default \"\"</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Create new Ingredient sub-object</p> Source code in <code>src/cript/nodes/subobjects/ingredient.py</code> <pre><code>@beartype\ndef __init__(self, material: Union[Material, UIDProxy], quantity: List[Union[Quantity, UIDProxy]], keyword: Optional[List[str]] = None, **kwargs):\n    \"\"\"\n    create an ingredient sub-object\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles=\"my bigsmiles\")\n    &gt;&gt;&gt; my_quantity = cript.Quantity(\n    ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n    ... )\n    &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n    ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n    ... )\n\n    Parameters\n    ----------\n    material : Material\n        material node\n    quantity : List[Quantity]\n        list of quantity sub-objects\n    keyword : List[str], optional\n        ingredient keyword must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/ingredient_keyword), by default \"\"\n\n    Returns\n    -------\n    None\n        Create new Ingredient sub-object\n    \"\"\"\n    super().__init__(**kwargs)\n    if keyword is None:\n        keyword = []\n    new_json_attrs = replace(self._json_attrs, material=material, quantity=quantity, keyword=keyword)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient.keyword","title":"<code>keyword(new_keyword)</code>","text":"<p>set new ingredient keyword to replace the current</p> <p>Parameters:</p> Name Type Description Default <code>new_keyword</code> <code>str</code> <p>new ingredient keyword</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/ingredient.py</code> <pre><code>@keyword.setter\n@beartype\ndef keyword(self, new_keyword: List[str]) -&gt; None:\n    \"\"\"\n    set new ingredient keyword to replace the current\n\n    Parameters\n    ----------\n    new_keyword : str\n        new ingredient keyword\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, keyword=new_keyword)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient.material","title":"<code>material()</code>","text":"<p>current material in this ingredient sub-object</p> <p>Returns:</p> Type Description <code>Material</code> <p>Material node within the ingredient sub-object</p> Source code in <code>src/cript/nodes/subobjects/ingredient.py</code> <pre><code>@property\n@beartype\ndef material(self) -&gt; Union[Material, None, UIDProxy]:\n    \"\"\"\n    current material in this ingredient sub-object\n\n    Returns\n    -------\n    Material\n        Material node within the ingredient sub-object\n    \"\"\"\n    return self._json_attrs.material\n</code></pre>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient.quantity","title":"<code>quantity()</code>","text":"<p>quantity for the ingredient sub-object</p> <p>Returns:</p> Type Description <code>List[Quantity]</code> <p>list of quantities for the ingredient sub-object</p> Source code in <code>src/cript/nodes/subobjects/ingredient.py</code> <pre><code>@property\n@beartype\ndef quantity(self) -&gt; List[Union[Quantity, UIDProxy]]:\n    \"\"\"\n    quantity for the ingredient sub-object\n\n    Returns\n    -------\n    List[Quantity]\n        list of quantities for the ingredient sub-object\n    \"\"\"\n    return self._json_attrs.quantity.copy()\n</code></pre>"},{"location":"nodes/subobjects/ingredient/#cript.nodes.subobjects.ingredient.Ingredient.set_material","title":"<code>set_material(new_material, new_quantity)</code>","text":"<p>update ingredient sub-object with new material and new list of quantities</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"123456\")\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient = cript.Ingredient(\n...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n... )\n&gt;&gt;&gt; my_new_material = cript.Material(\n...     name=\"my material\", bigsmiles = \"78910\"\n... )\n&gt;&gt;&gt; my_new_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_ingredient.set_material(new_material=my_new_material, new_quantity=[my_new_quantity])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>new_material</code> <code>Material</code> <p>new material node to replace the current</p> required <code>new_quantity</code> <code>List[Quantity]</code> <p>new list of quantity sub-objects to replace the current quantity subobject on this node</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/ingredient.py</code> <pre><code>@beartype\ndef set_material(self, new_material: Union[Material, UIDProxy], new_quantity: List[Union[Quantity, UIDProxy]]) -&gt; None:\n    \"\"\"\n    update ingredient sub-object with new material and new list of quantities\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"123456\")\n    &gt;&gt;&gt; my_quantity = cript.Quantity(\n    ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n    ... )\n    &gt;&gt;&gt; my_ingredient = cript.Ingredient(\n    ...     material=my_material, quantity=[my_quantity], keyword=[\"catalyst\"]\n    ... )\n    &gt;&gt;&gt; my_new_material = cript.Material(\n    ...     name=\"my material\", bigsmiles = \"78910\"\n    ... )\n    &gt;&gt;&gt; my_new_quantity = cript.Quantity(\n    ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n    ... )\n    &gt;&gt;&gt; my_ingredient.set_material(new_material=my_new_material, new_quantity=[my_new_quantity])\n\n    Parameters\n    ----------\n    new_material : Material\n        new material node to replace the current\n    new_quantity : List[Quantity]\n        new list of quantity sub-objects to replace the current quantity subobject on this node\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, material=new_material, quantity=new_quantity)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/parameter/","title":"Parameter","text":""},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter--definition","title":"Definition","text":"<p>A parameter is an input value to an algorithm.</p> Difference between <code>Parameter</code> and <code>Condition</code> <p>For typical computations, the difference between parameter and condition lies in whether it changes the thermodynamic state of the simulated system: Variables that are part of defining a thermodynamic state should be defined as a condition in a parent node.</p> <p>Therefore, <code>number</code> and <code>volume</code> need to be listed as conditions while <code>boundaries</code> and <code>origin</code> are parameters of ensemble size</p>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>Algorithm sub-object</li> </ul>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter--available-sub-objects","title":"Available sub-objects:","text":"<ul> <li>None</li> </ul>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter--attributes","title":"Attributes","text":"attribute type example description required vocab key str key for identifier True True value Any value True unit str unit for parameter"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"key\":\"update_frequency\",\n   \"node\":[\"Parameter\"],\n   \"unit\":\"1/second\",\n   \"value\":1000.0\n   \"uid\":\"_:6af3b3aa-1dbc-4ce7-be8b-1896b375001c\",\n   \"uuid\":\"6af3b3aa-1dbc-4ce7-be8b-1896b375001c\",\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/parameter.py</code> <pre><code>class Parameter(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n\n    A [parameter](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=25)\n    is an input value to an algorithm.\n\n    ??? note \"Difference between `Parameter` and `Condition`\"\n        For typical computations, the difference between\n        parameter and condition lies in whether it changes the thermodynamic state of the simulated\n        system: Variables that are part of defining a thermodynamic state should be defined as a condition\n        in a parent node.\n\n        Therefore, `number` and `volume` need to be listed as conditions while\n        `boundaries` and `origin` are parameters of ensemble size\n\n    ---\n    ## Can Be Added To:\n    * [Algorithm sub-object](../algorithm)\n\n    ## Available sub-objects:\n    * None\n\n    ---\n\n    ## Attributes\n\n    | attribute | type | example | description        | required | vocab |\n    |-----------|------|---------|--------------------|----------|-------|\n    | key       | str  |         | key for identifier | True     | True  |\n    | value     | Any  |         | value              | True     |       |\n    | unit      | str  |         | unit for parameter |          |       |\n\n\n    ## JSON Representation\n    ```json\n    {\n       \"key\":\"update_frequency\",\n       \"node\":[\"Parameter\"],\n       \"unit\":\"1/second\",\n       \"value\":1000.0\n       \"uid\":\"_:6af3b3aa-1dbc-4ce7-be8b-1896b375001c\",\n       \"uuid\":\"6af3b3aa-1dbc-4ce7-be8b-1896b375001c\",\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        value: Optional[Number] = None\n        # We explicitly allow None for unit here (instead of empty str),\n        # this presents number without physical unit, like counting\n        # particles or dimensionless numbers.\n        unit: Union[str, None] = None\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    # Note that the key word args are ignored.\n    # They are just here, such that we can feed more kwargs in that we get from the back end.\n    @beartype\n    def __init__(self, key: str, value: Number, unit: Optional[str] = None, **kwargs):\n        \"\"\"\n        create new Parameter sub-object\n\n        Parameters\n        ----------\n        key : str\n            Parameter key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/parameter_key)\n        value : Union[int, float]\n            Parameter value\n        unit : Union[str, None], optional\n            Parameter unit, by default None\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n\n        Returns\n        -------\n        None\n            create Parameter sub-object\n        \"\"\"\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, key=key, value=value, unit=unit)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @classmethod\n    def _from_json(cls, json_dict: dict):\n        # TODO: remove this temporary fix, once back end is working correctly\n        try:\n            json_dict[\"value\"] = float(json_dict[\"value\"])\n        except KeyError:\n            pass\n        return super(Parameter, cls)._from_json(json_dict)\n\n    @property\n    @beartype\n    def key(self) -&gt; str:\n        \"\"\"\n        Parameter key must come from the [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/parameter_key)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n        &gt;&gt;&gt; my_parameter.key = \"damping_time\"\n\n        Returns\n        -------\n        str\n            parameter key\n        \"\"\"\n        return self._json_attrs.key\n\n    @key.setter\n    @beartype\n    def key(self, new_key: str) -&gt; None:\n        \"\"\"\n        set new key for the Parameter sub-object\n\n        Parameters\n        ----------\n        new_key : str\n            new Parameter key\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def value(self) -&gt; Optional[Number]:\n        \"\"\"\n        Parameter value\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n        &gt;&gt;&gt; my_parameter.value = 1\n\n        Returns\n        -------\n        Union[int, float, str]\n            parameter value\n        \"\"\"\n        return self._json_attrs.value\n\n    @value.setter\n    @beartype\n    def value(self, new_value: Number) -&gt; None:\n        \"\"\"\n        set the Parameter value\n\n        Parameters\n        ----------\n        new_value : Union[int, float, str]\n            new parameter value\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, value=new_value)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def unit(self) -&gt; Union[str, None]:\n        \"\"\"\n        Parameter unit\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n        &gt;&gt;&gt; my_parameter.unit = \"gram\"\n\n        Returns\n        -------\n        str\n            parameter unit\n        \"\"\"\n        return self._json_attrs.unit\n\n    @unit.setter\n    @beartype\n    def unit(self, new_unit: str) -&gt; None:\n        \"\"\"\n        set the unit attribute for the Parameter sub-object\n\n        Parameters\n        ----------\n        new_unit : str\n            new Parameter unit\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, unit=new_unit)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter.key","title":"<code>key: str</code>  <code>property</code> <code>writable</code>","text":"<p>Parameter key must come from the CRIPT Controlled Vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n&gt;&gt;&gt; my_parameter.key = \"damping_time\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>parameter key</p>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter.unit","title":"<code>unit: Union[str, None]</code>  <code>property</code> <code>writable</code>","text":"<p>Parameter unit</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n&gt;&gt;&gt; my_parameter.unit = \"gram\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>parameter unit</p>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter.value","title":"<code>value: Optional[Number]</code>  <code>property</code> <code>writable</code>","text":"<p>Parameter value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n&gt;&gt;&gt; my_parameter.value = 1\n</code></pre> <p>Returns:</p> Type Description <code>Union[int, float, str]</code> <p>parameter value</p>"},{"location":"nodes/subobjects/parameter/#cript.nodes.subobjects.parameter.Parameter.__init__","title":"<code>__init__(key, value, unit=None, **kwargs)</code>","text":"<p>create new Parameter sub-object</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Parameter key must come from CRIPT Controlled Vocabulary</p> required <code>value</code> <code>Union[int, float]</code> <p>Parameter value</p> required <code>unit</code> <code>Union[str, None]</code> <p>Parameter unit, by default None</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>create Parameter sub-object</p> Source code in <code>src/cript/nodes/subobjects/parameter.py</code> <pre><code>@beartype\ndef __init__(self, key: str, value: Number, unit: Optional[str] = None, **kwargs):\n    \"\"\"\n    create new Parameter sub-object\n\n    Parameters\n    ----------\n    key : str\n        Parameter key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/parameter_key)\n    value : Union[int, float]\n        Parameter value\n    unit : Union[str, None], optional\n        Parameter unit, by default None\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_parameter = cript.Parameter(\"update_frequency\", 1000.0, \"1/second\")\n\n    Returns\n    -------\n    None\n        create Parameter sub-object\n    \"\"\"\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, key=key, value=value, unit=unit)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/property/","title":"Property","text":""},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property","title":"<code>Property</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property--definition","title":"Definition","text":"<p>Property sub-objects are qualities/traits of a material or Process</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>Material</li> <li>Process</li> <li>Computation_Process</li> </ul>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property--available-sub-objects","title":"Available sub-objects:","text":"<ul> <li>Condition</li> <li>Citation</li> </ul>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property--attributes","title":"Attributes","text":"attribute type example description required vocab key str enthalpy type of property True True type str min type of value stored True True value Any 1.23 value or quantity True unit str gram unit for value True uncertainty Number 0.1 uncertainty of value uncertainty_type str standard_deviation type of uncertainty True component list[Material] material that the property relates to** structure str {[][$][C:1][C:1][$] specific chemical structure associate with the property with atom mappings** method str sec approach or source of property data True sample_preparation Process sample preparation condition list[Condition] conditions under which the property was measured data Data data node computation list[Computation] computation method that produced property citation list[Citation] reference to a book, paper, or scholarly work notes str miscellaneous information, or custom data structure (e.g.; JSON)"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"key\":\"enthalpy\",\n   \"node\":[\"Property\"],\n   \"type\":\"value\",\n   \"unit\":\"J\",\n   \"value\":5.0\n   \"uid\":\"_:bc3abb68-25b5-4144-aa1b-85d82b7c77e1\",\n   \"uuid\":\"bc3abb68-25b5-4144-aa1b-85d82b7c77e1\",\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/property.py</code> <pre><code>class Property(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n    [Property](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=18)\n    sub-objects are qualities/traits of a [material](../../primary_nodes/material) or\n    [Process](../../primary_nodes/process)\n\n    ---\n\n    ## Can Be Added To:\n    * [Material](../../primary_nodes/material)\n    * [Process](../../primary_nodes/process)\n    * [Computation_Process](../../primary_nodes/computation_process)\n\n    ## Available sub-objects:\n    * [Condition](../condition)\n    * [Citation](../citation)\n\n    ---\n\n    ## Attributes\n\n    | attribute          | type              | example                                 | description                                                                  | required | vocab |\n    |--------------------|-------------------|-----------------------------------------|------------------------------------------------------------------------------|----------|-------|\n    | key                | str               | enthalpy                                | type of property                                                             | True     | True  |\n    | type               | str               | min                                     | type of value stored                                                         | True     | True  |\n    | value              | Any               | 1.23                                    | value or quantity                                                            | True     |       |\n    | unit               | str               | gram                                    | unit for value                                                               | True     |       |\n    | uncertainty        | Number            | 0.1                                     | uncertainty of value                                                         |          |       |\n    | uncertainty_type   | str               | standard_deviation                      | type of uncertainty                                                          |          | True  |\n    | component          | list[Material]    |                                         | material that the property relates to**                                      |          |       |\n    | structure          | str               | {\\\\[\\\\]\\\\[$\\\\]\\\\[C:1\\\\]\\\\[C:1\\\\]\\\\[$\\\\] | specific chemical structure associate with the property with atom mappings** |          |       |\n    | method             | str               | sec                                     | approach or source of property data                                          |          | True  |\n    | sample_preparation | Process           |                                         | sample preparation                                                           |          |       |\n    | condition          | list[Condition]   |                                         | conditions under which the property was measured                             |          |       |\n    | data               | Data              |                                         | data node                                                                    |          |       |\n    | computation        | list[Computation] |                                         | computation method that produced property                                    |          |       |\n    | citation           | list[Citation]    |                                         | reference to a book, paper, or scholarly work                                |          |       |\n    | notes              | str               |                                         | miscellaneous information, or custom data structure (e.g.; JSON)             |          |       |\n\n\n    ## JSON Representation\n    ```json\n    {\n       \"key\":\"enthalpy\",\n       \"node\":[\"Property\"],\n       \"type\":\"value\",\n       \"unit\":\"J\",\n       \"value\":5.0\n       \"uid\":\"_:bc3abb68-25b5-4144-aa1b-85d82b7c77e1\",\n       \"uuid\":\"bc3abb68-25b5-4144-aa1b-85d82b7c77e1\",\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        type: str = \"\"\n        value: Union[Number, str, None] = None\n        unit: Optional[str] = \"\"\n        uncertainty: Optional[Number] = None\n        uncertainty_type: str = \"\"\n        component: List[Union[Material, UIDProxy]] = field(default_factory=list)\n        structure: str = \"\"\n        method: str = \"\"\n        sample_preparation: Optional[Union[Process, UIDProxy]] = None\n        condition: List[Union[Condition, UIDProxy]] = field(default_factory=list)\n        data: List[Union[Data, UIDProxy]] = field(default_factory=list)\n        computation: List[Union[Computation, UIDProxy]] = field(default_factory=list)\n        citation: List[Union[Citation, UIDProxy]] = field(default_factory=list)\n        notes: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(\n        self,\n        key: str,\n        type: str,\n        value: Union[Number, str, None],\n        unit: Union[str, None],\n        uncertainty: Optional[Number] = None,\n        uncertainty_type: str = \"\",\n        component: Optional[List[Union[Material, UIDProxy]]] = None,\n        structure: str = \"\",\n        method: str = \"\",\n        sample_preparation: Optional[Union[Process, UIDProxy]] = None,\n        condition: Optional[List[Union[Condition, UIDProxy]]] = None,\n        data: Optional[List[Union[Data, UIDProxy]]] = None,\n        computation: Optional[List[Union[Computation, UIDProxy]]] = None,\n        citation: Optional[List[Union[Citation, UIDProxy]]] = None,\n        notes: str = \"\",\n        **kwargs\n    ):\n        \"\"\"\n        create a property sub-object\n\n        Parameters\n        ----------\n        key : str\n            type of property, Property key must come from the CRIPT Controlled Vocabulary\n        type : str\n            type of value stored, Property type must come from the CRIPT Controlled Vocabulary\n        value : Union[Number, None]\n            value or quantity\n        unit : str\n            unit for value\n        uncertainty : Union[Number, None], optional\n            uncertainty value of the value, by default None\n        uncertainty_type : str, optional\n            type of uncertainty, by default \"\"\n        component : Union[List[Material], None], optional\n            List of Material nodes, by default None\n        structure : str, optional\n            specific chemical structure associate with the property with atom mappings**, by default \"\"\n        method : str, optional\n            approach or source of property data, by default \"\"\n        sample_preparation : Union[Process, None], optional\n            sample preparation, by default None\n        condition : Union[List[Condition], None], optional\n            conditions under which the property was measured, by default None\n        data : Union[List[Data], None], optional\n            Data node, by default None\n        computation : Union[List[Computation], None], optional\n            computation method that produced property, by default None\n        citation : Union[List[Citation], None], optional\n            reference scholarly work, by default None\n        notes : str, optional\n            miscellaneous information, or custom data structure (e.g.; JSON), by default \"\"\n\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n\n        Returns\n        -------\n        None\n            create a Property sub-object\n        \"\"\"\n        if component is None:\n            component = []\n        if condition is None:\n            condition = []\n        if computation is None:\n            computation = []\n        if data is None:\n            data = []\n        if citation is None:\n            citation = []\n\n        super().__init__(**kwargs)\n        new_json_attrs = replace(\n            self._json_attrs,\n            key=key,\n            type=type,\n            value=value,\n            unit=unit,\n            uncertainty=uncertainty,\n            uncertainty_type=uncertainty_type,\n            component=component,\n            structure=structure,\n            method=method,\n            sample_preparation=sample_preparation,\n            condition=condition,\n            data=data,\n            computation=computation,\n            citation=citation,\n            notes=notes,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def key(self) -&gt; str:\n        \"\"\"\n        Property key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.key = \"angle_rdist\"\n\n        Returns\n        -------\n        str\n            Property Key\n        \"\"\"\n        return self._json_attrs.key\n\n    @key.setter\n    @beartype\n    def key(self, new_key: str) -&gt; None:\n        \"\"\"\n        set the key for this Property sub-object\n\n        Parameters\n        ----------\n        new_key : str\n            new Property key\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        type of value for this Property sub-object\n\n        [property type](https://app.criptapp.org/vocab/) must come from CRIPT controlled vocabulary\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.type = \"max\"\n\n        Returns\n        -------\n        str\n            type of value for this Property sub-object\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_type: str) -&gt; None:\n        \"\"\"\n        set the Property type for this subobject\n\n        Parameters\n        ----------\n        new_type : str\n            new Property type\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, type=new_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def value(self) -&gt; Union[Number, str, None]:\n        \"\"\"\n        get the Property value\n\n        Returns\n        -------\n        Union[Number, None]\n            Property value\n        \"\"\"\n        return self._json_attrs.value\n\n    @beartype\n    def set_value(self, new_value: Union[Number, str, None], new_unit: str) -&gt; None:\n        \"\"\"\n        set the value attribute of the Property subobject\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.set_value(new_value=1, new_unit=\"gram\")\n\n        Parameters\n        ----------\n        new_value : Number\n            new value\n        new_unit : str\n            new unit for the value\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, value=new_value, unit=new_unit)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def unit(self) -&gt; Optional[str]:\n        \"\"\"\n        get the Property unit for the value\n\n        Returns\n        -------\n        str\n            unit\n        \"\"\"\n        return self._json_attrs.unit\n\n    @property\n    @beartype\n    def uncertainty(self) -&gt; Union[Number, None]:\n        \"\"\"\n        get the uncertainty value of the Property node\n\n        Returns\n        -------\n        Union[Number, None]\n            uncertainty value\n        \"\"\"\n        return self._json_attrs.uncertainty\n\n    @beartype\n    def set_uncertainty(self, new_uncertainty: Optional[Number], new_uncertainty_type: str) -&gt; None:\n        \"\"\"\n        set the uncertainty value and type\n\n        Uncertainty type must come from [CRIPT Controlled Vocabulary]\n\n        Parameters\n        ----------\n        new_uncertainty : Number\n            new uncertainty value\n        new_uncertainty_type : str\n            new uncertainty type\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.set_uncertainty(new_uncertainty=2, new_uncertainty_type=\"fwhm\")\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, uncertainty=new_uncertainty, uncertainty_type=new_uncertainty_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def uncertainty_type(self) -&gt; str:\n        \"\"\"\n        get the uncertainty_type for this Property subobject\n\n        [Uncertainty type](https://app.criptapp.org/vocab/uncertainty_type)\n        must come from CRIPT Controlled Vocabulary\n\n        Returns\n        -------\n        str\n            Uncertainty type\n        \"\"\"\n        return self._json_attrs.uncertainty_type\n\n    @property\n    @beartype\n    def component(self) -&gt; List[Union[Material, UIDProxy]]:\n        \"\"\"\n        list of Materials that the Property relates to\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"123456\")\n        &gt;&gt;&gt; my_property.component = [my_material]\n\n        Returns\n        -------\n        List[Material]\n            list of Materials that the Property relates to\n        \"\"\"\n        return self._json_attrs.component.copy()\n\n    @component.setter\n    @beartype\n    def component(self, new_component: List[Union[Material, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of Materials as components for the Property subobject\n\n        Parameters\n        ----------\n        new_component : List[Material]\n            new list of Materials to for the Property subobject\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, component=new_component)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def structure(self) -&gt; str:\n        \"\"\"\n        specific chemical structure associate with the property with atom mappings\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.structure = \"{[][$][C:1][C:1][$],[$][C:2][C:2]([C:2])[$][]}\"\n\n        Returns\n        -------\n        str\n            Property structure string\n        \"\"\"\n        return self._json_attrs.structure\n\n    @structure.setter\n    @beartype\n    def structure(self, new_structure: str) -&gt; None:\n        \"\"\"\n        set the this Property's structure\n\n        Parameters\n        ----------\n        new_structure : str\n            new structure\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, structure=new_structure)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def method(self) -&gt; str:\n        \"\"\"\n        approach or source of property data True sample_preparation Process sample preparation\n\n        [Property method](https://app.criptapp.org/vocab/property_method) must come from CRIPT Controlled Vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.method = \"ASTM_D3574_Test_A\"\n\n        Returns\n        -------\n        str\n            Property method\n        \"\"\"\n        return self._json_attrs.method\n\n    @method.setter\n    @beartype\n    def method(self, new_method: str) -&gt; None:\n        \"\"\"\n        set the Property method\n\n        Parameters\n        ----------\n        new_method : str\n            new Property method\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, method=new_method)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def sample_preparation(self) -&gt; Union[Process, None, UIDProxy]:\n        \"\"\"\n        sample_preparation\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n        &gt;&gt;&gt; my_property.sample_preparation = my_process\n\n        Returns\n        -------\n        Union[Process, None]\n            Property linking back to the Process that has it as subobject\n        \"\"\"\n        return self._json_attrs.sample_preparation\n\n    @sample_preparation.setter\n    @beartype\n    def sample_preparation(self, new_sample_preparation: Union[Process, None, UIDProxy]) -&gt; None:\n        \"\"\"\n        set the sample_preparation for the Property subobject\n\n        Parameters\n        ----------\n        new_sample_preparation : Union[Process, None]\n            back link to the Process that has this Property as its subobject\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, sample_preparation=new_sample_preparation)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def condition(self) -&gt; List[Union[Condition, UIDProxy]]:\n        \"\"\"\n        list of Conditions under which the property was measured\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"max\", value=1)\n        &gt;&gt;&gt; my_property.condition = [my_condition]\n\n        Returns\n        -------\n        List[Condition]\n            list of Conditions\n        \"\"\"\n        return self._json_attrs.condition.copy()\n\n    @condition.setter\n    @beartype\n    def condition(self, new_condition: List[Union[Condition, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of Conditions for this property subobject\n\n        Parameters\n        ----------\n        new_condition : List[Condition]\n            new list of Condition Subobjects\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, condition=new_condition)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def data(self) -&gt; List[Union[Data, UIDProxy]]:\n        \"\"\"\n        List of Data nodes for this Property subobjects\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\",\n        ... )\n        &gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n        &gt;&gt;&gt; my_property.data = [my_data]\n\n        Returns\n        -------\n        List[Data]\n            list of Data nodes\n        \"\"\"\n        return self._json_attrs.data.copy()\n\n    @data.setter\n    @beartype\n    def data(self, new_data: List[Union[Data, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the Data node for the Property subobject\n\n        Parameters\n        ----------\n        new_data : List[Data]\n            new list of Data nodes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, data=new_data)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def computation(self) -&gt; List[Union[Computation, UIDProxy]]:\n        \"\"\"\n        list of Computation nodes that produced this property\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n        &gt;&gt;&gt; my_property.computation = [my_computation]\n\n        Returns\n        -------\n        List[Computation]\n            list of Computation nodes\n        \"\"\"\n        return self._json_attrs.computation.copy()\n\n    @computation.setter\n    @beartype\n    def computation(self, new_computation: List[Union[Computation, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of Computation nodes that produced this property\n\n        Parameters\n        ----------\n        new_computation : List[Computation]\n            new list of Computation nodes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, computation=new_computation)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Union[Citation, UIDProxy]]:\n        \"\"\"\n        list of Citation subobjects for this Property subobject\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n        &gt;&gt;&gt; my_property.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of Citation subobjects for this Property subobject\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of Citation subobjects for the Property subobject\n\n        Parameters\n        ----------\n        new_citation : List[Citation]\n            new list of Citation subobjects\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def notes(self) -&gt; str:\n        \"\"\"\n        notes for this Property subobject\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n        &gt;&gt;&gt; my_property.notes = \"these are my notes\"\n\n        Returns\n        -------\n        str\n            notes for this property subobject\n        \"\"\"\n        return self._json_attrs.notes\n\n    @notes.setter\n    @beartype\n    def notes(self, new_notes: str) -&gt; None:\n        \"\"\"\n        set the notes for this Property sub-object\n\n        Parameters\n        ----------\n        new_notes : str\n            new notes\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, notes=new_notes)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.citation","title":"<code>citation: List[Union[Citation, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Citation subobjects for this Property subobject</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; title = (\n...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n... )\n&gt;&gt;&gt; my_reference = cript.Reference(\n...     type=\"journal_article\",\n...     title=title,\n...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n...     journal=\"Computer Physics Communications\",\n...     publisher=\"Elsevier\",\n...     year=2019,\n...     pages=[463, 476],\n...     doi=\"10.1016/j.cpc.2018.08.011\",\n...     issn=\"0010-4655\",\n...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n... )\n&gt;&gt;&gt; my_citation = cript.Citation(type=\"reference\", reference=my_reference)\n&gt;&gt;&gt; my_property.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of Citation subobjects for this Property subobject</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.component","title":"<code>component: List[Union[Material, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Materials that the Property relates to</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_material = cript.Material(name=\"my material\", bigsmiles = \"123456\")\n&gt;&gt;&gt; my_property.component = [my_material]\n</code></pre> <p>Returns:</p> Type Description <code>List[Material]</code> <p>list of Materials that the Property relates to</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.computation","title":"<code>computation: List[Union[Computation, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Computation nodes that produced this property</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_computation = cript.Computation(name=\"my computation name\", type=\"analysis\")\n&gt;&gt;&gt; my_property.computation = [my_computation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Computation]</code> <p>list of Computation nodes</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.condition","title":"<code>condition: List[Union[Condition, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Conditions under which the property was measured</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_condition = cript.Condition(key=\"atm\", type=\"max\", value=1)\n&gt;&gt;&gt; my_property.condition = [my_condition]\n</code></pre> <p>Returns:</p> Type Description <code>List[Condition]</code> <p>list of Conditions</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.data","title":"<code>data: List[Union[Data, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>List of Data nodes for this Property subobjects</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\",\n... )\n&gt;&gt;&gt; my_data = cript.Data(name=\"my data name\", type=\"afm_amp\", file=[my_file])\n&gt;&gt;&gt; my_property.data = [my_data]\n</code></pre> <p>Returns:</p> Type Description <code>List[Data]</code> <p>list of Data nodes</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.key","title":"<code>key: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property key must come from CRIPT Controlled Vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.key = \"angle_rdist\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Property Key</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.method","title":"<code>method: str</code>  <code>property</code> <code>writable</code>","text":"<p>approach or source of property data True sample_preparation Process sample preparation</p> <p>Property method must come from CRIPT Controlled Vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.method = \"ASTM_D3574_Test_A\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Property method</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.notes","title":"<code>notes: str</code>  <code>property</code> <code>writable</code>","text":"<p>notes for this Property subobject</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.notes = \"these are my notes\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>notes for this property subobject</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.sample_preparation","title":"<code>sample_preparation: Union[Process, None, UIDProxy]</code>  <code>property</code> <code>writable</code>","text":"<p>sample_preparation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_process = cript.Process(name=\"my process name\", type=\"affinity_pure\")\n&gt;&gt;&gt; my_property.sample_preparation = my_process\n</code></pre> <p>Returns:</p> Type Description <code>Union[Process, None]</code> <p>Property linking back to the Process that has it as subobject</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.structure","title":"<code>structure: str</code>  <code>property</code> <code>writable</code>","text":"<p>specific chemical structure associate with the property with atom mappings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.structure = \"{[][$][C:1][C:1][$],[$][C:2][C:2]([C:2])[$][]}\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Property structure string</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>type of value for this Property sub-object</p> <p>property type must come from CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.type = \"max\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>type of value for this Property sub-object</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.uncertainty","title":"<code>uncertainty: Union[Number, None]</code>  <code>property</code>","text":"<p>get the uncertainty value of the Property node</p> <p>Returns:</p> Type Description <code>Union[Number, None]</code> <p>uncertainty value</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.uncertainty_type","title":"<code>uncertainty_type: str</code>  <code>property</code>","text":"<p>get the uncertainty_type for this Property subobject</p> <p>Uncertainty type must come from CRIPT Controlled Vocabulary</p> <p>Returns:</p> Type Description <code>str</code> <p>Uncertainty type</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.unit","title":"<code>unit: Optional[str]</code>  <code>property</code>","text":"<p>get the Property unit for the value</p> <p>Returns:</p> Type Description <code>str</code> <p>unit</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.value","title":"<code>value: Union[Number, str, None]</code>  <code>property</code>","text":"<p>get the Property value</p> <p>Returns:</p> Type Description <code>Union[Number, None]</code> <p>Property value</p>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.__init__","title":"<code>__init__(key, type, value, unit, uncertainty=None, uncertainty_type='', component=None, structure='', method='', sample_preparation=None, condition=None, data=None, computation=None, citation=None, notes='', **kwargs)</code>","text":"<p>create a property sub-object</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>type of property, Property key must come from the CRIPT Controlled Vocabulary</p> required <code>type</code> <code>str</code> <p>type of value stored, Property type must come from the CRIPT Controlled Vocabulary</p> required <code>value</code> <code>Union[Number, None]</code> <p>value or quantity</p> required <code>unit</code> <code>str</code> <p>unit for value</p> required <code>uncertainty</code> <code>Union[Number, None]</code> <p>uncertainty value of the value, by default None</p> <code>None</code> <code>uncertainty_type</code> <code>str</code> <p>type of uncertainty, by default \"\"</p> <code>''</code> <code>component</code> <code>Union[List[Material], None]</code> <p>List of Material nodes, by default None</p> <code>None</code> <code>structure</code> <code>str</code> <p>specific chemical structure associate with the property with atom mappings**, by default \"\"</p> <code>''</code> <code>method</code> <code>str</code> <p>approach or source of property data, by default \"\"</p> <code>''</code> <code>sample_preparation</code> <code>Union[Process, None]</code> <p>sample preparation, by default None</p> <code>None</code> <code>condition</code> <code>Union[List[Condition], None]</code> <p>conditions under which the property was measured, by default None</p> <code>None</code> <code>data</code> <code>Union[List[Data], None]</code> <p>Data node, by default None</p> <code>None</code> <code>computation</code> <code>Union[List[Computation], None]</code> <p>computation method that produced property, by default None</p> <code>None</code> <code>citation</code> <code>Union[List[Citation], None]</code> <p>reference scholarly work, by default None</p> <code>None</code> <code>notes</code> <code>str</code> <p>miscellaneous information, or custom data structure (e.g.; JSON), by default \"\"</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>create a Property sub-object</p> Source code in <code>src/cript/nodes/subobjects/property.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    key: str,\n    type: str,\n    value: Union[Number, str, None],\n    unit: Union[str, None],\n    uncertainty: Optional[Number] = None,\n    uncertainty_type: str = \"\",\n    component: Optional[List[Union[Material, UIDProxy]]] = None,\n    structure: str = \"\",\n    method: str = \"\",\n    sample_preparation: Optional[Union[Process, UIDProxy]] = None,\n    condition: Optional[List[Union[Condition, UIDProxy]]] = None,\n    data: Optional[List[Union[Data, UIDProxy]]] = None,\n    computation: Optional[List[Union[Computation, UIDProxy]]] = None,\n    citation: Optional[List[Union[Citation, UIDProxy]]] = None,\n    notes: str = \"\",\n    **kwargs\n):\n    \"\"\"\n    create a property sub-object\n\n    Parameters\n    ----------\n    key : str\n        type of property, Property key must come from the CRIPT Controlled Vocabulary\n    type : str\n        type of value stored, Property type must come from the CRIPT Controlled Vocabulary\n    value : Union[Number, None]\n        value or quantity\n    unit : str\n        unit for value\n    uncertainty : Union[Number, None], optional\n        uncertainty value of the value, by default None\n    uncertainty_type : str, optional\n        type of uncertainty, by default \"\"\n    component : Union[List[Material], None], optional\n        List of Material nodes, by default None\n    structure : str, optional\n        specific chemical structure associate with the property with atom mappings**, by default \"\"\n    method : str, optional\n        approach or source of property data, by default \"\"\n    sample_preparation : Union[Process, None], optional\n        sample preparation, by default None\n    condition : Union[List[Condition], None], optional\n        conditions under which the property was measured, by default None\n    data : Union[List[Data], None], optional\n        Data node, by default None\n    computation : Union[List[Computation], None], optional\n        computation method that produced property, by default None\n    citation : Union[List[Citation], None], optional\n        reference scholarly work, by default None\n    notes : str, optional\n        miscellaneous information, or custom data structure (e.g.; JSON), by default \"\"\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n\n    Returns\n    -------\n    None\n        create a Property sub-object\n    \"\"\"\n    if component is None:\n        component = []\n    if condition is None:\n        condition = []\n    if computation is None:\n        computation = []\n    if data is None:\n        data = []\n    if citation is None:\n        citation = []\n\n    super().__init__(**kwargs)\n    new_json_attrs = replace(\n        self._json_attrs,\n        key=key,\n        type=type,\n        value=value,\n        unit=unit,\n        uncertainty=uncertainty,\n        uncertainty_type=uncertainty_type,\n        component=component,\n        structure=structure,\n        method=method,\n        sample_preparation=sample_preparation,\n        condition=condition,\n        data=data,\n        computation=computation,\n        citation=citation,\n        notes=notes,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.set_uncertainty","title":"<code>set_uncertainty(new_uncertainty, new_uncertainty_type)</code>","text":"<p>set the uncertainty value and type</p> <p>Uncertainty type must come from [CRIPT Controlled Vocabulary]</p> <p>Parameters:</p> Name Type Description Default <code>new_uncertainty</code> <code>Number</code> <p>new uncertainty value</p> required <code>new_uncertainty_type</code> <code>str</code> <p>new uncertainty type</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.set_uncertainty(new_uncertainty=2, new_uncertainty_type=\"fwhm\")\n</code></pre> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/property.py</code> <pre><code>@beartype\ndef set_uncertainty(self, new_uncertainty: Optional[Number], new_uncertainty_type: str) -&gt; None:\n    \"\"\"\n    set the uncertainty value and type\n\n    Uncertainty type must come from [CRIPT Controlled Vocabulary]\n\n    Parameters\n    ----------\n    new_uncertainty : Number\n        new uncertainty value\n    new_uncertainty_type : str\n        new uncertainty type\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n    &gt;&gt;&gt; my_property.set_uncertainty(new_uncertainty=2, new_uncertainty_type=\"fwhm\")\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, uncertainty=new_uncertainty, uncertainty_type=new_uncertainty_type)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/property/#cript.nodes.subobjects.property.Property.set_value","title":"<code>set_value(new_value, new_unit)</code>","text":"<p>set the value attribute of the Property subobject</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n&gt;&gt;&gt; my_property.set_value(new_value=1, new_unit=\"gram\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>Number</code> <p>new value</p> required <code>new_unit</code> <code>str</code> <p>new unit for the value</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/property.py</code> <pre><code>@beartype\ndef set_value(self, new_value: Union[Number, str, None], new_unit: str) -&gt; None:\n    \"\"\"\n    set the value attribute of the Property subobject\n\n    Examples\n    ---------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_property = cript.Property(key=\"enthalpy\", type=\"min\", value=1.00, unit=\"J\")\n    &gt;&gt;&gt; my_property.set_value(new_value=1, new_unit=\"gram\")\n\n    Parameters\n    ----------\n    new_value : Number\n        new value\n    new_unit : str\n        new unit for the value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, value=new_value, unit=new_unit)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/quantity/","title":"Quantity","text":""},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity","title":"<code>Quantity</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity--definition","title":"Definition","text":"<p>The Quantity sub-objects are the amount of material involved in a process</p>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>Ingredient</li> </ul>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity--available-sub-objects","title":"Available sub-objects","text":"<ul> <li>None</li> </ul>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity--attributes","title":"Attributes","text":"attribute type example description required vocab key str mass type of quantity True True value Any 1.23 amount of material True unit str gram unit for quantity True uncertainty Number 0.1 uncertainty of value uncertainty_type str std type of uncertainty True"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity--json-representation","title":"JSON Representation","text":"<pre><code>{\n \"node\":[\"Quantity\"],\n \"key\":\"mass\",\n \"value\":11.2\n \"uncertainty\":0.2,\n \"uncertainty_type\":\"stdev\",\n \"unit\":\"kg\",\n \"uid\":\"_:c95ee781-923b-4699-ba3b-923ce186ac5d\",\n \"uuid\":\"c95ee781-923b-4699-ba3b-923ce186ac5d\",\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>class Quantity(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n    The [Quantity](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=22)\n    sub-objects are the amount of material involved in a process\n\n    ---\n\n    ## Can Be Added To:\n    * [Ingredient](../ingredient)\n\n    ## Available sub-objects\n    * None\n\n    ----\n\n    ## Attributes\n\n    | attribute        | type    | example | description          | required | vocab |\n    |------------------|---------|---------|----------------------|----------|-------|\n    | key              | str     | mass    | type of quantity     | True     | True  |\n    | value            | Any     | 1.23    | amount of material   | True     |       |\n    | unit             | str     | gram    | unit for quantity    | True     |       |\n    | uncertainty      | Number  | 0.1     | uncertainty of value |          |       |\n    | uncertainty_type | str     | std     | type of uncertainty  |          | True  |\n\n\n\n\n    ## JSON Representation\n    ```json\n    {\n     \"node\":[\"Quantity\"],\n     \"key\":\"mass\",\n     \"value\":11.2\n     \"uncertainty\":0.2,\n     \"uncertainty_type\":\"stdev\",\n     \"unit\":\"kg\",\n     \"uid\":\"_:c95ee781-923b-4699-ba3b-923ce186ac5d\",\n     \"uuid\":\"c95ee781-923b-4699-ba3b-923ce186ac5d\",\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        key: str = \"\"\n        value: Union[Number, str, None] = None\n        unit: str = \"\"\n        uncertainty: Optional[Number] = None\n        uncertainty_type: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, key: str, value: Number, unit: str, uncertainty: Optional[Number] = None, uncertainty_type: str = \"\", **kwargs):\n        \"\"\"\n        create Quantity sub-object\n\n        Parameters\n        ----------\n        key : str\n            type of quantity. Quantity key must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/quantity_key)\n        value : Number\n            amount of material\n        unit : str\n            unit for quantity\n        uncertainty : Union[Number, None], optional\n            uncertainty of value, by default None\n        uncertainty_type : str, optional\n            type of uncertainty. Quantity uncertainty type must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/uncertainty_type), by default \"\"\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n\n        Returns\n        -------\n        None\n            create Quantity sub-object\n        \"\"\"\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, key=key, value=value, unit=unit, uncertainty=uncertainty, uncertainty_type=uncertainty_type)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @classmethod\n    def _from_json(cls, json_dict: dict):\n        # TODO: remove this temporary fix, once back end is working correctly\n        for key in [\"value\", \"uncertainty\"]:\n            try:\n                json_dict[key] = float(json_dict[key])\n            except KeyError:\n                pass\n        return super(Quantity, cls)._from_json(json_dict)\n\n    @beartype\n    def set_key_unit(self, new_key: str, new_unit: str) -&gt; None:\n        \"\"\"\n        set the Quantity key and unit attributes\n\n        Quantity key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/quantity_key)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_quantity.set_key_unit(new_key=\"mass\", new_unit=\"kg\")\n\n        Parameters\n        ----------\n        new_key : str\n            new Quantity key. Quantity key must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/quantity_key)\n        new_unit : str\n            new unit\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, key=new_key, unit=new_unit)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def key(self) -&gt; str:\n        \"\"\"\n        get the Quantity sub-object key attribute\n\n        [Quantity type](https://app.criptapp.org/vocab/quantity_key) must come from CRIPT controlled vocabulary\n\n        Returns\n        -------\n        str\n            this Quantity key attribute\n        \"\"\"\n        return self._json_attrs.key\n\n    @property\n    @beartype\n    def value(self) -&gt; Union[int, float, str]:\n        \"\"\"\n        amount of Material\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n        &gt;&gt;&gt; my_quantity.value = 1\n\n        Returns\n        -------\n        Union[int, float, str]\n            amount of Material\n        \"\"\"\n        return self._json_attrs.value  # type: ignore\n\n    @value.setter\n    @beartype\n    def value(self, new_value: Union[Number, str, None]) -&gt; None:\n        \"\"\"\n        set the amount of Material\n\n        Parameters\n        ----------\n        new_value : Union[int, float, str]\n            amount of Material\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, value=new_value)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def unit(self) -&gt; str:\n        \"\"\"\n        get the Quantity unit attribute\n\n        Returns\n        -------\n        str\n            unit for the Quantity value attribute\n        \"\"\"\n        return self._json_attrs.unit\n\n    @property\n    @beartype\n    def uncertainty(self) -&gt; Optional[Number]:\n        \"\"\"\n        get the uncertainty value\n\n        Returns\n        -------\n        Number\n            uncertainty value\n        \"\"\"\n        return self._json_attrs.uncertainty  # type: ignore\n\n    @property\n    @beartype\n    def uncertainty_type(self) -&gt; str:\n        \"\"\"\n        get the uncertainty type attribute for the Quantity sub-object\n\n        [Uncertainty type](https://app.criptapp.org/vocab/uncertainty_type) must come from CRIPT controlled vocabulary\n\n        Returns\n        -------\n        str\n            uncertainty type\n        \"\"\"\n        return self._json_attrs.uncertainty_type\n\n    @beartype\n    def set_uncertainty(self, uncertainty: Optional[Number], type: str) -&gt; None:\n        \"\"\"\n        set the `uncertainty value` and `uncertainty_type`\n\n        Uncertainty and uncertainty type are set at the same time to keep the value and type in sync\n\n        `uncertainty_type` must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/uncertainty_type)\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_quantity = cript.Quantity(\n        ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n        ... )\n\n        Parameters\n        ----------\n        uncertainty : Number\n            uncertainty value\n        type : str\n            type of uncertainty, uncertainty_type must come from\n            [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/uncertainty_type)\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, uncertainty=uncertainty, uncertainty_type=type)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.__init__","title":"<code>__init__(key, value, unit, uncertainty=None, uncertainty_type='', **kwargs)</code>","text":"<p>create Quantity sub-object</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>type of quantity. Quantity key must come from CRIPT Controlled Vocabulary</p> required <code>value</code> <code>Number</code> <p>amount of material</p> required <code>unit</code> <code>str</code> <p>unit for quantity</p> required <code>uncertainty</code> <code>Union[Number, None]</code> <p>uncertainty of value, by default None</p> <code>None</code> <code>uncertainty_type</code> <code>str</code> <p>type of uncertainty. Quantity uncertainty type must come from CRIPT Controlled Vocabulary, by default \"\"</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>create Quantity sub-object</p> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@beartype\ndef __init__(self, key: str, value: Number, unit: str, uncertainty: Optional[Number] = None, uncertainty_type: str = \"\", **kwargs):\n    \"\"\"\n    create Quantity sub-object\n\n    Parameters\n    ----------\n    key : str\n        type of quantity. Quantity key must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/quantity_key)\n    value : Number\n        amount of material\n    unit : str\n        unit for quantity\n    uncertainty : Union[Number, None], optional\n        uncertainty of value, by default None\n    uncertainty_type : str, optional\n        type of uncertainty. Quantity uncertainty type must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/uncertainty_type), by default \"\"\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_quantity = cript.Quantity(\n    ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n    ... )\n\n    Returns\n    -------\n    None\n        create Quantity sub-object\n    \"\"\"\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, key=key, value=value, unit=unit, uncertainty=uncertainty, uncertainty_type=uncertainty_type)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.key","title":"<code>key()</code>","text":"<p>get the Quantity sub-object key attribute</p> <p>Quantity type must come from CRIPT controlled vocabulary</p> <p>Returns:</p> Type Description <code>str</code> <p>this Quantity key attribute</p> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@property\n@beartype\ndef key(self) -&gt; str:\n    \"\"\"\n    get the Quantity sub-object key attribute\n\n    [Quantity type](https://app.criptapp.org/vocab/quantity_key) must come from CRIPT controlled vocabulary\n\n    Returns\n    -------\n    str\n        this Quantity key attribute\n    \"\"\"\n    return self._json_attrs.key\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.set_key_unit","title":"<code>set_key_unit(new_key, new_unit)</code>","text":"<p>set the Quantity key and unit attributes</p> <p>Quantity key must come from CRIPT Controlled Vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n&gt;&gt;&gt; my_quantity.set_key_unit(new_key=\"mass\", new_unit=\"kg\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>new_key</code> <code>str</code> <p>new Quantity key. Quantity key must come from CRIPT Controlled Vocabulary</p> required <code>new_unit</code> <code>str</code> <p>new unit</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@beartype\ndef set_key_unit(self, new_key: str, new_unit: str) -&gt; None:\n    \"\"\"\n    set the Quantity key and unit attributes\n\n    Quantity key must come from [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/quantity_key)\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_quantity = cript.Quantity(\n    ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n    ... )\n    &gt;&gt;&gt; my_quantity.set_key_unit(new_key=\"mass\", new_unit=\"kg\")\n\n    Parameters\n    ----------\n    new_key : str\n        new Quantity key. Quantity key must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/quantity_key)\n    new_unit : str\n        new unit\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, key=new_key, unit=new_unit)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.set_uncertainty","title":"<code>set_uncertainty(uncertainty, type)</code>","text":"<p>set the <code>uncertainty value</code> and <code>uncertainty_type</code></p> <p>Uncertainty and uncertainty type are set at the same time to keep the value and type in sync</p> <p><code>uncertainty_type</code> must come from CRIPT Controlled Vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_quantity = cript.Quantity(\n...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n... )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>uncertainty</code> <code>Number</code> <p>uncertainty value</p> required <code>type</code> <code>str</code> <p>type of uncertainty, uncertainty_type must come from CRIPT Controlled Vocabulary</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@beartype\ndef set_uncertainty(self, uncertainty: Optional[Number], type: str) -&gt; None:\n    \"\"\"\n    set the `uncertainty value` and `uncertainty_type`\n\n    Uncertainty and uncertainty type are set at the same time to keep the value and type in sync\n\n    `uncertainty_type` must come from\n    [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/uncertainty_type)\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_quantity = cript.Quantity(\n    ...     key=\"mass\", value=11.2, unit=\"kg\", uncertainty=0.2, uncertainty_type=\"stdev\"\n    ... )\n\n    Parameters\n    ----------\n    uncertainty : Number\n        uncertainty value\n    type : str\n        type of uncertainty, uncertainty_type must come from\n        [CRIPT Controlled Vocabulary](https://app.criptapp.org/vocab/uncertainty_type)\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, uncertainty=uncertainty, uncertainty_type=type)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.uncertainty","title":"<code>uncertainty()</code>","text":"<p>get the uncertainty value</p> <p>Returns:</p> Type Description <code>Number</code> <p>uncertainty value</p> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@property\n@beartype\ndef uncertainty(self) -&gt; Optional[Number]:\n    \"\"\"\n    get the uncertainty value\n\n    Returns\n    -------\n    Number\n        uncertainty value\n    \"\"\"\n    return self._json_attrs.uncertainty  # type: ignore\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.uncertainty_type","title":"<code>uncertainty_type()</code>","text":"<p>get the uncertainty type attribute for the Quantity sub-object</p> <p>Uncertainty type must come from CRIPT controlled vocabulary</p> <p>Returns:</p> Type Description <code>str</code> <p>uncertainty type</p> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@property\n@beartype\ndef uncertainty_type(self) -&gt; str:\n    \"\"\"\n    get the uncertainty type attribute for the Quantity sub-object\n\n    [Uncertainty type](https://app.criptapp.org/vocab/uncertainty_type) must come from CRIPT controlled vocabulary\n\n    Returns\n    -------\n    str\n        uncertainty type\n    \"\"\"\n    return self._json_attrs.uncertainty_type\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.unit","title":"<code>unit()</code>","text":"<p>get the Quantity unit attribute</p> <p>Returns:</p> Type Description <code>str</code> <p>unit for the Quantity value attribute</p> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@property\n@beartype\ndef unit(self) -&gt; str:\n    \"\"\"\n    get the Quantity unit attribute\n\n    Returns\n    -------\n    str\n        unit for the Quantity value attribute\n    \"\"\"\n    return self._json_attrs.unit\n</code></pre>"},{"location":"nodes/subobjects/quantity/#cript.nodes.subobjects.quantity.Quantity.value","title":"<code>value(new_value)</code>","text":"<p>set the amount of Material</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>Union[int, float, str]</code> <p>amount of Material</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/subobjects/quantity.py</code> <pre><code>@value.setter\n@beartype\ndef value(self, new_value: Union[Number, str, None]) -&gt; None:\n    \"\"\"\n    set the amount of Material\n\n    Parameters\n    ----------\n    new_value : Union[int, float, str]\n        amount of Material\n\n    Returns\n    -------\n    None\n    \"\"\"\n    new_attrs = replace(self._json_attrs, value=new_value)\n    self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/software_configuration/","title":"Software Configuration","text":""},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration","title":"<code>SoftwareConfiguration</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration--definition","title":"Definition","text":"<p>The software_configuration sub-object includes software and the set of algorithms to execute computation or computational_process.</p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration--can-be-added-to","title":"Can Be Added To:","text":"<ul> <li>Computation</li> <li>Computation_Process</li> </ul>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration--available-sub-objects","title":"Available sub-objects:","text":"<ul> <li>Algorithm</li> <li>Citation</li> </ul>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration--attributes","title":"Attributes","text":"keys type example description required vocab software Software software used True algorithms list[Algorithm] algorithms used notes str miscellaneous information, or custom data structure (e.g.; JSON) citation list[Citation] reference to a book, paper, or scholarly work"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration--json-representation","title":"JSON Representation","text":"<pre><code>{\n   \"node\":[\"SoftwareConfiguration\"],\n   \"uid\":\"_:f0dc3415-635d-4590-8b1f-cd65ad8ab3fe\"\n   \"software\":{\n      \"name\":\"SOMA\",\n      \"node\":[\"Software\"],\n      \"source\":\"https://gitlab.com/InnocentBug/SOMA\",\n      \"uid\":\"_:5bf9cb33-f029-4d1b-ba53-3602036e4f75\",\n      \"uuid\":\"5bf9cb33-f029-4d1b-ba53-3602036e4f75\",\n      \"version\":\"0.7.0\"\n   }\n}\n</code></pre> Source code in <code>src/cript/nodes/subobjects/software_configuration.py</code> <pre><code>class SoftwareConfiguration(UUIDBaseNode):\n    \"\"\"\n    ## Definition\n\n    The [software_configuration](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=24)\n    sub-object includes software and the set of algorithms to execute computation or computational_process.\n\n    ---\n\n    ## Can Be Added To:\n    * [Computation](../../primary_nodes/computation)\n    * [Computation_Process](../../primary_nodes/computation_process)\n\n    ## Available sub-objects:\n    * [Algorithm](../algorithm)\n    * [Citation](../citation)\n\n    ---\n\n    ## Attributes\n\n    | keys                                             | type            | example | description                                                      | required | vocab |\n    |--------------------------------------------------|-----------------|---------|------------------------------------------------------------------|----------|-------|\n    | software                                         | Software        |         | software used                                                    | True     |       |\n    | algorithms                                       | list[Algorithm] |         | algorithms used                                                  |          |       |\n    | notes                                            | str             |         | miscellaneous information, or custom data structure (e.g.; JSON) |          |       |\n    | citation                                         | list[Citation]  |         | reference to a book, paper, or scholarly work                    |          |       |\n\n\n    ## JSON Representation\n    ```json\n    {\n       \"node\":[\"SoftwareConfiguration\"],\n       \"uid\":\"_:f0dc3415-635d-4590-8b1f-cd65ad8ab3fe\"\n       \"software\":{\n          \"name\":\"SOMA\",\n          \"node\":[\"Software\"],\n          \"source\":\"https://gitlab.com/InnocentBug/SOMA\",\n          \"uid\":\"_:5bf9cb33-f029-4d1b-ba53-3602036e4f75\",\n          \"uuid\":\"5bf9cb33-f029-4d1b-ba53-3602036e4f75\",\n          \"version\":\"0.7.0\"\n       }\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        software: Optional[Union[Software, UIDProxy]] = None\n        algorithm: List[Union[Algorithm, UIDProxy]] = field(default_factory=list)\n        notes: str = \"\"\n        citation: List[Union[Citation, UIDProxy]] = field(default_factory=list)\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, software: Union[Software, UIDProxy], algorithm: Optional[List[Union[Algorithm, UIDProxy]]] = None, notes: str = \"\", citation: Union[List[Union[Citation, UIDProxy]], None] = None, **kwargs):\n        \"\"\"\n        Create Software_Configuration sub-object\n\n\n        Parameters\n        ----------\n        software : Software\n            Software node used for the Software_Configuration\n        algorithm : Union[List[Algorithm], None], optional\n            algorithm used for the Software_Configuration, by default None\n        notes : str, optional\n            plain text notes, by default \"\"\n        citation : Union[List[Citation], None], optional\n            list of Citation sub-object, by default None\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n\n        Returns\n        -------\n        None\n            Create Software_Configuration sub-object\n        \"\"\"\n        if algorithm is None:\n            algorithm = []\n        if citation is None:\n            citation = []\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, software=software, algorithm=algorithm, notes=notes, citation=citation)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def software(self) -&gt; Union[Software, None, UIDProxy]:\n        \"\"\"\n        Software used\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n        &gt;&gt;&gt; my_software_configuration.software = my_software\n\n        Returns\n        -------\n        Union[Software, None]\n            Software node used\n        \"\"\"\n        return self._json_attrs.software\n\n    @software.setter\n    @beartype\n    def software(self, new_software: Union[Software, None, UIDProxy]) -&gt; None:\n        \"\"\"\n        set the Software used\n\n        Parameters\n        ----------\n        new_software : Union[Software, None]\n            new Software node\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, software=new_software)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def algorithm(self) -&gt; List[Union[Algorithm, UIDProxy]]:\n        \"\"\"\n        list of Algorithms used\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n        &gt;&gt;&gt; my_software_configuration.algorithm = [my_algorithm]\n\n        Returns\n        -------\n        List[Algorithm]\n            list of algorithms used\n        \"\"\"\n        return self._json_attrs.algorithm.copy()\n\n    @algorithm.setter\n    @beartype\n    def algorithm(self, new_algorithm: List[Union[Algorithm, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the list of Algorithms\n\n        Parameters\n        ----------\n        new_algorithm : List[Algorithm]\n            list of algorithms\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, algorithm=new_algorithm)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def notes(self) -&gt; str:\n        \"\"\"\n        miscellaneous information, or custom data structure (e.g.; JSON). Notes can be written in plain text or JSON\n\n        Examples\n        --------\n        ### Plain Text\n        ```json\n        my_software_configuration.notes = \"these are my awesome notes!\"\n        ```\n\n        Examples\n        -------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n        &gt;&gt;&gt; my_software_configuration.notes = \"{'notes subject': 'notes contents'}\"\n\n        Returns\n        -------\n        str\n            notes\n        \"\"\"\n        return self._json_attrs.notes\n\n    @notes.setter\n    @beartype\n    def notes(self, new_notes: str) -&gt; None:\n        \"\"\"\n        set notes for Software_configuration\n\n        Parameters\n        ----------\n        new_notes : str\n            new notes in plain text or JSON\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, notes=new_notes)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def citation(self) -&gt; List[Union[Citation, UIDProxy]]:\n        \"\"\"\n        list of Citation sub-objects for the Software_Configuration\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; title = (\n        ...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n        ...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n        ... )\n        &gt;&gt;&gt; my_reference = cript.Reference(\n        ...     type=\"journal_article\",\n        ...     title=title,\n        ...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n        ...     journal=\"Computer Physics Communications\",\n        ...     publisher=\"Elsevier\",\n        ...     year=2019,\n        ...     pages=[463, 476],\n        ...     doi=\"10.1016/j.cpc.2018.08.011\",\n        ...     issn=\"0010-4655\",\n        ...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n        ... )\n        &gt;&gt;&gt; my_citation = Citation(\"reference\", my_reference)\n        &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n        &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n        &gt;&gt;&gt; my_software_configuration.citation = [my_citation]\n\n        Returns\n        -------\n        List[Citation]\n            list of Citations\n        \"\"\"\n        return self._json_attrs.citation.copy()\n\n    @citation.setter\n    @beartype\n    def citation(self, new_citation: List[Union[Citation, UIDProxy]]) -&gt; None:\n        \"\"\"\n        set the Citation sub-object\n\n        Parameters\n        ----------\n        new_citation : List[Citation]\n            new list of Citation sub-objects\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, citation=new_citation)\n        self._update_json_attrs_if_valid(new_attrs)\n</code></pre>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration.algorithm","title":"<code>algorithm: List[Union[Algorithm, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Algorithms used</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_algorithm = cript.Algorithm(key=\"mc_barostat\", type=\"barostat\")\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n&gt;&gt;&gt; my_software_configuration.algorithm = [my_algorithm]\n</code></pre> <p>Returns:</p> Type Description <code>List[Algorithm]</code> <p>list of algorithms used</p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration.citation","title":"<code>citation: List[Union[Citation, UIDProxy]]</code>  <code>property</code> <code>writable</code>","text":"<p>list of Citation sub-objects for the Software_Configuration</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; title = (\n...     \"Multi-architecture Monte-Carlo (MC) simulation of soft coarse-grained polymeric materials: \"\n...     \"Soft coarse grained Monte-Carlo Acceleration (SOMA)\"\n... )\n&gt;&gt;&gt; my_reference = cript.Reference(\n...     type=\"journal_article\",\n...     title=title,\n...     author=[\"Ludwig Schneider\", \"Marcus M\u00fcller\"],\n...     journal=\"Computer Physics Communications\",\n...     publisher=\"Elsevier\",\n...     year=2019,\n...     pages=[463, 476],\n...     doi=\"10.1016/j.cpc.2018.08.011\",\n...     issn=\"0010-4655\",\n...     website=\"https://www.sciencedirect.com/science/article/pii/S0010465518303072\",\n... )\n&gt;&gt;&gt; my_citation = Citation(\"reference\", my_reference)\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n&gt;&gt;&gt; my_software_configuration.citation = [my_citation]\n</code></pre> <p>Returns:</p> Type Description <code>List[Citation]</code> <p>list of Citations</p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration.notes","title":"<code>notes: str</code>  <code>property</code> <code>writable</code>","text":"<p>miscellaneous information, or custom data structure (e.g.; JSON). Notes can be written in plain text or JSON</p> <p>Examples:</p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration.notes--plain-text","title":"Plain Text","text":"<pre><code>my_software_configuration.notes = \"these are my awesome notes!\"\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n&gt;&gt;&gt; my_software_configuration.notes = \"{'notes subject': 'notes contents'}\"\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>notes</p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration.software","title":"<code>software: Union[Software, None, UIDProxy]</code>  <code>property</code> <code>writable</code>","text":"<p>Software used</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n&gt;&gt;&gt; my_software_configuration.software = my_software\n</code></pre> <p>Returns:</p> Type Description <code>Union[Software, None]</code> <p>Software node used</p>"},{"location":"nodes/subobjects/software_configuration/#cript.nodes.subobjects.software_configuration.SoftwareConfiguration.__init__","title":"<code>__init__(software, algorithm=None, notes='', citation=None, **kwargs)</code>","text":"<p>Create Software_Configuration sub-object</p> <p>Parameters:</p> Name Type Description Default <code>software</code> <code>Software</code> <p>Software node used for the Software_Configuration</p> required <code>algorithm</code> <code>Union[List[Algorithm], None]</code> <p>algorithm used for the Software_Configuration, by default None</p> <code>None</code> <code>notes</code> <code>str</code> <p>plain text notes, by default \"\"</p> <code>''</code> <code>citation</code> <code>Union[List[Citation], None]</code> <p>list of Citation sub-object, by default None</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n&gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>Create Software_Configuration sub-object</p> Source code in <code>src/cript/nodes/subobjects/software_configuration.py</code> <pre><code>@beartype\ndef __init__(self, software: Union[Software, UIDProxy], algorithm: Optional[List[Union[Algorithm, UIDProxy]]] = None, notes: str = \"\", citation: Union[List[Union[Citation, UIDProxy]], None] = None, **kwargs):\n    \"\"\"\n    Create Software_Configuration sub-object\n\n\n    Parameters\n    ----------\n    software : Software\n        Software node used for the Software_Configuration\n    algorithm : Union[List[Algorithm], None], optional\n        algorithm used for the Software_Configuration, by default None\n    notes : str, optional\n        plain text notes, by default \"\"\n    citation : Union[List[Citation], None], optional\n        list of Citation sub-object, by default None\n\n    Examples\n    ---------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_software = cript.Software(name=\"LAMMPS\", version=\"23Jun22\", source=\"lammps.org\")\n    &gt;&gt;&gt; my_software_configuration = cript.SoftwareConfiguration(software=my_software)\n\n    Returns\n    -------\n    None\n        Create Software_Configuration sub-object\n    \"\"\"\n    if algorithm is None:\n        algorithm = []\n    if citation is None:\n        citation = []\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, software=software, algorithm=algorithm, notes=notes, citation=citation)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/supporting_nodes/file/","title":"File","text":""},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File","title":"<code>File</code>","text":"<p>             Bases: <code>PrimaryBaseNode</code></p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File--definition","title":"Definition","text":"<p>The File node provides a link to scholarly work and allows users to specify in what way the work relates to that data. More specifically, users can specify that the data was directly extracted from, inspired by, derived from, etc.</p> <p>The file node is held in the Data node.</p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File--attributes","title":"Attributes","text":"Attribute Type Example Description Required name str <code>\"my file name\"</code> descriptive name for the file node True source str <code>\"path/to/my/file\"</code> or <code>\"https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system\"</code> source to the file can be URL or local path True type str <code>\"logs\"</code> Pick from CRIPT File Types True extension str <code>\".csv\"</code> file extension False data_dictionary str <code>\"my extra info in my data dictionary\"</code> set of information describing the contents, format, and structure of a file False notes str miscellaneous information, or custom data structure (e.g.; JSON)"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File--json","title":"JSON","text":"<pre><code>{\n    \"node\": [\"File\"],\n    \"name\": \"my file node name\",\n    \"source\": \"https://criptapp.org\",\n    \"type\": \"calibration\",\n    \"extension\": \".csv\",\n    \"data_dictionary\": \"my file's data dictionary\",\n}\n</code></pre> Source code in <code>src/cript/nodes/supporting_nodes/file.py</code> <pre><code>class File(PrimaryBaseNode):\n    \"\"\"\n    ## Definition\n\n    The [File node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001\n    .pdf#page=28) provides a link to scholarly work and allows users to specify in what way the work relates to that\n    data. More specifically, users can specify that the data was directly extracted from, inspired by, derived from,\n    etc.\n\n    The file node is held in the [Data node](../../primary_nodes/data).\n\n    ## Attributes\n\n    | Attribute       | Type | Example                                                                                               | Description                                                                 | Required |\n    |-----------------|------|-------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------|----------|\n    | name            | str  | `\"my file name\"`                                                                                      | descriptive name for the file node                                          | True     |\n    | source          | str  | `\"path/to/my/file\"` or `\"https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system\"` | source to the file can be URL or local path                                 | True     |\n    | type            | str  | `\"logs\"`                                                                                              | Pick from [CRIPT File Types](https://app.criptapp.org/vocab/file_type/)     | True     |\n    | extension       | str  | `\".csv\"`                                                                                              | file extension                                                              | False    |\n    | data_dictionary | str  | `\"my extra info in my data dictionary\"`                                                               | set of information describing the contents, format, and structure of a file | False    |\n    | notes           | str  |                                                                                                       | miscellaneous information, or custom data structure (e.g.; JSON)            |          |\n\n    ## JSON\n    ``` json\n    {\n        \"node\": [\"File\"],\n        \"name\": \"my file node name\",\n        \"source\": \"https://criptapp.org\",\n        \"type\": \"calibration\",\n        \"extension\": \".csv\",\n        \"data_dictionary\": \"my file's data dictionary\",\n    }\n    ```\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(PrimaryBaseNode.JsonAttributes):\n        \"\"\"\n        all file attributes\n        \"\"\"\n\n        source: str = \"\"\n        type: str = \"\"\n        extension: str = \"\"\n        data_dictionary: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, name: str, source: str, type: str, extension: str, data_dictionary: str = \"\", notes: str = \"\", **kwargs):\n        \"\"\"\n        create a File node\n\n        Parameters\n        ----------\n        name: str\n            File node name\n        source: str\n            link or path to local file\n        type: str\n            Pick a file type from CRIPT controlled vocabulary\n            [File types](https://app.criptapp.org/vocab/file_type)\n        extension:str\n            file extension\n        data_dictionary:str\n            extra information describing the file\n        notes: str\n            notes for the file node\n        **kwargs:dict\n            for internal use. Any extra data needed to create this file node\n            when deserializing the JSON response from the API\n\n        Examples\n        --------\n        ### Web URL File Node\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file name\",\n        ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n        ...     type=\"calibration\",\n        ...     extension=\".pdf\",\n        ...     data_dictionary=\"my file's data dictionary\",\n        ...     notes=\"my notes for this file\",\n        ... )\n\n        ### Local Source File Node\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file name\",\n        ...     source=\"/home/user/MIT/project/my_file.csv\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ...     data_dictionary=\"my file's data dictionary\",\n        ...     notes=\"my notes for this file\",\n        ... )\n        \"\"\"\n\n        super().__init__(name=name, notes=notes, **kwargs)\n\n        # setting every attribute except for source, which will be handled via setter\n        new_json_attrs = replace(\n            self._json_attrs,\n            type=type,\n            # always giving the function the required str regardless if the input `Path` or `str`\n            source=str(source),\n            extension=extension,\n            data_dictionary=data_dictionary,\n        )\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    def ensure_uploaded(self, api=None):\n        \"\"\"\n        Ensure that a local file is being uploaded into CRIPT accessible cloud storage.\n        After this call, non-local files (file names that do not start with `http`) are uploaded.\n        It is not necessary to call this function manually.\n        A saved project automatically ensures uploaded files, it is recommend to rely on the automatic upload.\n\n        Parameters\n        -----------\n        api: cript.API, optional\n           API object that performs the upload.\n           If None, the globally cached object is being used.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"/local/path/to/file\",\n        ...     type=\"calibration\",\n        ...     extension=\"csv\",\n        ... )\n        &gt;&gt;&gt; my_file.ensure_uploaded()   # doctest: +SKIP\n        &gt;&gt;&gt; my_file.source # changed to cloud storage object name   # doctest: +SKIP\n        \"\"\"\n\n        if _is_local_file(file_source=self.source):\n            # upload file source if local file\n            self.source = _upload_file_and_get_object_name(source=self.source)\n\n    # TODO can be made into a function\n\n    # --------------- Properties ---------------\n    @property\n    @beartype\n    def source(self) -&gt; str:\n        \"\"\"\n        The File node source can be set to be either a path to a local file on disk\n        or a URL path to a file on the web.\n\n        Examples\n        --------\n        URL File Source\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ... )\n        &gt;&gt;&gt; my_file.source = \"/home/user/project/my_file.csv\"\n\n        Returns\n        -------\n        source: str\n            A string representing the file source.\n        \"\"\"\n        return self._json_attrs.source\n\n    @source.setter\n    @beartype\n    def source(self, new_source: str) -&gt; None:\n        \"\"\"\n        sets the source of the file node\n        the source can either be a path to a file on local storage or a link to a file\n\n        1. checks if the file source is a link or a local file path\n        2. if the source is a link such as `https://wikipedia.com` then it sets the URL as the file source\n        3. if the file source is a local file path such as\n                `C:\\\\Users\\\\my_username\\\\Desktop\\\\cript\\\\file.txt`\n            1. then it opens the file and reads it\n            2. uploads it to the cloud storage\n            3. gets back a URL from where in the cloud the file is found\n            4. sets that as the source\n\n        Parameters\n        ----------\n        new_source: str\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file.source = \"https://pubs.acs.org/doi/10.1021/acscentsci.3c00011\"\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, source=new_source)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def type(self) -&gt; str:\n        \"\"\"\n        The [File type](https://app.criptapp.org/vocab/file_type) must come from CRIPT controlled vocabulary\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".csv\",\n        ... )\n        &gt;&gt;&gt; my_file.type = \"calibration\"\n\n        Returns\n        -------\n        file type: str\n            file type must come from [CRIPT controlled vocabulary](https://app.criptapp.org/vocab/file_type)\n        \"\"\"\n        return self._json_attrs.type\n\n    @type.setter\n    @beartype\n    def type(self, new_type: str) -&gt; None:\n        \"\"\"\n        set the file type\n\n        file type must come from CRIPT controlled vocabulary\n\n        Parameters\n        -----------\n        new_type: str\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file.type = \"computation_config\"\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # TODO check vocabulary is valid\n        # is_vocab_valid(\"file type\", self._json_attrs.type)\n        new_attrs = replace(self._json_attrs, type=new_type)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def extension(self) -&gt; str:\n        \"\"\"\n        The file extension property explicitly states what is the file extension of the file node.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".text\",\n        ... )\n        &gt;&gt;&gt; my_file.extension = \".csv\"\n\n        !!! Note \"file extensions must start with a dot\"\n            File extensions must start with a dot, for example `.csv` or `.pdf`\n\n        Returns\n        -------\n        extension: str\n            file extension\n        \"\"\"\n        return self._json_attrs.extension\n\n    @extension.setter\n    @beartype\n    def extension(self, new_extension) -&gt; None:\n        \"\"\"\n        sets the new file extension\n\n        Parameters\n        ----------\n        new_extension: str\n            new file extension to overwrite the current file extension\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file.extension = \".pdf\"\n\n        Returns\n        -------\n            None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, extension=new_extension)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @property\n    @beartype\n    def data_dictionary(self) -&gt; str:\n        # TODO data dictionary needs documentation describing it and how to use it\n        \"\"\"\n        The data dictionary contains additional information\n        that the scientist needs to describe their file.\n\n        Notes\n        ------\n        It is advised for this field to be written in JSON format\n\n        Examples\n        ---------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file name\",\n        ...     source=\"https://criptapp.org\",\n        ...     type=\"calibration\",\n        ...     extension=\".png\",\n        ... )\n        &gt;&gt;&gt; my_file.data_dictionary = \"{'notes': 'This is something that describes my file node.'}\"\n\n        Returns\n        -------\n        data_dictionary: str\n            the file data dictionary attribute\n        \"\"\"\n        return self._json_attrs.data_dictionary\n\n    @data_dictionary.setter\n    @beartype\n    def data_dictionary(self, new_data_dictionary: str) -&gt; None:\n        \"\"\"\n        Sets the data dictionary for the file node.\n\n        Parameters\n        ----------\n        new_data_dictionary: str\n            The new data dictionary to be set.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        new_attrs = replace(self._json_attrs, data_dictionary=new_data_dictionary)\n        self._update_json_attrs_if_valid(new_attrs)\n\n    @beartype\n    def download(\n        self,\n        destination_directory_path: Union[str, Path] = \".\",\n    ) -&gt; None:\n        \"\"\"\n        download this file to current working directory or a specific destination.\n        The file name will come from the file_node.name and the extension will come from file_node.extension\n\n        Examples\n        --------\n        &gt;&gt;&gt; import cript\n        &gt;&gt;&gt; my_file = cript.File(\n        ...     name=\"my file node name\",\n        ...     source=\"/local/path/to/file\",\n        ...     type=\"calibration\",\n        ...     extension=\".jpeg\",\n        ... )\n        &gt;&gt;&gt; my_file.ensure_uploaded()   # doctest: +SKIP\n        &gt;&gt;&gt; my_file.source # changed to cloud storage object name   # doctest: +SKIP\n        &gt;&gt;&gt; my_file.download()  # doctest: +SKIP\n\n        Notes\n        -----\n        Whether the file extension is written like `.csv` or `csv` the program will work correctly\n\n        Parameters\n        ----------\n        destination_directory_path: Union[str, Path]\n            where you want the file to be stored and what you want the name to be\n            by default it is the current working directory\n\n        Returns\n        -------\n        None\n        \"\"\"\n        from cript.api.api import _get_global_cached_api\n\n        api = _get_global_cached_api()\n\n        # convert the path from str to Path in case it was given as a str and resolve it to get the absolute path\n        existing_folder_path = Path(destination_directory_path).resolve()\n\n        # stripping dot from extension to make all extensions uniform, in case a user puts `.csv` or `csv` it will work\n        file_name = f\"{self.name}.{self.extension.lstrip('.')}\"\n\n        absolute_file_path = str((existing_folder_path / file_name).resolve())\n\n        api.download_file(file_source=self.source, destination_path=absolute_file_path)\n</code></pre>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.data_dictionary","title":"<code>data_dictionary: str</code>  <code>property</code> <code>writable</code>","text":"<p>The data dictionary contains additional information that the scientist needs to describe their file.</p> Notes <p>It is advised for this field to be written in JSON format</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".png\",\n... )\n&gt;&gt;&gt; my_file.data_dictionary = \"{'notes': 'This is something that describes my file node.'}\"\n</code></pre> <p>Returns:</p> Name Type Description <code>data_dictionary</code> <code>str</code> <p>the file data dictionary attribute</p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.extension","title":"<code>extension: str</code>  <code>property</code> <code>writable</code>","text":"<p>The file extension property explicitly states what is the file extension of the file node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".text\",\n... )\n&gt;&gt;&gt; my_file.extension = \".csv\"\n</code></pre> <p>file extensions must start with a dot</p> <p>File extensions must start with a dot, for example <code>.csv</code> or <code>.pdf</code></p> <p>Returns:</p> Name Type Description <code>extension</code> <code>str</code> <p>file extension</p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.source","title":"<code>source: str</code>  <code>property</code> <code>writable</code>","text":"<p>The File node source can be set to be either a path to a local file on disk or a URL path to a file on the web.</p> <p>Examples:</p> <p>URL File Source</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n... )\n&gt;&gt;&gt; my_file.source = \"/home/user/project/my_file.csv\"\n</code></pre> <p>Returns:</p> Name Type Description <code>source</code> <code>str</code> <p>A string representing the file source.</p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.type","title":"<code>type: str</code>  <code>property</code> <code>writable</code>","text":"<p>The File type must come from CRIPT controlled vocabulary</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file name\",\n...     source=\"https://criptapp.org\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n... )\n&gt;&gt;&gt; my_file.type = \"calibration\"\n</code></pre> <p>Returns:</p> Type Description <code>file type: str</code> <p>file type must come from CRIPT controlled vocabulary</p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all file attributes</p> Source code in <code>src/cript/nodes/supporting_nodes/file.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(PrimaryBaseNode.JsonAttributes):\n    \"\"\"\n    all file attributes\n    \"\"\"\n\n    source: str = \"\"\n    type: str = \"\"\n    extension: str = \"\"\n    data_dictionary: str = \"\"\n</code></pre>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.__init__","title":"<code>__init__(name, source, type, extension, data_dictionary='', notes='', **kwargs)</code>","text":"<p>create a File node</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>File node name</p> required <code>source</code> <code>str</code> <p>link or path to local file</p> required <code>type</code> <code>str</code> <p>Pick a file type from CRIPT controlled vocabulary File types</p> required <code>extension</code> <code>str</code> <p>file extension</p> required <code>data_dictionary</code> <code>str</code> <p>extra information describing the file</p> <code>''</code> <code>notes</code> <code>str</code> <p>notes for the file node</p> <code>''</code> <code>**kwargs</code> <p>for internal use. Any extra data needed to create this file node when deserializing the JSON response from the API</p> <code>{}</code> <p>Examples:</p>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.__init__--web-url-file-node","title":"Web URL File Node","text":"<pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file name\",\n...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n...     type=\"calibration\",\n...     extension=\".pdf\",\n...     data_dictionary=\"my file's data dictionary\",\n...     notes=\"my notes for this file\",\n... )\n</code></pre>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.__init__--local-source-file-node","title":"Local Source File Node","text":"<pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file name\",\n...     source=\"/home/user/MIT/project/my_file.csv\",\n...     type=\"calibration\",\n...     extension=\".csv\",\n...     data_dictionary=\"my file's data dictionary\",\n...     notes=\"my notes for this file\",\n... )\n</code></pre> Source code in <code>src/cript/nodes/supporting_nodes/file.py</code> <pre><code>@beartype\ndef __init__(self, name: str, source: str, type: str, extension: str, data_dictionary: str = \"\", notes: str = \"\", **kwargs):\n    \"\"\"\n    create a File node\n\n    Parameters\n    ----------\n    name: str\n        File node name\n    source: str\n        link or path to local file\n    type: str\n        Pick a file type from CRIPT controlled vocabulary\n        [File types](https://app.criptapp.org/vocab/file_type)\n    extension:str\n        file extension\n    data_dictionary:str\n        extra information describing the file\n    notes: str\n        notes for the file node\n    **kwargs:dict\n        for internal use. Any extra data needed to create this file node\n        when deserializing the JSON response from the API\n\n    Examples\n    --------\n    ### Web URL File Node\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_file = cript.File(\n    ...     name=\"my file name\",\n    ...     source=\"https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf\",\n    ...     type=\"calibration\",\n    ...     extension=\".pdf\",\n    ...     data_dictionary=\"my file's data dictionary\",\n    ...     notes=\"my notes for this file\",\n    ... )\n\n    ### Local Source File Node\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_file = cript.File(\n    ...     name=\"my file name\",\n    ...     source=\"/home/user/MIT/project/my_file.csv\",\n    ...     type=\"calibration\",\n    ...     extension=\".csv\",\n    ...     data_dictionary=\"my file's data dictionary\",\n    ...     notes=\"my notes for this file\",\n    ... )\n    \"\"\"\n\n    super().__init__(name=name, notes=notes, **kwargs)\n\n    # setting every attribute except for source, which will be handled via setter\n    new_json_attrs = replace(\n        self._json_attrs,\n        type=type,\n        # always giving the function the required str regardless if the input `Path` or `str`\n        source=str(source),\n        extension=extension,\n        data_dictionary=data_dictionary,\n    )\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.download","title":"<code>download(destination_directory_path='.')</code>","text":"<p>download this file to current working directory or a specific destination. The file name will come from the file_node.name and the extension will come from file_node.extension</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"/local/path/to/file\",\n...     type=\"calibration\",\n...     extension=\".jpeg\",\n... )\n&gt;&gt;&gt; my_file.ensure_uploaded()\n&gt;&gt;&gt; my_file.source # changed to cloud storage object name\n&gt;&gt;&gt; my_file.download()\n</code></pre> Notes <p>Whether the file extension is written like <code>.csv</code> or <code>csv</code> the program will work correctly</p> <p>Parameters:</p> Name Type Description Default <code>destination_directory_path</code> <code>Union[str, Path]</code> <p>where you want the file to be stored and what you want the name to be by default it is the current working directory</p> <code>'.'</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/cript/nodes/supporting_nodes/file.py</code> <pre><code>@beartype\ndef download(\n    self,\n    destination_directory_path: Union[str, Path] = \".\",\n) -&gt; None:\n    \"\"\"\n    download this file to current working directory or a specific destination.\n    The file name will come from the file_node.name and the extension will come from file_node.extension\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_file = cript.File(\n    ...     name=\"my file node name\",\n    ...     source=\"/local/path/to/file\",\n    ...     type=\"calibration\",\n    ...     extension=\".jpeg\",\n    ... )\n    &gt;&gt;&gt; my_file.ensure_uploaded()   # doctest: +SKIP\n    &gt;&gt;&gt; my_file.source # changed to cloud storage object name   # doctest: +SKIP\n    &gt;&gt;&gt; my_file.download()  # doctest: +SKIP\n\n    Notes\n    -----\n    Whether the file extension is written like `.csv` or `csv` the program will work correctly\n\n    Parameters\n    ----------\n    destination_directory_path: Union[str, Path]\n        where you want the file to be stored and what you want the name to be\n        by default it is the current working directory\n\n    Returns\n    -------\n    None\n    \"\"\"\n    from cript.api.api import _get_global_cached_api\n\n    api = _get_global_cached_api()\n\n    # convert the path from str to Path in case it was given as a str and resolve it to get the absolute path\n    existing_folder_path = Path(destination_directory_path).resolve()\n\n    # stripping dot from extension to make all extensions uniform, in case a user puts `.csv` or `csv` it will work\n    file_name = f\"{self.name}.{self.extension.lstrip('.')}\"\n\n    absolute_file_path = str((existing_folder_path / file_name).resolve())\n\n    api.download_file(file_source=self.source, destination_path=absolute_file_path)\n</code></pre>"},{"location":"nodes/supporting_nodes/file/#cript.nodes.supporting_nodes.file.File.ensure_uploaded","title":"<code>ensure_uploaded(api=None)</code>","text":"<p>Ensure that a local file is being uploaded into CRIPT accessible cloud storage. After this call, non-local files (file names that do not start with <code>http</code>) are uploaded. It is not necessary to call this function manually. A saved project automatically ensures uploaded files, it is recommend to rely on the automatic upload.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <p>API object that performs the upload. If None, the globally cached object is being used.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import cript\n&gt;&gt;&gt; my_file = cript.File(\n...     name=\"my file node name\",\n...     source=\"/local/path/to/file\",\n...     type=\"calibration\",\n...     extension=\"csv\",\n... )\n&gt;&gt;&gt; my_file.ensure_uploaded()\n&gt;&gt;&gt; my_file.source # changed to cloud storage object name\n</code></pre> Source code in <code>src/cript/nodes/supporting_nodes/file.py</code> <pre><code>def ensure_uploaded(self, api=None):\n    \"\"\"\n    Ensure that a local file is being uploaded into CRIPT accessible cloud storage.\n    After this call, non-local files (file names that do not start with `http`) are uploaded.\n    It is not necessary to call this function manually.\n    A saved project automatically ensures uploaded files, it is recommend to rely on the automatic upload.\n\n    Parameters\n    -----------\n    api: cript.API, optional\n       API object that performs the upload.\n       If None, the globally cached object is being used.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import cript\n    &gt;&gt;&gt; my_file = cript.File(\n    ...     name=\"my file node name\",\n    ...     source=\"/local/path/to/file\",\n    ...     type=\"calibration\",\n    ...     extension=\"csv\",\n    ... )\n    &gt;&gt;&gt; my_file.ensure_uploaded()   # doctest: +SKIP\n    &gt;&gt;&gt; my_file.source # changed to cloud storage object name   # doctest: +SKIP\n    \"\"\"\n\n    if _is_local_file(file_source=self.source):\n        # upload file source if local file\n        self.source = _upload_file_and_get_object_name(source=self.source)\n</code></pre>"},{"location":"nodes/supporting_nodes/group/","title":"Group","text":""},{"location":"nodes/supporting_nodes/group/#group-node","title":"Group Node","text":""},{"location":"nodes/supporting_nodes/user/","title":"User","text":""},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User","title":"<code>User</code>","text":"<p>             Bases: <code>UUIDBaseNode</code></p> <p>The User node represents any researcher or individual who interacts with the CRIPT platform. It serves two main purposes: 1. It plays a core role in permissions (access control) 1. It provides a traceable link to the individual who has contributed or edited data within the database</p> attribute type example description required vocab url str unique ID of the node True username str \"john_doe\" User\u2019s name True email str \"user@cript.com\" email of the user True orcid str \"0000-0000-0000-0000\" ORCID ID of the user True updated_at datetime* 2023-03-06 18:45:23.450248 last date the node was modified (UTC time) True created_at datetime* 2023-03-06 18:45:23.450248 date it was created (UTC time) True"},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User--json","title":"JSON","text":"<pre><code>{\n    \"node\": \"User\",\n    \"username\": \"my username\",\n    \"email\": \"user@email.com\",\n    \"orcid\": \"0000-0000-0000-0001\",\n}\n</code></pre> Warnings <ul> <li>A User cannot be created or modified using the Python SDK.</li> <li>A User node is a read-only node that can only be deserialized from API JSON response to Python node.</li> <li>The User node cannot be instantiated and within the Python SDK.</li> <li>Attempting to edit the user node will result in an <code>Attribute Error</code></li> </ul> Source code in <code>src/cript/nodes/supporting_nodes/user.py</code> <pre><code>class User(UUIDBaseNode):\n    \"\"\"\n    The [User node](https://pubs.acs.org/doi/suppl/10.1021/acscentsci.3c00011/suppl_file/oc3c00011_si_001.pdf#page=27)\n    represents any researcher or individual who interacts with the CRIPT platform.\n    It serves two main purposes:\n    1. It plays a core role in permissions (access control)\n    1. It provides a traceable link to the individual who has contributed or edited data within the database\n\n\n    | attribute  | type        | example                    | description                                | required | vocab |\n    |------------|-------------|----------------------------|--------------------------------------------|----------|-------|\n    | url        | str         |                            | unique ID of the node                      | True     |       |\n    | username   | str         | \"john_doe\"                 | User\u2019s name                                | True     |       |\n    | email      | str         | \"user@cript.com\"           | email of the user                          | True     |       |\n    | orcid      | str         | \"0000-0000-0000-0000\"      | ORCID ID of the user                       | True     |       |\n    | updated_at | datetime*   | 2023-03-06 18:45:23.450248 | last date the node was modified (UTC time) | True     |       |\n    | created_at | datetime*   | 2023-03-06 18:45:23.450248 | date it was created (UTC time)             | True     |       |\n\n\n    ## JSON\n    ```json\n    {\n        \"node\": \"User\",\n        \"username\": \"my username\",\n        \"email\": \"user@email.com\",\n        \"orcid\": \"0000-0000-0000-0001\",\n    }\n    ```\n\n    Warnings\n    -------\n    * A User cannot be created or modified using the Python SDK.\n    * A User node is a **read-only** node that can only be deserialized from API JSON response to Python node.\n    * The User node cannot be instantiated and within the Python SDK.\n    * Attempting to edit the user node will result in an `Attribute Error`\n\n    \"\"\"\n\n    @dataclass(frozen=True)\n    class JsonAttributes(UUIDBaseNode.JsonAttributes):\n        \"\"\"\n        all User attributes\n        \"\"\"\n\n        email: Optional[str] = \"\"\n        model_version: str = \"\"\n        orcid: Optional[str] = \"\"\n        picture: str = \"\"\n        username: str = \"\"\n\n    _json_attrs: JsonAttributes = JsonAttributes()\n\n    @beartype\n    def __init__(self, username: str, email: Optional[str] = \"\", orcid: Optional[str] = \"\", **kwargs):\n        \"\"\"\n        Json from CRIPT API to be converted to a node\n        optionally the group can be None if the user doesn't have a group\n\n        Parameters\n        ----------\n        username: str\n            user username\n        email: str\n            user email\n        orcid: str\n            user ORCID\n        \"\"\"\n        super().__init__(**kwargs)\n        new_json_attrs = replace(self._json_attrs, username=username, email=email, orcid=orcid)\n        self._update_json_attrs_if_valid(new_json_attrs)\n\n    @property\n    @beartype\n    def created_at(self) -&gt; str:\n        return self._json_attrs.created_at\n\n    @property\n    @beartype\n    def email(self) -&gt; Union[str, None]:\n        \"\"\"\n        user's email\n\n        Raises\n        ------\n        AttributeError\n\n        Returns\n        -------\n        user email: str\n            User node email\n        \"\"\"\n        return self._json_attrs.email\n\n    @property\n    @beartype\n    def model_version(self) -&gt; str:\n        return self._json_attrs.model_version\n\n    @property\n    @beartype\n    def orcid(self) -&gt; Union[str, None]:\n        \"\"\"\n        users [ORCID](https://orcid.org/)\n\n        Raises\n        ------\n        AttributeError\n\n        Returns\n        -------\n        ORCID: str\n            user's ORCID\n        \"\"\"\n        return self._json_attrs.orcid\n\n    @property\n    @beartype\n    def picture(self) -&gt; str:\n        return self._json_attrs.picture\n\n    @property\n    @beartype\n    def updated_at(self) -&gt; str:\n        return self._json_attrs.updated_at\n\n    @property\n    @beartype\n    def username(self) -&gt; str:\n        \"\"\"\n        username of the User node\n\n        Raises\n        ------\n        AttributeError\n\n        Returns\n        -------\n        username: str\n            username of the User node\n        \"\"\"\n        return self._json_attrs.username\n</code></pre>"},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User.email","title":"<code>email: Union[str, None]</code>  <code>property</code>","text":"<p>user's email</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Returns:</p> Type Description <code>user email: str</code> <p>User node email</p>"},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User.orcid","title":"<code>orcid: Union[str, None]</code>  <code>property</code>","text":"<p>users ORCID</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Returns:</p> Name Type Description <code>ORCID</code> <code>str</code> <p>user's ORCID</p>"},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User.username","title":"<code>username: str</code>  <code>property</code>","text":"<p>username of the User node</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Returns:</p> Name Type Description <code>username</code> <code>str</code> <p>username of the User node</p>"},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User.JsonAttributes","title":"<code>JsonAttributes</code>  <code>dataclass</code>","text":"<p>             Bases: <code>JsonAttributes</code></p> <p>all User attributes</p> Source code in <code>src/cript/nodes/supporting_nodes/user.py</code> <pre><code>@dataclass(frozen=True)\nclass JsonAttributes(UUIDBaseNode.JsonAttributes):\n    \"\"\"\n    all User attributes\n    \"\"\"\n\n    email: Optional[str] = \"\"\n    model_version: str = \"\"\n    orcid: Optional[str] = \"\"\n    picture: str = \"\"\n    username: str = \"\"\n</code></pre>"},{"location":"nodes/supporting_nodes/user/#cript.nodes.supporting_nodes.user.User.__init__","title":"<code>__init__(username, email='', orcid='', **kwargs)</code>","text":"<p>Json from CRIPT API to be converted to a node optionally the group can be None if the user doesn't have a group</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>user username</p> required <code>email</code> <code>Optional[str]</code> <p>user email</p> <code>''</code> <code>orcid</code> <code>Optional[str]</code> <p>user ORCID</p> <code>''</code> Source code in <code>src/cript/nodes/supporting_nodes/user.py</code> <pre><code>@beartype\ndef __init__(self, username: str, email: Optional[str] = \"\", orcid: Optional[str] = \"\", **kwargs):\n    \"\"\"\n    Json from CRIPT API to be converted to a node\n    optionally the group can be None if the user doesn't have a group\n\n    Parameters\n    ----------\n    username: str\n        user username\n    email: str\n        user email\n    orcid: str\n        user ORCID\n    \"\"\"\n    super().__init__(**kwargs)\n    new_json_attrs = replace(self._json_attrs, username=username, email=email, orcid=orcid)\n    self._update_json_attrs_if_valid(new_json_attrs)\n</code></pre>"},{"location":"tutorial/cript_installation_guide/","title":"CRIPT Installation Guide","text":""},{"location":"tutorial/cript_installation_guide/#how-to-install-cript","title":"How to Install CRIPT","text":"<p>Abstract</p> <p>This page will give you a through guide on how to install the  CRIPT Python SDK on your system.</p>"},{"location":"tutorial/cript_installation_guide/#steps","title":"Steps","text":"<ol> <li>Install Python 3.8+</li> <li> <p>Create a virtual environment</p> <p>It is best practice to create a dedicated python virtual environment for each python project</p> Windows: Mac &amp;  Linux: <pre><code>python -m venv .\\venv\n</code></pre> <pre><code>python3 -m venv ./venv\n</code></pre> </li> <li> <p>Activate your virtual environment</p> Windows: Mac &amp;  Linux: <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>source venv/bin/activate\n</code></pre> </li> <li> <p>Install CRIPT from Python Package Index (PyPI) <pre><code> pip install cript\n</code></pre></p> </li> <li>Create your CRIPT Script!</li> </ol> Install Package From our GitHub <p>Please note that it is also possible to install this package from our  GitHub.</p> <p>Formula: <code>pip install git+[repository URL]@[branch or tag]</code></p> <p>Install from Main:  <code>pip install git+https://github.com/C-Accel-CRIPT/Python-SDK@main</code></p> <p>or to download the latest in development code <code>pip install git+https://github.com/C-Accel-CRIPT/Python-SDK@develop</code></p>"},{"location":"tutorial/how_to_get_api_token/","title":"CRIPT API Token","text":"<p>Abstract</p> <p>This page shows the steps to acquiring an API Token to connect to the CRIPT platform</p> <p></p> <p>The token is needed because we need to authenticate the user before saving any of their data</p> <p>Token Security</p> <p>It is highly recommended that you store your API tokens in a safe location and read it into your code   Hard-coding API tokens directly into the code can pose security risks,   as the token might be exposed if the code is shared or stored in a version control system.</p> <p>Anyone that has access to your tokens can impersonate you on the CRIPT platform</p> <p></p> <p> Security Settings    under the profile icon dropdown </p> <p>To get your token:</p> <ol> <li>please visit your Security Settings under the profile    icon dropdown on the top right</li> <li>Click on the copy button next to the API Token to copy it to clipboard</li> <li>Now you can paste it into the <code>API Token</code> field</li> </ol> <p>Example:</p> <pre><code>API Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n\nStorage Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gU21pdGgiLCJpYXQiOjE1MTYyMzkwMjJ9.Q_w2AVguPRU2KskCXwR7ZHl09TQXEntfEA8Jj2_Jyew\n</code></pre>"}]}